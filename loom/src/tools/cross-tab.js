// ═══════════════════════════════════════════════════════════════════════════
// CROSS-TAB MESH TOOLS — AgentMesh P2P (between browser tabs)
// ═══════════════════════════════════════════════════════════════════════════

import { tool, z } from '../vendor/strands.js';

export const invokeMeshAgentTool = tool({ name: 'invoke_mesh_agent', description: 'Send a prompt to an agent in ANOTHER browser tab.', inputSchema: z.object({ target: z.string(), prompt: z.string() }), callback: async (input) => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; try { const r = await window.AgentMesh.invoke(input.target, input.prompt); return { success: true, target: input.target, result: r.result || r }; } catch (e) { return { error: e.message }; } } });
export const listMeshPeersTool = tool({ name: 'list_mesh_peers', description: 'List all connected browser tabs', inputSchema: z.object({}), callback: async () => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; const peers = window.AgentMesh.getPeers(); return { myPage: window.AgentMesh.currentPage.id, peerCount: peers.length, peers: peers.map(p => ({ id: p.id, label: p.label, tabId: p.tabId })), availableTargets: [...new Set(peers.map(p => p.id))] }; } });
export const broadcastMeshTool = tool({ name: 'broadcast_mesh', description: 'Send message to ALL connected tabs', inputSchema: z.object({ message: z.string() }), callback: async (input) => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; try { const r = await window.AgentMesh.invoke('all', input.message); return { success: true, responses: r }; } catch (e) { return { error: e.message }; } } });
export const addToMeshRingTool = tool({ name: 'add_to_mesh_ring', description: 'Share context visible to ALL agents in ALL tabs', inputSchema: z.object({ text: z.string(), agentType: z.string().optional() }), callback: async (input) => { if (!window.AgentMesh?.addToRingContext) return { error: 'AgentMesh not available' }; window.AgentMesh.addToRingContext('multi-agent', input.agentType || 'multi', input.text); return { success: true, added: input.text.slice(0, 100) }; } });
export const getMeshRingTool = tool({ name: 'get_mesh_ring', description: 'See what agents in other tabs are working on', inputSchema: z.object({ maxEntries: z.number().optional() }), callback: async (input) => { if (!window.AgentMesh?.getRingContext) return { error: 'AgentMesh not available' }; const entries = window.AgentMesh.getRingContext(); return { totalEntries: entries.length, recent: entries.slice(-(input.maxEntries || 10)).map(e => ({ agentId: e.agentId, type: e.agentType, text: e.text.slice(0, 200) })) }; } });

export const MESH_TOOLS = [invokeMeshAgentTool, listMeshPeersTool, broadcastMeshTool, addToMeshRingTool, getMeshRingTool];
