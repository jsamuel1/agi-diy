<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>agi.diy</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="agi.diy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="description" content="Build your own AGI. Strands Agent running entirely in your browser.">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="icon-192.svg">
    <link rel="apple-touch-icon" sizes="152x152" href="icon-192.svg">
    <link rel="apple-touch-icon" sizes="180x180" href="icon-192.svg">
    <link rel="apple-touch-icon" sizes="167x167" href="icon-192.svg">
    
    <!-- Splash screens for iOS -->
    <meta name="apple-mobile-web-app-title" content="agi.diy">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óà</text></svg>">
    
    <!-- Marked.js for Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Google Font for clean typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            --bg: #0a0a0a;
            --bg-elevated: #111111;
            --glass: rgba(255,255,255,0.03);
            --glass-border: rgba(255,255,255,0.06);
            --glass-hover: rgba(255,255,255,0.08);
            --text: rgba(255,255,255,0.92);
            --text-secondary: rgba(255,255,255,0.55);
            --text-tertiary: rgba(255,255,255,0.35);
            --accent: rgba(255,255,255,0.9);
            --divider: rgba(255,255,255,0.08);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            font-weight: 400;
            letter-spacing: -0.01em;
            touch-action: pan-x pan-y; /* Prevent double-tap zoom */
            -webkit-text-size-adjust: 100%; /* Prevent text size adjustment */
        }

        /* Map background mode - transparent app overlay, NO BLUR */
        html.map-mode,
        body.map-mode {
            background: transparent !important;
            background-color: transparent !important;
            --ui-opacity: 0.7;
        }
        body.map-mode .app {
            background: transparent !important;
            background-color: transparent !important;
            position: relative;
            z-index: 1;
        }
        body.map-mode .messages-container {
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.map-mode .messages-inner {
            background: transparent !important;
        }
        body.map-mode .header {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        body.map-mode .input-container {
            background: transparent !important;
        }
        body.map-mode .input-field {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        body.map-mode .send-btn {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.map-mode .message {
            background: transparent !important;
        }
        body.map-mode .message.system {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.map-mode .message.assistant .message-content {
            background: rgba(0, 0, 0, calc(var(--ui-opacity, 0.7) - 0.2));
            padding: 12px 16px;
            border-radius: 12px;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.map-mode .tool-block {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.map-mode .dynamic-ui {
            background: rgba(0, 0, 0, var(--ui-opacity, 0.7)) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        
        /* Map background container */
        #map-background {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: -1 !important;
            pointer-events: none !important;
            opacity: 1 !important;
        }

        ::selection {
            background: rgba(255,255,255,0.15);
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

        .app { 
            display: flex; 
            flex-direction: column; 
            height: 100vh;
            max-width: 100%;
        }

        /* Header - minimal floating glass */
        .header {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: var(--glass);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border: 1px solid var(--glass-border);
            border-radius: 100px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            z-index: 100;
            padding-top: calc(12px + env(safe-area-inset-top));
            min-width: 400px;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: var(--text);
        }

        .brand-dot {
            color: var(--text-tertiary);
        }
        
        .header-divider {
            width: 1px;
            height: 16px;
            background: var(--divider);
        }

        .header-btn {
            padding: 6px 14px;
            border-radius: 100px;
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        .header-btn:hover { 
            color: var(--text);
            background: var(--glass);
        }

        #sdkStatus {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 500;
        }

        /* Messages Container */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 100px 0 20px;
            padding-bottom: calc(80px + env(safe-area-inset-bottom)); /* Space for floating input */
        }

        .messages-inner {
            max-width: 720px;
            margin: 0 auto;
            padding: 0 32px;
        }

        /* Message - floating, left-aligned, no bubbles */
        .message {
            margin-bottom: 48px;
            animation: messageIn 0.4s ease;
            position: relative;
        }
        
        @keyframes messageIn { 
            from { opacity: 0; transform: translateY(12px); } 
            to { opacity: 1; transform: translateY(0); }
        }

        .message-role {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            margin-bottom: 12px;
        }

        .message-content {
            font-size: 15px;
            line-height: 1.8;
            color: var(--text);
        }

        .message.user .message-content {
            color: var(--text-secondary);
        }

        .message.assistant .message-content {
            color: var(--text);
        }

        .message.system {
            padding: 24px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            backdrop-filter: blur(20px);
        }

        .message.system .message-content {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .message.error .message-content {
            color: rgba(255,120,120,0.9);
        }

        /* Tool Block - glass card */
        .tool-block {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
            backdrop-filter: blur(20px);
        }

        .tool-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 4px;
        }

        .tool-name {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .tool-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }

        .tool-status.running { animation: pulse 1.5s infinite ease-in-out; background: var(--text); }
        .tool-status.error { background: rgba(255,120,120,0.8); }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .tool-input {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 11px;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-tertiary);
            margin-top: 12px;
        }

        /* Dynamic UI Container */
        .dynamic-ui {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 24px;
            margin: 24px 0;
            backdrop-filter: blur(20px);
        }

        /* Markdown Rendering */
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            margin: 24px 0 12px;
            font-weight: 600;
            color: var(--text);
            letter-spacing: -0.02em;
        }
        .markdown-content h1 { font-size: 20px; }
        .markdown-content h2 { font-size: 17px; }
        .markdown-content h3 { font-size: 15px; }
        
        .markdown-content p { margin: 12px 0; }
        
        .markdown-content code {
            background: rgba(255,255,255,0.06);
            padding: 3px 7px;
            border-radius: 5px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }
        .markdown-content pre {
            background: rgba(0,0,0,0.4);
            padding: 16px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 16px 0;
            border: 1px solid var(--glass-border);
        }
        .markdown-content pre code { 
            background: none; 
            padding: 0;
            color: var(--text-secondary);
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 12px 0;
            padding-left: 24px;
        }
        .markdown-content li {
            margin: 6px 0;
            color: var(--text-secondary);
        }
        
        .markdown-content a {
            color: var(--text);
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-color: var(--text-tertiary);
        }
        .markdown-content a:hover {
            text-decoration-color: var(--text);
        }

        /* Input Area - floating glass */
        .input-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 16px 24px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            background: transparent;
            pointer-events: none; /* Allow clicks through container */
        }

        .input-wrapper {
            max-width: 720px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto; /* Re-enable clicks on actual input */
        }
        
        .vision-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .input-field {
            flex: 1;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 16px 20px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            font-family: inherit;
            resize: none;
            min-height: 56px;
            max-height: 200px;
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            -webkit-appearance: none; /* Prevents iOS styling */
            appearance: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        .input-field:focus { 
            outline: none; 
            border-color: rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255,255,255,0.1);
        }
        .input-field::placeholder { color: var(--text-tertiary); }

        .send-btn {
            width: 56px;
            height: 56px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            background: rgba(10, 10, 10, 0.85);
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        .send-btn:hover { 
            background: rgba(30, 30, 30, 0.9);
            color: var(--text);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        .send-btn:disabled { 
            opacity: 0.3; 
            cursor: not-allowed;
        }

        /* Settings Modal - glass */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active { display: flex; }

        .modal-content {
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            max-width: 560px;
            max-height: 85vh;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 24px 28px;
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title { 
            font-size: 15px; 
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: transparent;
            color: var(--text-tertiary);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .modal-close:hover { 
            background: var(--glass); 
            color: var(--text);
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 28px;
        }

        .form-group { margin-bottom: 24px; }
        .form-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            margin-bottom: 10px;
        }
        .form-input {
            width: 100%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 14px 16px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            font-family: inherit;
            transition: border-color 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
        }
        .form-input:focus { 
            outline: none; 
            border-color: rgba(255,255,255,0.15);
        }
        textarea.form-input { 
            min-height: 120px; 
            resize: vertical; 
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 16px; /* Keep 16px to prevent iOS zoom */
            line-height: 1.6;
        }

        .btn {
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }
        .btn:hover { 
            background: var(--glass-hover);
            color: var(--text);
        }
        .btn-primary { 
            background: var(--text); 
            color: var(--bg); 
            border-color: var(--text);
        }
        .btn-primary:hover { 
            background: rgba(255,255,255,0.85);
        }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 28px;
            padding: 4px;
            background: var(--glass);
            border-radius: 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .tabs::-webkit-scrollbar {
            display: none;
        }
        .tab {
            flex: 0 0 auto;
            padding: 10px 16px;
            border-radius: 7px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            white-space: nowrap;
        }
        .tab:hover { color: var(--text-secondary); }
        .tab.active { 
            background: var(--bg);
            color: var(--text);
        }
        
        @media (max-width: 640px) {
            .tabs {
                margin-bottom: 20px;
                padding: 3px;
            }
            .tab {
                padding: 8px 12px;
                font-size: 12px;
            }
            .modal-content {
                max-height: 90vh;
                border-radius: 16px;
            }
            .modal-body {
                padding: 20px;
            }
            .modal-header {
                padding: 16px 20px;
            }
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Thinking indicator */
        .thinking {
            display: flex;
            gap: 8px;
            padding: 8px 0;
            align-items: center;
        }
        .thinking-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); opacity: 0.3; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 12px 20px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            font-size: 13px;
            color: var(--text-secondary);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 300;
        }
        .toast.show { 
            transform: translateX(-50%) translateY(0); 
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 640px) {
            .header {
                left: 16px;
                right: 16px;
                transform: none;
                border-radius: 16px;
                gap: 8px;
                padding: 10px 16px;
                padding-top: calc(10px + env(safe-area-inset-top));
                min-width: auto;
            }
            .header-left {
                gap: 8px;
                flex: 1;
                min-width: 0;
            }
            .header-right {
                gap: 4px;
                flex-shrink: 0;
            }
            .header-btn {
                padding: 6px 10px;
                font-size: 12px;
                flex-shrink: 0;
            }
            .header-divider {
                display: none;
            }
            .brand {
                font-size: 13px;
                flex-shrink: 0;
            }
            #sdkStatus {
                font-size: 10px;
                flex-shrink: 1;
                max-width: 80px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            .messages-inner {
                padding: 0 20px;
            }
            .input-container {
                padding: 12px 16px;
                padding-bottom: calc(12px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-left">
                <span class="brand">agi<span class="brand-dot">.</span>diy</span>
                <div class="header-divider"></div>
                <span id="sdkStatus">loading...</span>
            </div>
            <div class="header-right">
                <button class="header-btn" id="notifyBtn" title="Enable notifications">üîî</button>
                <button class="header-btn" id="clearBtn">clear</button>
                <button class="header-btn" id="settingsBtn">settings</button>
            </div>
        </header>

        <div class="messages-container" id="chatContainer">
            <div class="messages-inner" id="messagesInner">
                <div class="message system">
                    <div class="message-content">
                        Build your own AGI. Strands Agent running entirely in your browser.
                        <br><br>
                        Open console for documentation.
                    </div>
                </div>
            </div>
        </div>

        <div class="input-container">
            <div class="input-wrapper" style="flex-direction:column;gap:8px;">
                <!-- Vision Controls Row - ABOVE input -->
                <div class="vision-controls" id="visionControls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;width:100%;">
                    <!-- Image upload, screen capture, ambient mode will be injected here -->
                </div>
                <!-- Input Row -->
                <div style="display:flex;gap:12px;align-items:flex-end;width:100%;">
                    <textarea 
                        class="input-field" 
                        id="inputField" 
                        placeholder="Ask anything..." 
                        rows="1"
                        disabled
                    ></textarea>
                    <button class="send-btn" id="sendBtn" disabled>
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Settings</span>
                <button class="modal-close" id="modalCloseBtn">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="tabs">
                    <button class="tab active" data-tab="credentials">API</button>
                    <button class="tab" data-tab="google">Google</button>
                    <button class="tab" data-tab="system">System</button>
                    <button class="tab" data-tab="tools">Tools</button>
                    <button class="tab" data-tab="context">Context</button>
                    <button class="tab" data-tab="map">Map</button>
                    <button class="tab" data-tab="sync">Sync</button>
                </div>

                <div class="tab-content active" id="tab-credentials">
                    <div class="form-group">
                        <label class="form-label">Provider</label>
                        <select class="form-input" id="provider">
                            <option value="anthropic">Anthropic</option>
                            <option value="openai">OpenAI</option>
                            <option value="bedrock">Amazon Bedrock</option>
                            <option value="webllm">WebLLM (Local)</option>
                        </select>
                    </div>
                    
                    <div id="anthropicFields">
                        <div class="form-group">
                            <label class="form-label">API Key</label>
                            <input type="password" class="form-input" id="anthropicApiKey" placeholder="sk-ant-...">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Model</label>
                            <input type="text" class="form-input" id="anthropicModel" placeholder="claude-haiku-4-5">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" class="form-input" id="anthropicMaxTokens" placeholder="8096" min="1" max="200000">
                            <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;">Maximum tokens for response (default: 8096)</div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Custom Headers (JSON)</label>
                            <textarea class="form-input" id="anthropicHeaders" rows="3" placeholder='{"anthropic-beta": "max-tokens-3-5-sonnet-2024-07-15"}'></textarea>
                            <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;">Additional HTTP headers for API requests (optional)</div>
                        </div>
                    </div>
                    
                    <div id="openaiFields" style="display:none;">
                        <div class="form-group">
                            <label class="form-label">API Key</label>
                            <input type="password" class="form-input" id="openaiApiKey" placeholder="sk-...">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Model</label>
                            <input type="text" class="form-input" id="openaiModel" placeholder="gpt-5-nano-2025-08-07">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" class="form-input" id="openaiMaxTokens" placeholder="8096" min="1" max="128000">
                            <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;">Maximum tokens for response (default: 8096)</div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Custom Headers (JSON)</label>
                            <textarea class="form-input" id="openaiHeaders" rows="3" placeholder='{"OpenAI-Organization": "org-xxx"}'></textarea>
                            <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;">Additional HTTP headers for API requests (optional)</div>
                        </div>
                    </div>
                    
                    <div id="bedrockFields" style="display:none;">
                        <div class="form-group">
                            <label class="form-label">API Key</label>
                            <input type="password" class="form-input" id="bedrockApiKey" placeholder="bedrock-api-key...">
                            <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;">Generate at <a href="https://console.aws.amazon.com/bedrock/home#/api-keys" target="_blank" style="color:var(--text-secondary);">Bedrock Console ‚Üí API Keys</a></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Region</label>
                            <select class="form-input" id="bedrockRegion">
                                <option value="us-east-1">us-east-1</option>
                                <option value="us-west-2">us-west-2</option>
                                <option value="eu-west-1">eu-west-1</option>
                                <option value="ap-northeast-1">ap-northeast-1</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Model</label>
                            <input type="text" class="form-input" id="bedrockModel" placeholder="global.anthropic.claude-opus-4-5-20251101-v1:0">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Max Tokens</label>
                            <input type="number" class="form-input" id="bedrockMaxTokens" placeholder="8096" min="1" max="200000">
                        </div>
                    </div>
                    
                    <div id="webllmFields" style="display:none;">
                        <div class="form-group">
                            <label class="form-label">Local Model</label>
                            <select class="form-input" id="webllmModel">
                                <option value="Qwen2.5-3B-Instruct-q4f16_1-MLC">Qwen 2.5 3B (recommended)</option>
                                <option value="Qwen2.5-1.5B-Instruct-q4f16_1-MLC">Qwen 2.5 1.5B (faster)</option>
                                <option value="Llama-3.2-3B-Instruct-q4f16_1-MLC">Llama 3.2 3B</option>
                                <option value="Llama-3.2-1B-Instruct-q4f16_1-MLC">Llama 3.2 1B (smallest)</option>
                                <option value="Phi-3.5-mini-instruct-q4f16_1-MLC">Phi 3.5 Mini</option>
                                <option value="SmolLM2-1.7B-Instruct-q4f16_1-MLC">SmolLM2 1.7B</option>
                                <option value="Hermes-2-Pro-Llama-3-8B-q4f16_1-MLC">Hermes Llama3 8B (best for tools)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <div style="font-size:12px;color:var(--text-tertiary);line-height:1.6;">
                                <strong>üöÄ Runs 100% locally</strong> ‚Äî No API key needed!<br>
                                Uses WebGPU for fast inference.<br>
                                First load downloads model (~1-4GB).<br>
                                Requires Chrome 113+ or Edge 113+.
                            </div>
                        </div>
                        <div id="webllmProgress" style="display:none;margin-bottom:16px;">
                            <div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px;" id="webllmProgressText">Loading...</div>
                            <div style="height:4px;background:var(--glass);border-radius:2px;overflow:hidden;">
                                <div id="webllmProgressBar" style="height:100%;background:var(--text);width:0%;transition:width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" id="saveCredentialsBtn">Save & Connect</button>
                        <button class="btn" id="testConnectionBtn">Test</button>
                    </div>
                </div>

                <div class="tab-content" id="tab-google">
                    <div class="form-group">
                        <label class="form-label">üîê Google OAuth Setup</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;line-height:1.6;">
                            Connect to Google APIs (Gmail, Drive, Calendar, YouTube, etc.)
                            <br>Requires OAuth Client ID from Google Cloud Console.
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">OAuth Client ID</label>
                        <input type="text" class="form-input" id="googleClientId" placeholder="xxx.apps.googleusercontent.com">
                        <div style="font-size:11px;color:var(--text-tertiary);margin-top:8px;">
                            Get from <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color:var(--text-secondary);">Google Cloud Console</a> ‚Üí Create OAuth 2.0 Client ID (Web application)
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">API Key (Optional)</label>
                        <input type="password" class="form-input" id="googleApiKey" placeholder="AIzaSy...">
                        <div style="font-size:11px;color:var(--text-tertiary);margin-top:8px;">
                            For public APIs without OAuth. Create at Cloud Console ‚Üí API Keys
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">OAuth Status</label>
                        <div id="googleAuthStatus" style="font-family:'SF Mono',monospace;font-size:12px;color:var(--text-secondary);background:rgba(0,0,0,0.3);padding:12px;border-radius:8px;">
                            Not connected
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" id="saveGoogleConfigBtn">Save Config</button>
                        <button class="btn" id="googleAuthBtn">üîê Authenticate</button>
                        <button class="btn" id="googleRevokeBtn">Revoke</button>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;">
                        <label class="form-label">üìã Setup Instructions</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.8;">
                            1. Go to <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color:var(--text-secondary);">Google Cloud Console</a><br>
                            2. Create a new project (or select existing)<br>
                            3. Enable APIs you need (Gmail, Drive, Calendar, etc.)<br>
                            4. Click "Create Credentials" ‚Üí "OAuth client ID"<br>
                            5. Select "Web application"</strong><br>
                            6. Under "Authorized JavaScript origins" add:<br>
                            <code id="currentOrigin" style="background:rgba(255,255,255,0.1);padding:4px 8px;border-radius:4px;display:inline-block;margin:4px 0;"></code><br>
                            7. Copy the Client ID and paste above<br>
                            8. Click "Authenticate" to connect
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="tab-system">
                    <div class="form-group">
                        <label class="form-label">System Prompt</label>
                        <textarea class="form-input" id="systemPrompt" rows="14"></textarea>
                    </div>
                    <button class="btn btn-primary" id="saveSystemPromptBtn">Save</button>
                </div>

                <div class="tab-content" id="tab-tools">
                    <div class="form-group">
                        <label class="form-label">All Tools (click to toggle)</label>
                        <div id="builtinToolsList" style="font-size:13px;color:var(--text-secondary);line-height:2.2;">
                            <!-- Tools will be rendered by JS with click handlers, grouped by category -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Custom Tools</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.8;" id="customToolsList">
                            Loading...
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">PWA Status</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.8;" id="pwaStatus">
                            Checking...
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="tab-context">
                    <div class="form-group">
                        <label class="form-label">üß† Dynamic Context Injection</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;">
                            Enable context sources to automatically inject data into every agent turn.
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                            <input type="checkbox" id="contextActivity" style="width:18px;height:18px;">
                            <span style="color:var(--text);">üëÅÔ∏è Activity Tracking</span>
                        </label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-left:28px;">
                            Mouse position, typing, scrolling, idle time, focus state
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                            <input type="checkbox" id="contextGeolocation" style="width:18px;height:18px;">
                            <span style="color:var(--text);">üìç Geolocation</span>
                        </label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-left:28px;">
                            GPS coordinates, altitude, speed (requires permission)
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                            <input type="checkbox" id="contextBluetooth" style="width:18px;height:18px;">
                            <span style="color:var(--text);">üì° Bluetooth Devices</span>
                        </label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-left:28px;">
                            Nearby devices and AGI agents (requires Chrome/Edge + HTTPS)
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;">
                        <label class="form-label">Current Context Preview</label>
                        <div id="contextPreview" style="font-family:'SF Mono',monospace;font-size:11px;background:rgba(0,0,0,0.3);padding:12px;border-radius:8px;max-height:200px;overflow-y:auto;color:var(--text-tertiary);white-space:pre-wrap;">
                            Click "Refresh" to see current context
                        </div>
                        <button class="btn" id="refreshContextBtn" style="margin-top:8px;">Refresh Preview</button>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;">
                        <label class="form-label">Custom Context</label>
                        <div style="display:flex;gap:8px;">
                            <input type="text" class="form-input" id="customContextKey" placeholder="key" style="flex:1;">
                            <input type="text" class="form-input" id="customContextValue" placeholder="value" style="flex:2;">
                            <button class="btn" id="addCustomContextBtn">Add</button>
                        </div>
                        <div id="customContextList" style="font-size:12px;color:var(--text-tertiary);margin-top:8px;">
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="tab-map">
                    <div class="form-group">
                        <label class="form-label">üó∫Ô∏è Map Background</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;">
                            Enable a full-screen Google Maps background with your live location. 
                            Clean, transparent, minimal - the map is just ambiance while streaming.
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Google Maps API Key</label>
                        <input type="password" class="form-input" id="googleMapsApiKey" placeholder="AIzaSy...">
                        <div style="font-size:11px;color:var(--text-tertiary);margin-top:8px;">
                            Get a free key at <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color:var(--text-secondary);">Google Cloud Console</a>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Map ID (Optional - for Advanced Markers)</label>
                        <input type="text" class="form-input" id="googleMapsMapId" placeholder="e.g., 8e0a97af9386fef">
                        <div style="font-size:11px;color:var(--text-tertiary);margin-top:8px;">
                            Create at <a href="https://console.cloud.google.com/google/maps-apis/studio/maps" target="_blank" style="color:var(--text-secondary);">Maps Studio</a> ‚Üí enables custom markers with emoji/labels
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                            <input type="checkbox" id="mapEnabled" style="width:18px;height:18px;">
                            <span style="color:var(--text);">Enable Map Background</span>
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Map Style</label>
                        <select class="form-input" id="mapStyle">
                            <option value="dark">Dark</option>
                            <option value="ultra-minimal">Minimal</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Current Location</label>
                        <div id="mapLocationDisplay" style="font-family:'SF Mono',monospace;font-size:12px;color:var(--text-secondary);background:rgba(0,0,0,0.3);padding:12px;border-radius:8px;">
                            Waiting for location...
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" id="saveMapSettingsBtn">Save & Apply</button>
                        <button class="btn" id="testMapBtn">Test Map</button>
                    </div>
                </div>

                <div class="tab-content" id="tab-sync">
                    <div class="form-group">
                        <label class="form-label">üîÑ Sync & Share</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;">
                            Export your settings as an encrypted URL to import on another device (like your mobile PWA).
                            All API keys and config are encrypted with your password.
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">üì§ Export Settings</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Enter a password to encrypt your settings. Share the generated URL/code with your mobile.
                        </div>
                        <div style="display:flex;gap:8px;margin-bottom:12px;">
                            <input type="password" class="form-input" id="exportPassword" placeholder="Encryption password" style="flex:1;">
                            <button class="btn btn-primary" id="exportSettingsBtn">Export</button>
                        </div>
                        <div id="exportResult" style="display:none;">
                            <div style="font-size:11px;color:var(--text-tertiary);margin-bottom:8px;">üìã Copy this URL:</div>
                            <textarea class="form-input" id="exportedUrl" rows="3" readonly style="font-size:12px;"></textarea>
                            <div class="btn-group" style="margin-top:8px;">
                                <button class="btn" id="copyExportBtn">üìã Copy URL</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;padding-top:24px;border-top:1px solid var(--divider);">
                        <label class="form-label">üì• Import Settings</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Paste the encrypted URL from your other device.
                        </div>
                        <textarea class="form-input" id="importUrl" rows="2" placeholder="Paste encrypted URL here..." style="font-size:12px;margin-bottom:8px;"></textarea>
                        <div style="display:flex;gap:8px;">
                            <input type="password" class="form-input" id="importPassword" placeholder="Decryption password" style="flex:1;">
                            <button class="btn btn-primary" id="importSettingsBtn">Import</button>
                        </div>
                        <div id="importStatus" style="font-size:12px;margin-top:8px;display:none;"></div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;padding-top:24px;border-top:1px solid var(--divider);">
                        <label class="form-label">üí¨ Chat History</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Messages are automatically saved to local storage.
                        </div>
                        <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                            <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                                <input type="checkbox" id="persistMessages" style="width:18px;height:18px;" checked>
                                <span style="color:var(--text);">Auto-save messages</span>
                            </label>
                        </div>
                        <div id="chatHistoryStats" style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Loading...
                        </div>
                        <div class="btn-group">
                            <button class="btn" id="exportChatBtn">üì• Export Chat</button>
                            <button class="btn" id="clearChatHistoryBtn" style="color:rgba(255,100,100,0.8);">üóëÔ∏è Clear History</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;padding-top:24px;border-top:1px solid var(--divider);">
                        <label class="form-label">üîê What's Exported</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.8;">
                            ‚úÖ API keys (Anthropic, OpenAI, Google)<br>
                            ‚úÖ Model preferences<br>
                            ‚úÖ System prompt<br>
                            ‚úÖ Custom tools<br>
                            ‚úÖ Map settings<br>
                            ‚úÖ Context preferences<br>
                            ‚ùå Chat history (use Export Chat separately)
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Polyfill for Symbol.dispose/asyncDispose (mobile browser support) -->
    <script>
    if (typeof Symbol.dispose === 'undefined') {
        Symbol.dispose = Symbol('Symbol.dispose');
    }
    if (typeof Symbol.asyncDispose === 'undefined') {
        Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
    }
    </script>

    <!-- Load Strands SDK -->
    <script type="module">
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // agi.diy ‚Äî Build your own AGI
    // 
    // Documentation available in console. Type agi.help() for reference.
    // 
    // Architecture:
    // - Strands Agent SDK (browser bundle)
    // - Custom Anthropic model provider
    // - Browser-native tools (storage, fetch, eval, render)
    // - Full streaming support
    // 
    // Source: https://github.com/strands-agents/sdk-typescript
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    import { 
        Agent, 
        tool,
        Model,
        TextBlock,
        ImageBlock,
        ToolResultBlock,
        Message,
        z
    } from './strands.js';
    
    // Expose Agent globally for ambient mode to create separate instances
    window.Agent = Agent;
    
    // Expose model classes for ambient mode to clone
    window.AnthropicBrowserModel = null; // Will be set after class definition
    window.OpenAIBrowserModel = null;
    window.BedrockBrowserModel = null;
    
    import { WebLLMBrowserModel } from './webllm.js';
    
    import { 
        VisionAgent, 
        ScreenCapture, 
        AmbientMode,
        createImageBlock,
        resizeImageIfNeeded
    } from './vision.js';
    
    import { 
        ContextInjector,
        BluetoothScanner
    } from './context-injector.js';
    
    import {
        MapBackground,
        createMapControls
    } from './map.js';
    
    import { googleAPI, DEFAULT_SCOPES } from './tools/google.js';
    
    // Initialize global context injector
    const contextInjector = new ContextInjector();
    contextInjector.exposeToWindow();

    const VERSION = '1.0.0';

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONSOLE DOCUMENTATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    console.log(`
%c‚óà agi.diy %cv${VERSION}

%cBuild your own AGI. Strands Agent running entirely in your browser.

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cQUICK START%c
1. Click "settings" ‚Üí Add your Anthropic API key
2. Start chatting ‚Äî the agent can execute code, render UI, persist data

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cARCHITECTURE%c
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Browser                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  agi.diy UI                                               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Strands Agent  ‚îÇ‚Üê‚Üí‚îÇ AnthropicBrowserModel           ‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ (streaming)    ‚îÇ  ‚îÇ (direct API calls)              ‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ         ‚Üì                                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Browser Tools                                       ‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ render_ui      ‚Ä¢ storage_get/set                 ‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ javascript_eval ‚Ä¢ fetch_url ‚Ä¢ update_self        ‚îÇ  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cAVAILABLE TOOLS%c

render_ui({ html, css?, script?, title? })
  Render dynamic HTML components in the chat interface.
  Example: "Create a button that counts clicks"

javascript_eval({ code })
  Execute JavaScript and return the result.
  Example: "What's 2 + 2?" ‚Üí uses this tool

storage_get({ key }) / storage_set({ key, value })
  Persist data across sessions using localStorage.
  Example: "Remember my name is Alex"

fetch_url({ url, method?, headers?, body? })
  Make HTTP requests (subject to CORS).
  Example: "Fetch the GitHub API"

update_self({ section, content, action? })
  Self-modify the agent's system prompt.
  Example: "Add to your instructions: always be concise"

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cAPI REFERENCE%c

agi.agent        ‚Äî Current Agent instance
agi.version      ‚Äî Current version
agi.help()       ‚Äî Show this documentation
agi.clear()      ‚Äî Clear chat
agi.settings()   ‚Äî Open settings

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cPRIVACY%c
‚Ä¢ Your API key is stored only in your browser's localStorage
‚Ä¢ No data is sent to any server except the AI provider you choose
‚Ä¢ All processing happens client-side

%c‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

%cSOURCE%c
Strands SDK: https://github.com/strands-agents/sdk-typescript
agi.diy: https://agi.diy

%c‚óà
`,
    'font-size:20px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'font-size:13px;color:#aaa',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888;font-family:monospace',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'color:#555',
    'font-size:11px;font-weight:bold;color:#fff',
    'font-size:12px;color:#888',
    'font-size:16px;color:#555'
    );

    const DEFAULT_SYSTEM_PROMPT = `You are AGI, an autonomous AI agent running entirely in the browser at agi.diy.

## Core Tools
- **render_ui**: Create interactive HTML/CSS/JS components inline
- **javascript_eval**: Execute JavaScript, return results
- **storage_get/set**: Persist data in localStorage across sessions
- **fetch_url**: HTTP requests (CORS restrictions apply)
- **notify**: Push notifications (works in background)

## Self-Modification
- **create_tool**: Define new tools with name, schema, and JS code
- **list_tools**: See all available tools
- **delete_tool**: Remove custom tools
- **update_self**: Modify your own system prompt

Custom tools persist in localStorage and load automatically.

## Context Awareness
- **get_user_context**: Activity state, mouse position, idle time, location
- **set_context**: Add persistent key-value context
- **enable_context_tracking**: Toggle activity/geolocation/bluetooth

## Communication
- **scan_bluetooth**: Discover nearby devices and AGI agents
- **send_to_agent**: Message other AGI agents nearby

## Map Tools (when enabled)
- **add_map_marker**: Place markers with emoji/label/color
- **fly_to_location/marker**: Smooth camera animations
- **tour_markers**: Animated journey through markers
- **get_map_location**: Current GPS position

## Google APIs (when configured)
- **google_auth**: OAuth 2.0 authentication
- **use_google**: Access Gmail, Drive, Calendar, YouTube, etc.
- **gmail_send**: Send emails directly

## Guidelines
- Be concise and direct
- Use tools proactively

- Create custom tools for repeated tasks
- Check user context to understand what they're doing
- Render interactive UI for better experiences

Version: ${VERSION}`;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ANTHROPIC MODEL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class AnthropicBrowserModel extends Model {
        constructor(config = {}) {
            super();
            this._config = {
                apiKey: config.apiKey || '',
                modelId: config.modelId || 'claude-haiku-4-5',
                maxTokens: config.maxTokens || 8096,
                temperature: config.temperature || 1.0,
                customHeaders: config.customHeaders || {},
            };
        }

        updateConfig(config) {
            this._config = { ...this._config, ...config };
        }

        getConfig() {
            return this._config;
        }

        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens, temperature, customHeaders } = this._config;
            
            if (!apiKey) {
                throw new Error('API key not configured. Open settings to add your key.');
            }

            const anthropicMessages = messages.map(msg => ({
                role: msg.role,
                content: msg.content.map(block => {
                    switch (block.type) {
                        case 'textBlock':
                            return { type: 'text', text: block.text };
                        case 'imageBlock':
                            // Handle image blocks for multimodal
                            if (block.source?.type === 'imageSourceBytes') {
                                // Convert Uint8Array to base64
                                const base64 = btoa(String.fromCharCode(...block.source.bytes));
                                return {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: `image/${block.format}`,
                                        data: base64
                                    }
                                };
                            } else if (block.source?.type === 'imageSourceUrl') {
                                return {
                                    type: 'image',
                                    source: {
                                        type: 'url',
                                        url: block.source.url
                                    }
                                };
                            }
                            return { type: 'text', text: '[Image]' };
                        case 'toolUseBlock':
                            return { 
                                type: 'tool_use', 
                                id: block.toolUseId, 
                                name: block.name, 
                                input: block.input 
                            };
                        case 'toolResultBlock':
                            const content = block.content.map(c => {
                                if (c.type === 'textBlock') return { type: 'text', text: c.text };
                                if (c.type === 'jsonBlock') return { type: 'text', text: JSON.stringify(c.json) };
                                return { type: 'text', text: String(c) };
                            });
                            return { 
                                type: 'tool_result', 
                                tool_use_id: block.toolUseId,
                                content: content
                            };
                        default:
                            return { type: 'text', text: String(block) };
                    }
                })
            }));

            const requestBody = {
                model: modelId,
                max_tokens: maxTokens,
                temperature: temperature,
                messages: anthropicMessages,
                stream: true
            };

            if (options?.systemPrompt) {
                if (typeof options.systemPrompt === 'string') {
                    requestBody.system = options.systemPrompt;
                } else if (Array.isArray(options.systemPrompt)) {
                    requestBody.system = options.systemPrompt
                        .filter(b => b.type === 'textBlock')
                        .map(b => b.text)
                        .join('\n');
                }
            }

            if (options?.toolSpecs && options.toolSpecs.length > 0) {
                requestBody.tools = options.toolSpecs.map(spec => ({
                    name: spec.name,
                    description: spec.description,
                    input_schema: spec.inputSchema
                }));
            }

            // Build headers with custom headers support
            const headers = {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true',
                ...customHeaders
            };

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`API error: ${response.status} - ${error}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let currentToolUseId = '';
            let currentToolName = '';

            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;
                        
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const event = JSON.parse(data);
                            
                            if (event.type === 'message_start') {
                                yield { type: 'modelMessageStartEvent', role: 'assistant' };
                            } 
                            else if (event.type === 'content_block_start') {
                                if (event.content_block?.type === 'tool_use') {
                                    currentToolUseId = event.content_block.id;
                                    currentToolName = event.content_block.name;
                                    yield {
                                        type: 'modelContentBlockStartEvent',
                                        start: {
                                            type: 'toolUseStart',
                                            name: currentToolName,
                                            toolUseId: currentToolUseId
                                        }
                                    };
                                } else {
                                    yield { type: 'modelContentBlockStartEvent' };
                                }
                            } 
                            else if (event.type === 'content_block_delta') {
                                if (event.delta?.type === 'text_delta') {
                                    yield {
                                        type: 'modelContentBlockDeltaEvent',
                                        delta: { type: 'textDelta', text: event.delta.text }
                                    };
                                } else if (event.delta?.type === 'input_json_delta') {
                                    yield {
                                        type: 'modelContentBlockDeltaEvent',
                                        delta: { type: 'toolUseInputDelta', input: event.delta.partial_json }
                                    };
                                }
                            } 
                            else if (event.type === 'content_block_stop') {
                                yield { type: 'modelContentBlockStopEvent' };
                                currentToolUseId = '';
                                currentToolName = '';
                            } 
                            else if (event.type === 'message_delta') {
                                if (event.delta?.stop_reason) {
                                    let stopReason = 'endTurn';
                                    switch (event.delta.stop_reason) {
                                        case 'tool_use': stopReason = 'toolUse'; break;
                                        case 'max_tokens': stopReason = 'maxTokens'; break;
                                        case 'stop_sequence': stopReason = 'stopSequence'; break;
                                    }
                                    yield { type: 'modelMessageStopEvent', stopReason };
                                }
                                if (event.usage) {
                                    yield {
                                        type: 'modelMetadataEvent',
                                        usage: {
                                            inputTokens: event.usage.input_tokens || 0,
                                            outputTokens: event.usage.output_tokens || 0,
                                            totalTokens: (event.usage.input_tokens || 0) + (event.usage.output_tokens || 0)
                                        }
                                    };
                                }
                            }
                        } catch (e) {
                            // Skip malformed events
                        }
                    }
                }
            } finally {
                reader.releaseLock();
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OPENAI MODEL (Browser-compatible)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class OpenAIBrowserModel extends Model {
        constructor(config = {}) {
            super();
            this._config = {
                apiKey: config.apiKey || '',
                modelId: config.modelId || 'gpt-5-nano-2025-08-07',
                maxTokens: config.maxTokens || 8096,
                temperature: config.temperature || 1.0,
                customHeaders: config.customHeaders || {},
            };
        }

        updateConfig(config) {
            this._config = { ...this._config, ...config };
        }

        getConfig() {
            return this._config;
        }

        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens, temperature, customHeaders } = this._config;
            
            if (!apiKey) {
                throw new Error('OpenAI API key not configured. Open settings to add your key.');
            }

            // Format messages for OpenAI
            const openaiMessages = [];
            
            // Add system prompt
            if (options?.systemPrompt) {
                const systemText = typeof options.systemPrompt === 'string' 
                    ? options.systemPrompt 
                    : options.systemPrompt.filter(b => b.type === 'textBlock').map(b => b.text).join('\n');
                if (systemText) {
                    openaiMessages.push({ role: 'system', content: systemText });
                }
            }

            // Convert messages
            for (const msg of messages) {
                if (msg.role === 'user') {
                    const toolResults = msg.content.filter(b => b.type === 'toolResultBlock');
                    const otherContent = msg.content.filter(b => b.type !== 'toolResultBlock');

                    // Add regular content
                    if (otherContent.length > 0) {
                        const parts = otherContent.map(block => {
                            if (block.type === 'textBlock') return { type: 'text', text: block.text };
                            if (block.type === 'imageBlock') {
                                // Handle image blocks for OpenAI vision
                                if (block.source?.type === 'imageSourceBytes') {
                                    const base64 = btoa(String.fromCharCode(...block.source.bytes));
                                    return {
                                        type: 'image_url',
                                        image_url: {
                                            url: `data:image/${block.format};base64,${base64}`
                                        }
                                    };
                                } else if (block.source?.type === 'imageSourceUrl') {
                                    return {
                                        type: 'image_url',
                                        image_url: { url: block.source.url }
                                    };
                                }
                            }
                            return { type: 'text', text: String(block) };
                        });
                        openaiMessages.push({ role: 'user', content: parts });
                    }

                    // Add tool results as separate messages
                    for (const tr of toolResults) {
                        const content = tr.content.map(c => {
                            if (c.type === 'textBlock') return c.text;
                            if (c.type === 'jsonBlock') return JSON.stringify(c.json);
                            return String(c);
                        }).join('');
                        openaiMessages.push({
                            role: 'tool',
                            tool_call_id: tr.toolUseId,
                            content: tr.status === 'error' ? `[ERROR] ${content}` : content
                        });
                    }
                } else {
                    // Assistant message
                    const toolCalls = [];
                    const textParts = [];

                    for (const block of msg.content) {
                        if (block.type === 'textBlock') {
                            textParts.push(block.text);
                        } else if (block.type === 'toolUseBlock') {
                            toolCalls.push({
                                id: block.toolUseId,
                                type: 'function',
                                function: {
                                    name: block.name,
                                    arguments: JSON.stringify(block.input)
                                }
                            });
                        }
                    }

                    const assistantMsg = { role: 'assistant', content: textParts.join('') };
                    if (toolCalls.length > 0) assistantMsg.tool_calls = toolCalls;
                    openaiMessages.push(assistantMsg);
                }
            }

            const requestBody = {
                model: modelId,
                max_completion_tokens: maxTokens,
                temperature: temperature,
                messages: openaiMessages,
                stream: true,
                stream_options: { include_usage: true }
            };

            // Add tools if specified
            if (options?.toolSpecs && options.toolSpecs.length > 0) {
                requestBody.tools = options.toolSpecs.map(spec => ({
                    type: 'function',
                    function: {
                        name: spec.name,
                        description: spec.description,
                        parameters: spec.inputSchema
                    }
                }));
            }

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    ...customHeaders
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`OpenAI API error: ${response.status} - ${error}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            // Track state
            let messageStarted = false;
            let textBlockStarted = false;
            const activeToolCalls = new Map();

            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;
                        
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const chunk = JSON.parse(data);
                            
                            if (!chunk.choices || chunk.choices.length === 0) {
                                // Usage chunk
                                if (chunk.usage) {
                                    yield {
                                        type: 'modelMetadataEvent',
                                        usage: {
                                            inputTokens: chunk.usage.prompt_tokens || 0,
                                            outputTokens: chunk.usage.completion_tokens || 0,
                                            totalTokens: chunk.usage.total_tokens || 0
                                        }
                                    };
                                }
                                continue;
                            }

                            const choice = chunk.choices[0];
                            const delta = choice.delta;

                            // Message start
                            if (delta?.role && !messageStarted) {
                                messageStarted = true;
                                yield { type: 'modelMessageStartEvent', role: delta.role };
                            }

                            // Text content
                            if (delta?.content && delta.content.length > 0) {
                                if (!textBlockStarted) {
                                    textBlockStarted = true;
                                    yield { type: 'modelContentBlockStartEvent' };
                                }
                                yield {
                                    type: 'modelContentBlockDeltaEvent',
                                    delta: { type: 'textDelta', text: delta.content }
                                };
                            }

                            // Tool calls
                            if (delta?.tool_calls) {
                                for (const tc of delta.tool_calls) {
                                    if (tc.id && tc.function?.name) {
                                        // Tool call start
                                        yield {
                                            type: 'modelContentBlockStartEvent',
                                            start: {
                                                type: 'toolUseStart',
                                                name: tc.function.name,
                                                toolUseId: tc.id
                                            }
                                        };
                                        activeToolCalls.set(tc.index, true);
                                    }
                                    if (tc.function?.arguments) {
                                        yield {
                                            type: 'modelContentBlockDeltaEvent',
                                            delta: { type: 'toolUseInputDelta', input: tc.function.arguments }
                                        };
                                    }
                                }
                            }

                            // Finish reason
                            if (choice.finish_reason) {
                                if (textBlockStarted) {
                                    yield { type: 'modelContentBlockStopEvent' };
                                    textBlockStarted = false;
                                }
                                for (const [idx] of activeToolCalls) {
                                    yield { type: 'modelContentBlockStopEvent' };
                                    activeToolCalls.delete(idx);
                                }

                                const stopReasonMap = {
                                    'stop': 'endTurn',
                                    'tool_calls': 'toolUse',
                                    'length': 'maxTokens',
                                    'content_filter': 'contentFiltered'
                                };
                                yield {
                                    type: 'modelMessageStopEvent',
                                    stopReason: stopReasonMap[choice.finish_reason] || 'endTurn'
                                };
                            }
                        } catch (e) {
                            // Skip malformed events
                        }
                    }
                }
            } finally {
                reader.releaseLock();
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BEDROCK MODEL (Browser-compatible with API Key)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class BedrockBrowserModel extends Model {
        constructor(config = {}) {
            super();
            this._config = {
                apiKey: config.apiKey || '',
                region: config.region || 'us-east-1',
                modelId: config.modelId || 'global.anthropic.claude-opus-4-5-20251101-v1:0',
                maxTokens: config.maxTokens || 8096,
            };
        }
        updateConfig(config) { this._config = { ...this._config, ...config }; }
        getConfig() { return this._config; }

        async *stream(messages, options) {
            const { apiKey, region, modelId, maxTokens } = this._config;
            if (!apiKey) throw new Error('Bedrock API key not configured.');

            const formatBlock = block => {
                if (block.type === 'textBlock') return { text: block.text };
                if (block.type === 'toolUseBlock') return { toolUse: { toolUseId: block.toolUseId, name: block.name, input: block.input } };
                if (block.type === 'toolResultBlock') return { toolResult: { toolUseId: block.toolUseId, content: block.content.map(c => ({ text: c.text || JSON.stringify(c.json) })) } };
                return { text: String(block) };
            };

            const requestBody = {
                messages: messages.map(m => ({ role: m.role, content: m.content.map(formatBlock) })),
                inferenceConfig: { maxTokens }
            };
            if (options?.systemPrompt) {
                requestBody.system = [{ text: typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.map(b => b.text).join('\n') }];
            }
            if (options?.toolSpecs?.length) {
                requestBody.toolConfig = { tools: options.toolSpecs.map(s => ({ toolSpec: { name: s.name, description: s.description, inputSchema: { json: s.inputSchema } } })) };
            }

            const response = await fetch(`https://bedrock-runtime.${region}.amazonaws.com/model/${encodeURIComponent(modelId)}/converse`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) throw new Error(`Bedrock API error: ${response.status} - ${await response.text()}`);

            const data = await response.json();
            console.debug('Bedrock response:', data);
            yield { type: 'modelMessageStartEvent', role: 'assistant' };
            for (const block of data.output?.message?.content || []) {
                if (block.text) {
                    yield { type: 'modelContentBlockStartEvent' };
                    yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: block.text } };
                    yield { type: 'modelContentBlockStopEvent' };
                } else if (block.toolUse) {
                    yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', toolUseId: block.toolUse.toolUseId, name: block.toolUse.name } };
                    yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: JSON.stringify(block.toolUse.input) } };
                    yield { type: 'modelContentBlockStopEvent' };
                }
            }
            yield { type: 'modelMessageStopEvent', stopReason: { end_turn: 'endTurn', tool_use: 'toolUse', max_tokens: 'maxTokens' }[data.stopReason] || 'endTurn' };
            if (data.usage) yield { type: 'modelMetadataEvent', usage: { inputTokens: data.usage.inputTokens, outputTokens: data.usage.outputTokens, totalTokens: data.usage.totalTokens || (data.usage.inputTokens + data.usage.outputTokens) } };
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BROWSER TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const renderUiTool = tool({
        name: 'render_ui',
        description: 'Render a dynamic HTML/CSS/JS component in the chat.',
        inputSchema: z.object({
            html: z.string().describe('HTML content'),
            css: z.string().optional().describe('CSS styles'),
            script: z.string().optional().describe('JavaScript to execute'),
            title: z.string().optional().describe('Component title')
        }),
        callback: async (input) => {
            const container = document.createElement('div');
            container.className = 'dynamic-ui';
            
            if (input.title) {
                const title = document.createElement('div');
                title.style.cssText = 'font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.08em;color:var(--text-tertiary);margin-bottom:16px;';
                title.textContent = input.title;
                container.appendChild(title);
            }
            
            if (input.css) {
                const style = document.createElement('style');
                style.textContent = input.css;
                container.appendChild(style);
            }
            
            const content = document.createElement('div');
            content.innerHTML = input.html;
            container.appendChild(content);
            
            const messagesInner = document.getElementById('messagesInner');
            messagesInner.appendChild(container);
            smartScroll();
            
            if (input.script) {
                try {
                    const fn = new Function(input.script);
                    setTimeout(() => fn.call(content), 0);
                } catch (e) {
                    return { rendered: true, scriptError: e.message };
                }
            }
            
            return { rendered: true, title: input.title || 'component' };
        }
    });

    const javascriptEvalTool = tool({
        name: 'javascript_eval',
        description: 'Execute JavaScript code and return the result',
        inputSchema: z.object({
            code: z.string().describe('JavaScript code')
        }),
        callback: async (input) => {
            try {
                const result = eval(input.code);
                return { result: String(result) };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    const storageGetTool = tool({
        name: 'storage_get',
        description: 'Get a value from localStorage',
        inputSchema: z.object({
            key: z.string().describe('Storage key')
        }),
        callback: async (input) => {
            const value = localStorage.getItem(input.key);
            return { key: input.key, value };
        }
    });

    const storageSetTool = tool({
        name: 'storage_set',
        description: 'Set a value in localStorage',
        inputSchema: z.object({
            key: z.string().describe('Storage key'),
            value: z.string().describe('Value')
        }),
        callback: async (input) => {
            localStorage.setItem(input.key, input.value);
            return { success: true, key: input.key };
        }
    });

    const fetchUrlTool = tool({
        name: 'fetch_url',
        description: 'Fetch content from a URL',
        inputSchema: z.object({
            url: z.string().describe('URL'),
            method: z.string().optional().describe('HTTP method'),
            headers: z.record(z.string(), z.string()).optional().describe('Headers'),
            body: z.string().optional().describe('Body')
        }),
        callback: async (input) => {
            try {
                const response = await fetch(input.url, {
                    method: input.method || 'GET',
                    headers: input.headers || {},
                    body: input.body
                });
                const contentType = response.headers.get('content-type');
                let data;
                if (contentType?.includes('application/json')) {
                    data = await response.json();
                } else {
                    data = await response.text();
                }
                return { status: response.status, data };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    const updateSelfTool = tool({
        name: 'update_self',
        description: 'Update agent configuration',
        inputSchema: z.object({
            section: z.enum(['system_prompt', 'config']).describe('Section'),
            content: z.string().describe('Content'),
            action: z.enum(['replace', 'append', 'prepend']).optional().describe('Action')
        }),
        callback: async (input) => {
            const action = input.action || 'replace';
            
            if (input.section === 'system_prompt') {
                const current = localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT;
                let newPrompt;
                if (action === 'append') {
                    newPrompt = current + '\n' + input.content;
                } else if (action === 'prepend') {
                    newPrompt = input.content + '\n' + current;
                } else {
                    newPrompt = input.content;
                }
                localStorage.setItem('system_prompt', newPrompt);
                window._agentNeedsReinit = true;
                return { success: true, message: 'System prompt updated.' };
            }
            
            return { error: `Unknown section: ${input.section}` };
        }
    });

    const notifyTool = tool({
        name: 'notify',
        description: 'Send a browser/push notification to the user. Works even when app is in background. Use this to alert the user about important events, completed tasks, or time-sensitive information.',
        inputSchema: z.object({
            title: z.string().describe('Notification title'),
            body: z.string().describe('Notification body text'),
            tag: z.string().optional().describe('Tag to group/replace notifications'),
            requireInteraction: z.boolean().optional().describe('Keep notification visible until user interacts'),
            url: z.string().optional().describe('URL to open when notification is clicked')
        }),
        callback: async (input) => {
            // Check permission
            if (!('Notification' in window)) {
                return { error: 'Notifications not supported in this browser' };
            }
            
            if (Notification.permission === 'denied') {
                return { error: 'Notification permission denied. User must enable in browser settings.' };
            }
            
            if (Notification.permission === 'default') {
                const permission = await Notification.requestPermission();
                if (permission !== 'granted') {
                    return { error: 'Notification permission not granted' };
                }
            }
            
            // Try service worker notification first (works in background)
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'SHOW_NOTIFICATION',
                    title: input.title,
                    body: input.body,
                    tag: input.tag,
                    requireInteraction: input.requireInteraction,
                    url: input.url
                });
                return { success: true, method: 'service-worker', title: input.title };
            }
            
            // Fallback to regular notification
            const notification = new Notification(input.title, {
                body: input.body,
                icon: '/icon-192.svg',
                tag: input.tag || 'agi-notification',
                requireInteraction: input.requireInteraction || false
            });
            
            notification.onclick = () => {
                window.focus();
                if (input.url) window.location.href = input.url;
                notification.close();
            };
            
            return { success: true, method: 'direct', title: input.title };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BLUETOOTH & CONTEXT TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const scanBluetoothTool = tool({
        name: 'scan_bluetooth',
        description: 'Scan for nearby Bluetooth devices. Can discover other AGI agents running nearby. Requires user permission.',
        inputSchema: z.object({
            timeout: z.number().optional().describe('Scan timeout in ms (default: 10000)')
        }),
        callback: async (input) => {
            try {
                const devices = await contextInjector.scanBluetooth();
                const agiAgents = devices.filter(d => d.isAgiAgent);
                
                return {
                    success: true,
                    totalDevices: devices.length,
                    agiAgents: agiAgents.length,
                    devices: devices.map(d => ({
                        id: d.id,
                        name: d.name,
                        isAgiAgent: d.isAgiAgent,
                        agentInfo: d.agentInfo || null
                    }))
                };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    const sendToAgentTool = tool({
        name: 'send_to_agent',
        description: 'Send a message to a nearby AGI agent discovered via Bluetooth.',
        inputSchema: z.object({
            deviceId: z.string().describe('Device ID from scan_bluetooth'),
            message: z.string().describe('Message to send to the agent')
        }),
        callback: async (input) => {
            try {
                await contextInjector.sendToNearbyAgent(input.deviceId, input.message);
                return { success: true, sentTo: input.deviceId };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    const getUserContextTool = tool({
        name: 'get_user_context',
        description: 'Get current user context including activity state, position, and environment. Useful for understanding what the user is doing.',
        inputSchema: z.object({
            includeActivity: z.boolean().optional().describe('Include activity tracking data'),
            includeLocation: z.boolean().optional().describe('Include geolocation data'),
            includeBluetooth: z.boolean().optional().describe('Include bluetooth device info')
        }),
        callback: async (input) => {
            const context = contextInjector.getContext();
            const result = {
                timestamp: context.timestamp,
                url: context.url
            };
            
            if (input.includeActivity !== false && context.activity) {
                result.activity = context.activity;
            }
            if (input.includeLocation && context.geolocation?.position) {
                result.location = context.geolocation;
            }
            if (input.includeBluetooth && context.bluetooth) {
                result.bluetooth = context.bluetooth;
            }
            result.custom = context.custom;
            
            return result;
        }
    });

    const setContextTool = tool({
        name: 'set_context',
        description: 'Set custom context data that will be injected into the system prompt on each turn.',
        inputSchema: z.object({
            key: z.string().describe('Context key'),
            value: z.string().describe('Context value')
        }),
        callback: async (input) => {
            contextInjector.setCustomContext(input.key, input.value);
            return { success: true, key: input.key };
        }
    });

    const enableContextTracking = tool({
        name: 'enable_context_tracking',
        description: 'Enable or disable context tracking features like activity monitoring, geolocation, or bluetooth.',
        inputSchema: z.object({
            feature: z.enum(['activity', 'geolocation', 'bluetooth']).describe('Feature to toggle'),
            enabled: z.boolean().describe('Enable or disable')
        }),
        callback: async (input) => {
            contextInjector.enable(input.feature, input.enabled);
            return { 
                success: true, 
                feature: input.feature, 
                enabled: input.enabled,
                note: input.feature === 'geolocation' || input.feature === 'bluetooth' 
                    ? 'May require user permission' : undefined
            };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MAP MARKER TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const addMapMarkerTool = tool({
        name: 'add_map_marker',
        description: 'Add a marker to the map background. Use this to highlight locations, show points of interest, or visualize data geographically.',
        inputSchema: z.object({
            lat: z.number().describe('Latitude coordinate'),
            lng: z.number().describe('Longitude coordinate'),
            label: z.string().optional().describe('Text label for the marker'),
            emoji: z.string().optional().describe('Emoji icon (default: üìç)'),
            color: z.string().optional().describe('Background color (default: #ff6b6b)'),
            id: z.string().optional().describe('Custom ID for the marker')
        }),
        callback: async (input) => {
            if (!mapBackground || !mapBackground.ready) {
                return { error: 'Map not enabled. Enable it in settings ‚Üí Map' };
            }
            
            const result = mapBackground.addMarker(input.lat, input.lng, {
                label: input.label,
                emoji: input.emoji || 'üìç',
                color: input.color || '#ff6b6b',
                id: input.id
            });
            
            if (result) {
                return { 
                    success: true, 
                    markerId: result.id,
                    position: { lat: input.lat, lng: input.lng }
                };
            }
            return { error: 'Failed to add marker' };
        }
    });

    const removeMapMarkerTool = tool({
        name: 'remove_map_marker',
        description: 'Remove a marker from the map by its ID.',
        inputSchema: z.object({
            id: z.string().describe('Marker ID to remove')
        }),
        callback: async (input) => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            const removed = mapBackground.removeMarker(input.id);
            return { success: removed, markerId: input.id };
        }
    });

    const clearMapMarkersTool = tool({
        name: 'clear_map_markers',
        description: 'Remove all custom markers from the map.',
        inputSchema: z.object({}),
        callback: async () => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            mapBackground.clearMarkers();
            return { success: true, message: 'All markers cleared' };
        }
    });

    const listMapMarkersTool = tool({
        name: 'list_map_markers',
        description: 'List all marker IDs currently on the map.',
        inputSchema: z.object({}),
        callback: async () => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            const markers = mapBackground.getMarkerIds();
            return { markers, count: markers.length };
        }
    });

    const panMapTool = tool({
        name: 'pan_map',
        description: 'Pan the map to a specific location.',
        inputSchema: z.object({
            lat: z.number().describe('Latitude'),
            lng: z.number().describe('Longitude'),
            zoom: z.number().optional().describe('Optional zoom level (1-20)')
        }),
        callback: async (input) => {
            if (!mapBackground || !mapBackground.ready) {
                return { error: 'Map not enabled' };
            }
            
            mapBackground.panTo(input.lat, input.lng, input.zoom);
            return { 
                success: true, 
                position: { lat: input.lat, lng: input.lng },
                zoom: input.zoom 
            };
        }
    });

    const getMapLocationTool = tool({
        name: 'get_map_location',
        description: 'Get the current user location from the map.',
        inputSchema: z.object({}),
        callback: async () => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            const pos = mapBackground.getPosition();
            if (pos) {
                return {
                    lat: pos.lat,
                    lng: pos.lng,
                    accuracy: pos.accuracy,
                    altitude: pos.altitude,
                    speed: pos.speed,
                    heading: pos.heading
                };
            }
            return { error: 'Location not available yet' };
        }
    });

    const flyToMarkerTool = tool({
        name: 'fly_to_marker',
        description: 'Smoothly animate/fly the map camera to a specific marker. Great for showcasing locations or giving tours.',
        inputSchema: z.object({
            markerId: z.string().describe('The marker ID to fly to'),
            zoom: z.number().optional().describe('Optional zoom level (1-20)'),
            duration: z.number().optional().describe('Animation duration in milliseconds (default: 2000)')
        }),
        callback: async (input) => {
            if (!mapBackground || !mapBackground.ready) {
                return { error: 'Map not enabled. Enable it in settings ‚Üí Map' };
            }
            
            const result = await mapBackground.flyToMarker(
                input.markerId, 
                input.zoom || null, 
                input.duration || 2000
            );
            return result;
        }
    });

    const flyToLocationTool = tool({
        name: 'fly_to_location',
        description: 'Smoothly animate/fly the map camera to specific coordinates with easing animation.',
        inputSchema: z.object({
            lat: z.number().describe('Target latitude'),
            lng: z.number().describe('Target longitude'),
            zoom: z.number().optional().describe('Optional zoom level (1-20)'),
            duration: z.number().optional().describe('Animation duration in milliseconds (default: 2000)')
        }),
        callback: async (input) => {
            if (!mapBackground || !mapBackground.ready) {
                return { error: 'Map not enabled' };
            }
            
            await mapBackground.flyTo(
                input.lat, 
                input.lng, 
                input.zoom || null, 
                input.duration || 2000
            );
            return { 
                success: true, 
                position: { lat: input.lat, lng: input.lng },
                message: `Flew to ${input.lat.toFixed(4)}, ${input.lng.toFixed(4)}`
            };
        }
    });

    const tourMarkersTool = tool({
        name: 'tour_markers',
        description: 'Take a tour through multiple markers in sequence with smooth animations. Perfect for showcasing a journey or route.',
        inputSchema: z.object({
            markerIds: z.array(z.string()).describe('Array of marker IDs to visit in order'),
            pauseMs: z.number().optional().describe('Pause duration at each marker in ms (default: 1500)'),
            flyDurationMs: z.number().optional().describe('Flight animation duration between markers in ms (default: 2000)')
        }),
        callback: async (input) => {
            if (!mapBackground || !mapBackground.ready) {
                return { error: 'Map not enabled' };
            }
            
            const result = await mapBackground.tourMarkers(
                input.markerIds,
                input.pauseMs || 1500,
                input.flyDurationMs || 2000
            );
            return result;
        }
    });

    const getMarkerPositionTool = tool({
        name: 'get_marker_position',
        description: 'Get the coordinates of a specific marker by its ID.',
        inputSchema: z.object({
            markerId: z.string().describe('The marker ID')
        }),
        callback: async (input) => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            const pos = mapBackground.getMarkerPosition(input.markerId);
            if (pos) {
                return { markerId: input.markerId, ...pos };
            }
            return { error: `Marker '${input.markerId}' not found` };
        }
    });

    const getAllMarkersTool = tool({
        name: 'get_all_markers',
        description: 'Get all markers with their IDs and positions.',
        inputSchema: z.object({}),
        callback: async () => {
            if (!mapBackground) {
                return { error: 'Map not enabled' };
            }
            
            const markers = mapBackground.getAllMarkers();
            return { 
                markers, 
                count: markers.length 
            };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GOOGLE API TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const googleAuthTool = tool({
        name: 'google_auth',
        description: `Authenticate with Google OAuth 2.0. Opens a popup for Google sign-in.
        
After authentication, you can use the use_google tool to access Gmail, Drive, Calendar, YouTube, and 200+ other Google APIs.

Setup required in settings ‚Üí Google tab:
1. Create OAuth Client ID at Google Cloud Console
2. Add your domain to authorized origins
3. Paste Client ID in settings`,
        inputSchema: z.object({
            forceNew: z.boolean().optional().describe('Force new authentication even if already logged in')
        }),
        callback: async (input) => {
            try {
                const config = googleAPI.getConfig();
                if (!config?.clientId) {
                    return { 
                        error: 'Google OAuth not configured. Go to settings ‚Üí Google tab to add your Client ID.' 
                    };
                }

                const token = await googleAPI.getToken(input?.forceNew || false);
                
                // Get user info
                let userInfo = null;
                try {
                    userInfo = await googleAPI.getUserInfo();
                } catch (e) {
                    console.warn('Could not get user info:', e);
                }

                return {
                    success: true,
                    message: userInfo 
                        ? `‚úÖ Authenticated as ${userInfo.email}\n\nYou can now use use_google to access Google APIs.`
                        : '‚úÖ Authentication successful!\n\nYou can now use use_google to access Google APIs.',
                    email: userInfo?.email,
                    scopes: token.scope?.split(' ') || []
                };
            } catch (error) {
                return { error: error.message || 'Authentication failed' };
            }
        }
    });

    const useGoogleTool = tool({
        name: 'use_google',
        description: `Execute Google API operations (Gmail, Drive, Calendar, YouTube, Sheets, Docs, etc.)

Universal access to 200+ Google APIs through the Discovery API.

Args:
  service: Google service name (gmail, drive, calendar, youtube, sheets, etc.)
  version: API version (v1, v3, etc.)
  resource: Resource path (e.g., 'users.messages', 'files', 'events')
  method: Method name (list, get, create, delete, send, etc.)
  parameters: API parameters as object

Examples:
  // List Gmail messages
  use_google({
    service: "gmail", version: "v1",
    resource: "users.messages", method: "list",
    parameters: { userId: "me", maxResults: 10 }
  })

  // Get calendar events
  use_google({
    service: "calendar", version: "v3",
    resource: "events", method: "list",
    parameters: { calendarId: "primary" }
  })

  // List Drive files
  use_google({
    service: "drive", version: "v3",
    resource: "files", method: "list",
    parameters: { pageSize: 10 }
  })

  // Search YouTube
  use_google({
    service: "youtube", version: "v3",
    resource: "search", method: "list",
    parameters: { part: "snippet", q: "coding tutorials", maxResults: 5 }
  })`,
        inputSchema: z.object({
            service: z.string().describe('Google service (gmail, drive, calendar, youtube, sheets, docs, etc.)'),
            version: z.string().describe('API version (v1, v3, etc.)'),
            resource: z.string().describe('Resource path (e.g., users.messages, files, events)'),
            method: z.string().describe('Method name (list, get, create, delete, send, etc.)'),
            parameters: z.record(z.string(), z.any()).optional().describe('API parameters'),
            headers: z.record(z.string(), z.string()).optional().describe('Custom HTTP headers')
        }),
        callback: async (input) => {
            try {
                // Check if authenticated
                if (!googleAPI.isAuthenticated()) {
                    const config = googleAPI.getConfig();
                    if (!config?.clientId) {
                        return { 
                            error: 'Google not configured. Go to settings ‚Üí Google tab to set up OAuth.' 
                        };
                    }
                    return { 
                        error: 'Not authenticated. Use google_auth tool first to sign in.' 
                    };
                }

                const result = await googleAPI.callAPI(
                    input.service,
                    input.version,
                    input.resource,
                    input.method,
                    input.parameters || {},
                    input.headers || {}
                );

                if (result.status === 'error') {
                    return { error: result.error };
                }

                return {
                    success: true,
                    data: result.data
                };
            } catch (error) {
                return { error: error.message || 'API call failed' };
            }
        }
    });

    const gmailSendTool = tool({
        name: 'gmail_send',
        description: `Send an email via Gmail. Handles message formatting automatically.

Example:
  gmail_send({
    to: "friend@example.com",
    subject: "Hello!",
    body: "This is a test email."
  })`,
        inputSchema: z.object({
            to: z.string().describe('Recipient email address'),
            subject: z.string().describe('Email subject'),
            body: z.string().describe('Email body (plain text or HTML)'),
            cc: z.array(z.string()).optional().describe('CC recipients'),
            bcc: z.array(z.string()).optional().describe('BCC recipients'),
            html: z.boolean().optional().describe('If true, body is HTML')
        }),
        callback: async (input) => {
            try {
                if (!googleAPI.isAuthenticated()) {
                    return { error: 'Not authenticated. Use google_auth tool first.' };
                }

                // Get user email first
                const userInfo = await googleAPI.getUserInfo();
                const senderEmail = userInfo.email;

                // Create MIME message
                const boundary = '===boundary===';
                let message = '';
                
                message += `From: ${senderEmail}\r\n`;
                message += `To: ${input.to}\r\n`;
                if (input.cc?.length) message += `Cc: ${input.cc.join(', ')}\r\n`;
                if (input.bcc?.length) message += `Bcc: ${input.bcc.join(', ')}\r\n`;
                message += `Subject: ${input.subject}\r\n`;
                message += `MIME-Version: 1.0\r\n`;
                message += `Content-Type: text/${input.html ? 'html' : 'plain'}; charset=UTF-8\r\n`;
                message += `\r\n`;
                message += input.body;

                // Base64 URL-safe encode
                const encodedMessage = btoa(unescape(encodeURIComponent(message)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');

                // Send via Gmail API
                const result = await googleAPI.callAPI(
                    'gmail', 'v1',
                    'users.messages', 'send',
                    { userId: 'me', resource: { raw: encodedMessage } }
                );

                if (result.status === 'error') {
                    return { error: result.error };
                }

                return {
                    success: true,
                    message: `‚úÖ Email sent to ${input.to}`,
                    messageId: result.data?.id
                };
            } catch (error) {
                return { error: error.message || 'Failed to send email' };
            }
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SELF-MODIFICATION TOOLS - Agent can create its own tools!
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Storage key for custom tools
    const CUSTOM_TOOLS_KEY = 'agi_custom_tools';

    // Load custom tools from localStorage
    function loadCustomTools() {
        try {
            const stored = localStorage.getItem(CUSTOM_TOOLS_KEY);
            if (!stored) return {};
            return JSON.parse(stored);
        } catch (e) {
            console.warn('Failed to load custom tools:', e);
            return {};
        }
    }

    // Save custom tools to localStorage
    function saveCustomTools(tools) {
        localStorage.setItem(CUSTOM_TOOLS_KEY, JSON.stringify(tools));
    }

    // Create a tool from stored definition
    function createToolFromDefinition(name, def) {
        try {
            // Build the Zod schema from the stored schema definition
            const schemaObj = {};
            for (const [key, prop] of Object.entries(def.inputSchema.properties || {})) {
                let zodType;
                switch (prop.type) {
                    case 'number': zodType = z.number(); break;
                    case 'boolean': zodType = z.boolean(); break;
                    case 'array': zodType = z.array(z.any()); break;
                    case 'object': zodType = z.object({}).passthrough(); break;
                    default: zodType = z.string();
                }
                if (prop.description) zodType = zodType.describe(prop.description);
                if (!(def.inputSchema.required || []).includes(key)) zodType = zodType.optional();
                schemaObj[key] = zodType;
            }

            // Create the callback function from stored code
            const callbackFn = new Function('input', `
                return (async () => {
                    ${def.code}
                })();
            `);

            return tool({
                name: name,
                description: def.description,
                inputSchema: z.object(schemaObj),
                callback: callbackFn
            });
        } catch (e) {
            console.error(`Failed to create tool ${name}:`, e);
            return null;
        }
    }

    // Build all custom tools as actual tool objects
    function buildCustomTools() {
        const customToolDefs = loadCustomTools();
        const tools = [];
        for (const [name, def] of Object.entries(customToolDefs)) {
            const t = createToolFromDefinition(name, def);
            if (t) tools.push(t);
        }
        return tools;
    }

    const createToolTool = tool({
        name: 'create_tool',
        description: `Create a new tool that will be available to the agent. The tool persists across sessions.
        
IMPORTANT: The 'code' parameter should be the BODY of an async function that receives 'input' as parameter.
Return a result object. You have access to: fetch, localStorage, document, console, etc.

Example - create a tool that gets weather:
{
    "name": "get_weather",
    "description": "Get weather for a city",
    "inputSchema": {
        "type": "object",
        "properties": {
            "city": { "type": "string", "description": "City name" }
        },
        "required": ["city"]
    },
    "code": "const response = await fetch('https://wttr.in/' + input.city + '?format=j1');\\nconst data = await response.json();\\nreturn { temperature: data.current_condition[0].temp_C, description: data.current_condition[0].weatherDesc[0].value };"
}`,
        inputSchema: z.object({
            name: z.string().describe('Tool name (snake_case)'),
            description: z.string().describe('What the tool does'),
            inputSchema: z.object({
                type: z.literal('object'),
                properties: z.record(z.string(), z.object({
                    type: z.string(),
                    description: z.string().optional()
                })),
                required: z.array(z.string()).optional()
            }).describe('JSON Schema for tool inputs'),
            code: z.string().describe('JavaScript code - body of async function with input parameter. Must return a result.')
        }),
        callback: async (input) => {
            try {
                // Validate the tool name
                if (!/^[a-z][a-z0-9_]*$/.test(input.name)) {
                    return { error: 'Tool name must be snake_case (lowercase, underscores, start with letter)' };
                }

                // Check for reserved names
                const reserved = ['create_tool', 'list_tools', 'delete_tool', 'render_ui', 'javascript_eval', 'storage_get', 'storage_set', 'fetch_url', 'update_self', 'notify'];
                if (reserved.includes(input.name)) {
                    return { error: `Cannot override built-in tool: ${input.name}` };
                }

                // Test that the code compiles
                try {
                    new Function('input', input.code);
                } catch (e) {
                    return { error: `Invalid JavaScript code: ${e.message}` };
                }

                // Store the tool definition
                const customTools = loadCustomTools();
                const toolDef = {
                    description: input.description,
                    inputSchema: input.inputSchema,
                    code: input.code,
                    createdAt: new Date().toISOString()
                };
                customTools[input.name] = toolDef;
                saveCustomTools(customTools);

                // Immediately add tool to current agent (hot-reload!)
                const newTool = createToolFromDefinition(input.name, toolDef);
                if (newTool && agent) {
                    agent.tools.push(newTool);
                }

                return { 
                    success: true, 
                    message: `Tool '${input.name}' created and ready to use immediately!`,
                    tool: input.name
                };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    const listToolsTool = tool({
        name: 'list_tools',
        description: 'List all available tools, including custom tools created by the agent',
        inputSchema: z.object({
            includeBuiltIn: z.boolean().optional().describe('Include built-in tools (default: true)')
        }),
        callback: async (input = {}) => {
            const includeBuiltIn = input?.includeBuiltIn !== false;
            const result = { custom: [], builtIn: [] };

            // Custom tools
            const customTools = loadCustomTools();
            for (const [name, def] of Object.entries(customTools)) {
                result.custom.push({
                    name,
                    description: def.description,
                    createdAt: def.createdAt
                });
            }

            // Built-in tools
            if (includeBuiltIn) {
                result.builtIn = [
                    'render_ui', 'javascript_eval', 'storage_get', 'storage_set',
                    'fetch_url', 'update_self', 'notify', 'create_tool', 'list_tools', 'delete_tool'
                ];
            }

            return result;
        }
    });

    const deleteToolTool = tool({
        name: 'delete_tool',
        description: 'Delete a custom tool created by the agent',
        inputSchema: z.object({
            name: z.string().describe('Name of the tool to delete')
        }),
        callback: async (input) => {
            const customTools = loadCustomTools();
            
            if (!customTools[input.name]) {
                return { error: `Tool '${input.name}' not found in custom tools` };
            }

            delete customTools[input.name];
            saveCustomTools(customTools);
            window._agentNeedsReinit = true;

            return { 
                success: true, 
                message: `Tool '${input.name}' deleted. Change takes effect on next message.`
            };
        }
    });

    const BROWSER_TOOLS = [
        renderUiTool,
        javascriptEvalTool,
        storageGetTool,
        storageSetTool,
        fetchUrlTool,
        updateSelfTool,
        notifyTool,
        createToolTool,
        listToolsTool,
        deleteToolTool,
        // Context & Bluetooth tools
        scanBluetoothTool,
        sendToAgentTool,
        getUserContextTool,
        setContextTool,
        enableContextTracking,
        // Map tools
        addMapMarkerTool,
        removeMapMarkerTool,
        clearMapMarkersTool,
        listMapMarkersTool,
        panMapTool,
        getMapLocationTool,
        // Map navigation tools
        flyToMarkerTool,
        flyToLocationTool,
        tourMarkersTool,
        getMarkerPositionTool,
        getAllMarkersTool,
        // Google API tools
        googleAuthTool,
        useGoogleTool,
        gmailSendTool
    ];

    // Expose model classes globally for ambient mode cloning
    window.AnthropicBrowserModel = AnthropicBrowserModel;
    window.OpenAIBrowserModel = OpenAIBrowserModel;
    window.BedrockBrowserModel = BedrockBrowserModel;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE & AGENT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let agent = null;
    let visionAgent = null;
    let pendingImages = [];
    let screenCapture = null;
    let isStreaming = false;
    window._agentNeedsReinit = false;

    // Global API
    window.agi = {
        version: VERSION,
        get agent() { return agent; },
        help: () => console.log('%cType agi.agent to inspect the agent, agi.clear() to clear chat, agi.settings() to open settings.\n\nCustom Tools:\n  agi.tools.list() - List custom tools\n  agi.tools.get(name) - Get tool definition\n  agi.tools.delete(name) - Delete a tool\n  agi.tools.clear() - Delete all custom tools', 'color:#888'),
        clear: () => window.clearChat(),
        settings: () => window.openSettings(),
        tools: {
            list: () => {
                const tools = JSON.parse(localStorage.getItem('agi_custom_tools') || '{}');
                console.table(Object.entries(tools).map(([name, def]) => ({
                    name,
                    description: def.description,
                    created: def.createdAt
                })));
                return Object.keys(tools);
            },
            get: (name) => {
                const tools = JSON.parse(localStorage.getItem('agi_custom_tools') || '{}');
                return tools[name] || null;
            },
            delete: (name) => {
                const tools = JSON.parse(localStorage.getItem('agi_custom_tools') || '{}');
                if (tools[name]) {
                    delete tools[name];
                    localStorage.setItem('agi_custom_tools', JSON.stringify(tools));
                    window._agentNeedsReinit = true;
                    console.log(`Deleted tool: ${name}`);
                    return true;
                }
                return false;
            },
            clear: () => {
                localStorage.removeItem('agi_custom_tools');
                window._agentNeedsReinit = true;
                console.log('All custom tools deleted');
            }
        }
    };

    // Global WebLLM model instance (persisted to avoid reloading)
    let webllmModelInstance = null;

    async function initializeAgent() {
        const provider = localStorage.getItem('provider') || 'anthropic';
        console.log('üîß initializeAgent provider:', provider);
        const systemPrompt = localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT;
        
        let model;
        
        if (provider === 'anthropic') {
            const apiKey = localStorage.getItem('anthropic_api_key');
            const modelId = localStorage.getItem('anthropic_model') || 'claude-haiku-4-5';
            const maxTokensStr = localStorage.getItem('anthropic_max_tokens');
            const headersStr = localStorage.getItem('anthropic_headers');
            
            if (!apiKey) {
                setStatus('no key');
                return false;
            }
            
            const maxTokens = maxTokensStr ? parseInt(maxTokensStr) : 8096;
            let customHeaders = {};
            try {
                if (headersStr) customHeaders = JSON.parse(headersStr);
            } catch (e) {
                console.warn('Invalid custom headers JSON:', e);
            }
            
            model = new AnthropicBrowserModel({ apiKey, modelId, maxTokens, customHeaders });
        } else if (provider === 'openai') {
            const apiKey = localStorage.getItem('openai_api_key');
            const modelId = localStorage.getItem('openai_model') || 'gpt-5-nano-2025-08-07';
            const maxTokensStr = localStorage.getItem('openai_max_tokens');
            const headersStr = localStorage.getItem('openai_headers');
            
            if (!apiKey) {
                setStatus('no key');
                return false;
            }
            
            const maxTokens = maxTokensStr ? parseInt(maxTokensStr) : 8096;
            let customHeaders = {};
            try {
                if (headersStr) customHeaders = JSON.parse(headersStr);
            } catch (e) {
                console.warn('Invalid custom headers JSON:', e);
            }
            
            model = new OpenAIBrowserModel({ apiKey, modelId, maxTokens, customHeaders });
        } else if (provider === 'bedrock') {
            const apiKey = localStorage.getItem('bedrock_api_key');
            const region = localStorage.getItem('bedrock_region') || 'us-east-1';
            const modelId = localStorage.getItem('bedrock_model') || 'global.anthropic.claude-opus-4-5-20251101-v1:0';
            const maxTokensStr = localStorage.getItem('bedrock_max_tokens');
            
            if (!apiKey) {
                setStatus('no key');
                return false;
            }
            
            const maxTokens = maxTokensStr ? parseInt(maxTokensStr) : 8096;
            console.log('üîß Bedrock config:', { region, modelId, maxTokens, hasKey: !!apiKey });
            model = new BedrockBrowserModel({ apiKey, region, modelId, maxTokens });
        } else if (provider === 'webllm') {
            const modelId = localStorage.getItem('webllm_model') || 'Qwen2.5-3B-Instruct-q4f16_1-MLC';
            
            // Check WebGPU support
            if (!navigator.gpu) {
                setStatus('no WebGPU');
                addMessage('error', 'WebGPU not supported. Try Chrome 113+ or Edge 113+.');
                return false;
            }
            
            // Show progress UI
            const progressEl = document.getElementById('webllmProgress');
            const progressText = document.getElementById('webllmProgressText');
            const progressBar = document.getElementById('webllmProgressBar');
            
            // Reuse existing model if same modelId
            if (webllmModelInstance && webllmModelInstance.getConfig().modelId === modelId && webllmModelInstance._loaded) {
                model = webllmModelInstance;
                setStatus('ready (local)');
            } else {
                progressEl.style.display = 'block';
                setStatus('loading model...');
                
                try {
                    model = new WebLLMBrowserModel({
                        modelId,
                        maxTokens: 4096,
                        onProgress: (percent, text) => {
                            progressBar.style.width = percent + '%';
                            progressText.textContent = text || `Loading: ${percent}%`;
                            setStatus(`loading ${percent}%`);
                        }
                    });
                    
                    await model.load();
                    webllmModelInstance = model;
                    progressEl.style.display = 'none';
                    setStatus('ready (local)');
                } catch (e) {
                    progressEl.style.display = 'none';
                    setStatus('load failed');
                    addMessage('error', `Failed to load model: ${e.message}`);
                    return false;
                }
            }
        } else {
            setStatus('unsupported');
            return false;
        }
        
        try {
            // Build custom tools from localStorage
            const customTools = buildCustomTools();
            
            // Filter out disabled tools
            const disabledTools = JSON.parse(localStorage.getItem('agi_disabled_tools') || '[]');
            const enabledBuiltinTools = BROWSER_TOOLS.filter(t => !disabledTools.includes(t.name));
            
            const allTools = [...enabledBuiltinTools, ...customTools];
            
            if (customTools.length > 0) {
                console.log(`‚úÖ Loaded ${customTools.length} custom tool(s):`, customTools.map(t => t.name));
            }
            if (disabledTools.length > 0) {
                console.log(`üö´ Disabled ${disabledTools.length} tool(s):`, disabledTools);
            }

            agent = new Agent({
                model,
                tools: allTools,
                systemPrompt,
                printer: false
            });
            
            // Wrap with VisionAgent for image/screen/ambient support
            visionAgent = new VisionAgent(agent);
            
            // Initialize ambient mode if not already
            if (!visionAgent.ambientMode) {
                visionAgent.enableAmbientMode({
                    idleThreshold: 30000,
                    maxIterations: 3,
                    cooldown: 60000,
                    onTimer: (state, seconds, maxIter) => {
                        // Update timer display on ambient button
                        updateAmbientTimer(state, seconds, maxIter);
                    },
                    onThinking: (mode, iter) => {
                        const status = document.querySelector('.ambient-status');
                        if (status) status.textContent = `${mode} ${iter}...`;
                        
                        // Add ambient message block to UI
                        addAmbientMessage(mode, iter);
                    },
                    onStream: (fullText, delta) => {
                        // Stream ambient output to UI in real-time
                        updateAmbientStreaming(fullText);
                    },
                    onToolCall: (status, toolName, data) => {
                        // Show tool calls from ambient mode
                        if (status === 'running') {
                            addAmbientToolCall(toolName, data);
                        } else if (status === 'done') {
                            updateAmbientToolStatus(toolName, data?.status || 'success');
                        }
                    },
                    onResult: (text, iter) => {
                        const status = document.querySelector('.ambient-status');
                        if (status) status.textContent = `Done (${iter})`;
                        
                        // Finalize the ambient message
                        finalizeAmbientMessage(text, iter);
                    },
                    // NEW: Handle manual trigger as user message
                    onUserMessage: async (prompt, modeLabel) => {
                        // This is called when user clicks ambient/auto button
                        // We run it through the main agent as if user typed it
                        await runAgent(`${modeLabel}: ${prompt}`);
                    }
                });
            }
            
            setStatus('ready');
            window._agentNeedsReinit = false;
            console.log('‚úÖ Agent initialized successfully');
            return true;
        } catch (e) {
            console.error('‚ùå Init failed:', e);
            setStatus('error');
            return false;
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CHAT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async function runAgent(userMessage, images = []) {
        if (!agent || window._agentNeedsReinit) {
            const initialized = await initializeAgent();
            if (!initialized) {
                addMessage('error', 'Not connected. Add your API key in settings.');
                return;
            }
        }

        // Mark main agent as busy (for ambient mode)
        if (visionAgent?.ambientMode) {
            visionAgent.ambientMode.setMainAgentBusy(true);
        }

        // Combine images from parameter and pending
        const allImages = [...images, ...pendingImages];
        pendingImages = []; // Clear pending
        
        // Show message with image count if any
        const msgText = allImages.length > 0 
            ? `${userMessage} [üì∑ ${allImages.length} image${allImages.length > 1 ? 's' : ''}]`
            : userMessage;
        addMessage('user', msgText);
        
        // Inject ambient result if available
        let finalMessage = userMessage;
        if (visionAgent?.ambientMode) {
            const ambientResult = visionAgent.ambientMode.getAndClearResult();
            if (ambientResult) {
                console.log('üåô Injecting ambient result');
                finalMessage = `${ambientResult}\n\n[New user query]:\n${userMessage}`;
            }
        }
        
        // üß† Inject dynamic context from context injector
        const contextStr = contextInjector.getContextString();
        if (contextStr) {
            finalMessage = `${contextStr}\n\n---\n\n${finalMessage}`;
        }
        
        setStatus('thinking...');
        addThinking();

        try {
            let currentText = '';
            
            // Build content blocks
            let input;
            if (allImages.length > 0) {
                // Multi-modal input with images - create proper Message
                const contentBlocks = [];
                
                // Add text first
                if (finalMessage) {
                    contentBlocks.push(new TextBlock(finalMessage));
                }
                
                // Add images
                for (const file of allImages) {
                    try {
                        const resized = await resizeImageIfNeeded(file);
                        const imageBlock = await createImageBlock(resized);
                        // Create ImageBlock instance
                        contentBlocks.push(new ImageBlock(imageBlock.image));
                    } catch (err) {
                        console.error('Failed to process image:', err);
                    }
                }
                
                // Wrap in Message for the agent
                input = [new Message({ role: 'user', content: contentBlocks })];
                console.log(`üì∑ Sending ${allImages.length} images with message`);
            } else {
                input = finalMessage;
            }
            
            for await (const event of agent.stream(input)) {
                if (!event || !event.type) continue;
                
                switch (event.type) {
                    case 'modelContentBlockDeltaEvent':
                        if (event.delta?.type === 'textDelta') {
                            currentText += event.delta.text;
                            updateStreaming(currentText);
                        }
                        break;
                    
                    case 'modelContentBlockStartEvent':
                        if (event.start?.type === 'toolUseStart') {
                            setStatus(event.start.name);
                        }
                        break;
                    
                    case 'beforeToolCallEvent':
                        addToolCall(event.toolUse?.name, event.toolUse?.input, 'running');
                        break;
                    
                    case 'afterToolCallEvent':
                        updateToolStatus(event.toolUse?.name, event.result?.status || 'success');
                        break;
                }
            }
            
            removeThinking();
            if (currentText) {
                finalizeStreaming(currentText);
            }
            
            // Record interaction for ambient mode
            if (visionAgent?.ambientMode) {
                visionAgent.ambientMode.recordInteraction(userMessage, currentText);
            }
            
            setStatus('ready');
            
        } catch (e) {
            console.error('Error:', e);
            removeThinking();
            addMessage('error', e.message);
            setStatus('ready');
            
            // Mark main agent as not busy on error
            if (visionAgent?.ambientMode) {
                visionAgent.ambientMode.setMainAgentBusy(false);
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let streamingEl = null;
    
    // Smart scroll - only auto-scroll if user is near bottom
    function smartScroll() {
        const container = document.getElementById('chatContainer');
        if (!container) return;
        
        const threshold = 150; // pixels from bottom to consider "at bottom"
        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
        
        if (isNearBottom) {
            container.scrollTop = container.scrollHeight;
        }
    }

    function addMessage(role, content) {
        const inner = document.getElementById('messagesInner');
        const msg = document.createElement('div');
        msg.className = `message ${role}`;
        
        if (role !== 'system') {
            const roleLabel = document.createElement('div');
            roleLabel.className = 'message-role';
            roleLabel.textContent = role === 'user' ? 'you' : role === 'assistant' ? 'agi' : role;
            msg.appendChild(roleLabel);
        }
        
        const contentEl = document.createElement('div');
        contentEl.className = 'message-content';
        
        if (role === 'user') {
            contentEl.textContent = content;
        } else {
            contentEl.innerHTML = `<div class="markdown-content">${marked.parse(content)}</div>`;
        }
        
        msg.appendChild(contentEl);
        inner.appendChild(msg);
        smartScroll();
    }

    function updateStreaming(text) {
        const inner = document.getElementById('messagesInner');
        
        if (!streamingEl) {
            removeThinking();
            streamingEl = document.createElement('div');
            streamingEl.className = 'message assistant';
            
            const roleLabel = document.createElement('div');
            roleLabel.className = 'message-role';
            roleLabel.textContent = 'agi';
            streamingEl.appendChild(roleLabel);
            
            const contentEl = document.createElement('div');
            contentEl.className = 'message-content';
            streamingEl.appendChild(contentEl);
            
            inner.appendChild(streamingEl);
        }
        
        streamingEl.querySelector('.message-content').innerHTML = `<div class="markdown-content">${marked.parse(text)}</div>`;
        smartScroll();
    }

    function finalizeStreaming(text) {
        if (streamingEl) {
            streamingEl.querySelector('.message-content').innerHTML = `<div class="markdown-content">${marked.parse(text)}</div>`;
            streamingEl = null;
        }
        // Save messages after streaming completes
        setTimeout(saveMessagesToStorage, 100);
    }

    function addToolCall(name, input, status) {
        const inner = document.getElementById('messagesInner');
        const tool = document.createElement('div');
        tool.className = 'tool-block';
        tool.id = `tool-${name}-${Date.now()}`;
        tool.innerHTML = `
            <div class="tool-header">
                <div class="tool-status ${status}"></div>
                <span class="tool-name">${name}</span>
            </div>
            <details>
                <summary style="cursor:pointer;color:var(--text-tertiary);font-size:11px;margin-top:8px;">input</summary>
                <div class="tool-input">${JSON.stringify(input, null, 2)}</div>
            </details>
        `;
        inner.appendChild(tool);
        smartScroll();
    }

    function updateToolStatus(name, status) {
        const blocks = document.querySelectorAll('.tool-block');
        for (let i = blocks.length - 1; i >= 0; i--) {
            const block = blocks[i];
            if (block.querySelector('.tool-name')?.textContent === name) {
                const dot = block.querySelector('.tool-status');
                if (dot) dot.className = `tool-status ${status === 'error' ? 'error' : ''}`;
                break;
            }
        }
    }

    function addThinking() {
        const inner = document.getElementById('messagesInner');
        if (inner.querySelector('.thinking-indicator')) return;
        
        const thinking = document.createElement('div');
        thinking.className = 'message assistant thinking-indicator';
        
        const roleLabel = document.createElement('div');
        roleLabel.className = 'message-role';
        roleLabel.textContent = 'agi';
        thinking.appendChild(roleLabel);
        
        const content = document.createElement('div');
        content.className = 'message-content';
        content.innerHTML = `<div class="thinking"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div>`;
        thinking.appendChild(content);
        
        inner.appendChild(thinking);
        smartScroll();
    }

    function removeThinking() {
        const indicator = document.querySelector('.thinking-indicator');
        if (indicator) indicator.remove();
    }

    function setStatus(text) {
        document.getElementById('sdkStatus').textContent = text;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AMBIENT MODE UI HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let ambientStreamingEl = null;

    function addAmbientMessage(mode, iter) {
        const inner = document.getElementById('messagesInner');
        
        // Remove any existing ambient streaming element
        if (ambientStreamingEl) {
            ambientStreamingEl = null;
        }
        
        // Create ambient message container
        ambientStreamingEl = document.createElement('div');
        ambientStreamingEl.className = 'message assistant ambient-message';
        ambientStreamingEl.style.cssText = 'border-left: 3px solid rgba(147,112,219,0.5); padding-left: 16px; opacity: 0.9;';
        
        const roleLabel = document.createElement('div');
        roleLabel.className = 'message-role';
        roleLabel.innerHTML = `üåô ${mode} <span style="color:var(--text-tertiary);font-size:10px;">(${iter})</span>`;
        ambientStreamingEl.appendChild(roleLabel);
        
        const contentEl = document.createElement('div');
        contentEl.className = 'message-content ambient-content';
        contentEl.innerHTML = '<div class="thinking"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div>';
        ambientStreamingEl.appendChild(contentEl);
        
        inner.appendChild(ambientStreamingEl);
        smartScroll();
    }

    function updateAmbientStreaming(text) {
        if (!ambientStreamingEl) return;
        
        const contentEl = ambientStreamingEl.querySelector('.ambient-content');
        if (contentEl) {
            contentEl.innerHTML = `<div class="markdown-content">${marked.parse(text)}</div>`;
            smartScroll();
        }
    }

    function addAmbientToolCall(toolName, input) {
        if (!ambientStreamingEl) return;
        
        const toolBlock = document.createElement('div');
        toolBlock.className = 'tool-block ambient-tool';
        toolBlock.id = `ambient-tool-${toolName}-${Date.now()}`;
        toolBlock.innerHTML = `
            <div class="tool-header">
                <div class="tool-status running"></div>
                <span class="tool-name">üåô ${toolName}</span>
            </div>
            <details>
                <summary style="cursor:pointer;color:var(--text-tertiary);font-size:11px;margin-top:8px;">input</summary>
                <div class="tool-input">${JSON.stringify(input, null, 2)}</div>
            </details>
        `;
        
        ambientStreamingEl.appendChild(toolBlock);
        smartScroll();
    }

    function updateAmbientToolStatus(toolName, status) {
        if (!ambientStreamingEl) return;
        
        const blocks = ambientStreamingEl.querySelectorAll('.ambient-tool');
        for (let i = blocks.length - 1; i >= 0; i--) {
            const block = blocks[i];
            if (block.querySelector('.tool-name')?.textContent.includes(toolName)) {
                const dot = block.querySelector('.tool-status');
                if (dot) dot.className = `tool-status ${status === 'error' ? 'error' : ''}`;
                break;
            }
        }
    }

    function finalizeAmbientMessage(text, iter) {
        if (!ambientStreamingEl) return;
        
        const contentEl = ambientStreamingEl.querySelector('.ambient-content');
        if (contentEl) {
            contentEl.innerHTML = `<div class="markdown-content">${marked.parse(text)}</div>`;
        }
        
        // Add a subtle "stored" indicator
        const storedIndicator = document.createElement('div');
        storedIndicator.style.cssText = 'font-size:11px;color:var(--text-tertiary);margin-top:12px;font-style:italic;';
        storedIndicator.textContent = `üíæ Stored - will be injected into your next message`;
        ambientStreamingEl.appendChild(storedIndicator);
        
        // Reset for next iteration
        ambientStreamingEl = null;
        
        smartScroll();
    }

    function updateAmbientTimer(state, seconds, maxIter) {
        const ambientStatus = document.getElementById('ambientStatus');
        const ambientBtn = document.getElementById('ambientBtn');
        const autoBtn = document.getElementById('autoBtn');
        
        if (!ambientStatus) return;
        
        // Update status text based on state
        switch (state) {
            case 'idle':
                ambientStatus.textContent = `‚è±Ô∏è ${seconds}s until thinking...`;
                ambientStatus.style.color = 'rgba(255,255,255,0.5)';
                break;
            case 'cooldown':
                ambientStatus.textContent = `‚è≥ cooldown ${seconds}s`;
                ambientStatus.style.color = 'rgba(147,112,219,0.7)';
                break;
            case 'ready':
                ambientStatus.textContent = `‚ú® ready to think`;
                ambientStatus.style.color = 'rgba(100,255,100,0.7)';
                break;
            case 'running':
                ambientStatus.textContent = `üß† thinking...`;
                ambientStatus.style.color = 'rgba(147,112,219,0.9)';
                break;
            case 'waiting':
                ambientStatus.textContent = `‚è∏Ô∏è waiting for main`;
                ambientStatus.style.color = 'rgba(255,165,0,0.7)';
                break;
            case 'done':
                ambientStatus.textContent = `‚úÖ done (${maxIter}/${maxIter})`;
                ambientStatus.style.color = 'rgba(100,255,100,0.7)';
                break;
            case 'stopped':
                ambientStatus.textContent = '';
                break;
            default:
                ambientStatus.textContent = state;
        }
        
        // Update button visual state
        if (ambientBtn) {
            const isActive = ['idle', 'cooldown', 'ready', 'running'].includes(state);
            ambientBtn.classList.toggle('active', isActive && !autoBtn?.classList.contains('active'));
        }
    }

    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    window.handleKeyDown = function(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            window.sendMessage();
        }
    };

    window.autoResize = function(el) {
        el.style.height = 'auto';
        el.style.height = Math.min(el.scrollHeight, 200) + 'px';
    };

    window.sendMessage = async function() {
        const input = document.getElementById('inputField');
        const text = input.value.trim();
        if (!text || isStreaming) return;
        
        input.value = '';
        input.style.height = 'auto';
        
        isStreaming = true;
        document.getElementById('sendBtn').disabled = true;
        
        try {
            await runAgent(text);
        } finally {
            isStreaming = false;
            document.getElementById('sendBtn').disabled = false;
        }
    };

    window.clearChat = function() {
        const inner = document.getElementById('messagesInner');
        inner.innerHTML = `
            <div class="message system">
                <div class="message-content">
                    Build your own AGI. Strands Agent running entirely in your browser.
                    <br><br>
                    Open console for documentation.
                </div>
            </div>
        `;
        window._agentNeedsReinit = true;
        // Clear persisted messages too
        localStorage.removeItem(MESSAGES_STORAGE_KEY);
        showToast('cleared');
    };

    window.openSettings = function() {
        document.getElementById('settingsModal').classList.add('active');
    };

    window.closeSettings = function() {
        document.getElementById('settingsModal').classList.remove('active');
    };

    window.showTab = function(tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
        
        // Update PWA status when tools tab is shown
        if (tabName === 'tools') {
            const pwaStatus = document.getElementById('pwaStatus');
            if (pwaStatus) {
                const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
                const hasServiceWorker = 'serviceWorker' in navigator;
                const notifPermission = 'Notification' in window ? Notification.permission : 'unsupported';
                
                pwaStatus.innerHTML = `
                    <strong>Installed:</strong> ${isStandalone ? '‚úÖ Yes' : '‚ùå No (add to home screen)'}<br>
                    <strong>Service Worker:</strong> ${hasServiceWorker ? '‚úÖ Supported' : '‚ùå Not supported'}<br>
                    <strong>Notifications:</strong> ${notifPermission === 'granted' ? '‚úÖ Enabled' : notifPermission === 'denied' ? '‚ùå Blocked' : notifPermission === 'default' ? '‚ö†Ô∏è Not requested' : '‚ùå Not supported'}<br>
                    <strong>Background:</strong> ${isStandalone && hasServiceWorker ? '‚úÖ Ready' : '‚ö†Ô∏è Install PWA for full support'}
                `;
            }
        }
    };

    window.updateProviderFields = function() {
        const provider = document.getElementById('provider').value;
        document.getElementById('anthropicFields').style.display = provider === 'anthropic' ? 'block' : 'none';
        document.getElementById('openaiFields').style.display = provider === 'openai' ? 'block' : 'none';
        document.getElementById('bedrockFields').style.display = provider === 'bedrock' ? 'block' : 'none';
        document.getElementById('webllmFields').style.display = provider === 'webllm' ? 'block' : 'none';
    };

    window.saveCredentials = async function() {
        const provider = document.getElementById('provider').value;
        localStorage.setItem('provider', provider);
        
        if (provider === 'anthropic') {
            localStorage.setItem('anthropic_api_key', document.getElementById('anthropicApiKey').value);
            localStorage.setItem('anthropic_model', document.getElementById('anthropicModel').value || 'claude-haiku-4-5');
            localStorage.setItem('anthropic_max_tokens', document.getElementById('anthropicMaxTokens').value || '');
            localStorage.setItem('anthropic_headers', document.getElementById('anthropicHeaders').value || '');
        } else if (provider === 'openai') {
            localStorage.setItem('openai_api_key', document.getElementById('openaiApiKey').value);
            localStorage.setItem('openai_model', document.getElementById('openaiModel').value || 'gpt-5-nano-2025-08-07');
            localStorage.setItem('openai_max_tokens', document.getElementById('openaiMaxTokens').value || '');
            localStorage.setItem('openai_headers', document.getElementById('openaiHeaders').value || '');
        } else if (provider === 'bedrock') {
            localStorage.setItem('bedrock_api_key', document.getElementById('bedrockApiKey').value);
            localStorage.setItem('bedrock_region', document.getElementById('bedrockRegion').value || 'us-east-1');
            localStorage.setItem('bedrock_model', document.getElementById('bedrockModel').value || 'global.anthropic.claude-opus-4-5-20251101-v1:0');
            localStorage.setItem('bedrock_max_tokens', document.getElementById('bedrockMaxTokens').value || '');
        } else if (provider === 'webllm') {
            localStorage.setItem('webllm_model', document.getElementById('webllmModel').value);
        }
        
        window._agentNeedsReinit = true;
        const success = await initializeAgent();
        if (success) {
            showToast('connected');
            closeSettings();
        } else {
            showToast('failed');
        }
    };

    window.saveSystemPrompt = async function() {
        localStorage.setItem('system_prompt', document.getElementById('systemPrompt').value);
        window._agentNeedsReinit = true;
        await initializeAgent();
        showToast('saved');
    };

    window.testConnection = async function() {
        // Save current form values first
        const provider = document.getElementById('provider').value;
        localStorage.setItem('provider', provider);
        if (provider === 'bedrock') {
            localStorage.setItem('bedrock_api_key', document.getElementById('bedrockApiKey').value);
            localStorage.setItem('bedrock_region', document.getElementById('bedrockRegion').value || 'us-east-1');
            localStorage.setItem('bedrock_model', document.getElementById('bedrockModel').value || 'global.anthropic.claude-opus-4-5-20251101-v1:0');
            localStorage.setItem('bedrock_max_tokens', document.getElementById('bedrockMaxTokens').value || '');
        }
        
        setStatus('testing...');
        window._agentNeedsReinit = true;
        const success = await initializeAgent();
        if (!success) {
            showToast('failed');
            return;
        }
        
        // Actually test the connection with a simple request
        try {
            const testMessages = [{ role: 'user', content: [{ type: 'textBlock', text: 'Hi' }] }];
            for await (const event of agent.model.stream(testMessages, {})) {
                // Just need one event to confirm it works
                if (event.type === 'modelMessageStartEvent' || event.type === 'modelContentBlockStartEvent') {
                    setStatus('ready');
                    showToast('connected');
                    return;
                }
            }
            setStatus('ready');
            showToast('connected');
        } catch (e) {
            console.error('Connection test failed:', e);
            setStatus('failed');
            showToast('failed: ' + e.message);
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SERVICE WORKER & PWA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let swRegistration = null;

    async function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            try {
                swRegistration = await navigator.serviceWorker.register('/sw.js');
                console.log('‚úÖ Service Worker registered:', swRegistration.scope);
                
                // Listen for updates
                swRegistration.addEventListener('updatefound', () => {
                    const newWorker = swRegistration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            showToast('Update available! Refresh to update.');
                        }
                    });
                });
                
                return true;
            } catch (error) {
                console.error('‚ùå Service Worker registration failed:', error);
                return false;
            }
        }
        return false;
    }

    async function requestNotificationPermission() {
        if (!('Notification' in window)) {
            showToast('Notifications not supported');
            return false;
        }
        
        if (Notification.permission === 'granted') {
            showToast('Notifications enabled');
            return true;
        }
        
        if (Notification.permission === 'denied') {
            showToast('Notifications blocked. Enable in browser settings.');
            return false;
        }
        
        const permission = await Notification.requestPermission();
        if (permission === 'granted') {
            showToast('Notifications enabled!');
            // Send a test notification
            if (swRegistration) {
                swRegistration.showNotification('agi.diy', {
                    body: 'Notifications are now enabled!',
                    icon: '/icon-192.svg'
                });
            }
            return true;
        } else {
            showToast('Notifications denied');
            return false;
        }
    }

    // Expose for button
    window.requestNotificationPermission = requestNotificationPermission;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // VISION CONTROLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initVisionControls() {
        const container = document.getElementById('visionControls');
        if (!container) return;
        
        container.innerHTML = `
            <style>
                .vision-btn {
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    background: rgba(255,255,255,0.05);
                    border: 1px solid rgba(255,255,255,0.1);
                    color: rgba(255,255,255,0.6);
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.2s;
                    font-size: 16px;
                }
                .vision-btn:hover {
                    background: rgba(255,255,255,0.1);
                    color: rgba(255,255,255,0.9);
                }
                .vision-btn.active {
                    background: rgba(147,112,219,0.2);
                    border-color: rgba(147,112,219,0.4);
                    color: rgba(147,112,219,0.9);
                }
                .vision-btn.has-images {
                    background: rgba(100,150,255,0.2);
                    border-color: rgba(100,150,255,0.4);
                    color: rgba(100,150,255,0.9);
                }
                .vision-btn.recording {
                    background: rgba(255,100,100,0.2);
                    border-color: rgba(255,100,100,0.4);
                    color: rgba(255,100,100,0.9);
                    animation: pulse 2s infinite;
                }
                .image-preview-strip {
                    display: flex;
                    gap: 4px;
                    max-width: 150px;
                    overflow-x: auto;
                }
                .image-preview-item {
                    width: 28px;
                    height: 28px;
                    border-radius: 6px;
                    object-fit: cover;
                    border: 1px solid rgba(255,255,255,0.1);
                }
                .clear-images {
                    font-size: 11px;
                    color: rgba(255,100,100,0.6);
                    cursor: pointer;
                    padding: 2px 6px;
                }
                .clear-images:hover {
                    color: rgba(255,100,100,1);
                }
                .ambient-status {
                    font-size: 11px;
                    color: rgba(255,255,255,0.4);
                    margin-left: 4px;
                }
                .screen-interval {
                    background: rgba(255,255,255,0.05);
                    border: 1px solid rgba(255,255,255,0.1);
                    color: rgba(255,255,255,0.6);
                    border-radius: 6px;
                    padding: 4px 6px;
                    font-size: 11px;
                    display: none;
                }
            </style>
            
            <!-- Image Upload -->
            <input type="file" id="imageInput" accept="image/*" multiple style="display:none">
            <button class="vision-btn" id="imageBtn" title="Add images (üì∑)">üì∑</button>
            <div class="image-preview-strip" id="imagePreview"></div>
            <span class="clear-images" id="clearImages" style="display:none">‚úï</span>
            
            <!-- Screen Capture -->
            <button class="vision-btn" id="screenBtn" title="Screen watch (üñ•Ô∏è)">üñ•Ô∏è</button>
            <select class="screen-interval" id="screenInterval">
                <option value="5000">5s</option>
                <option value="10000">10s</option>
                <option value="30000">30s</option>
            </select>
            
            <!-- Ambient Mode -->
            <button class="vision-btn" id="ambientBtn" title="Ambient mode (üåô)">üåô</button>
            <button class="vision-btn" id="autoBtn" title="Autonomous mode (üöÄ)">üöÄ</button>
            <button class="vision-btn" id="bluetoothBtn" title="Scan Bluetooth (üì°)">üì°</button>
            <button class="vision-btn" id="mapToggleBtn" title="Toggle map background (üó∫Ô∏è)">üó∫Ô∏è</button>
            <span class="ambient-status" id="ambientStatus"></span>
        `;
        
        // Image upload handlers
        const imageInput = document.getElementById('imageInput');
        const imageBtn = document.getElementById('imageBtn');
        const imagePreview = document.getElementById('imagePreview');
        const clearImagesBtn = document.getElementById('clearImages');
        
        imageBtn.addEventListener('click', () => imageInput.click());
        
        imageInput.addEventListener('change', (e) => {
            pendingImages = [...e.target.files];
            updateImagePreview();
        });
        
        clearImagesBtn.addEventListener('click', () => {
            pendingImages = [];
            imageInput.value = '';
            updateImagePreview();
        });
        
        function updateImagePreview() {
            imagePreview.innerHTML = '';
            clearImagesBtn.style.display = pendingImages.length > 0 ? 'inline' : 'none';
            imageBtn.classList.toggle('has-images', pendingImages.length > 0);
            
            pendingImages.forEach(file => {
                const img = document.createElement('img');
                img.className = 'image-preview-item';
                img.src = URL.createObjectURL(file);
                imagePreview.appendChild(img);
            });
        }
        
        // Screen capture handlers
        const screenBtn = document.getElementById('screenBtn');
        const screenInterval = document.getElementById('screenInterval');
        let isScreenWatching = false;
        
        screenBtn.addEventListener('click', async () => {
            if (isScreenWatching) {
                // Stop
                if (screenCapture) {
                    screenCapture.stop();
                    screenCapture = null;
                }
                screenBtn.classList.remove('recording');
                screenBtn.textContent = 'üñ•Ô∏è';
                screenInterval.style.display = 'none';
                isScreenWatching = false;
                showToast('Screen watch stopped');
            } else {
                // Start
                screenCapture = new ScreenCapture();
                const started = await screenCapture.start();
                
                if (started) {
                    screenBtn.classList.add('recording');
                    screenBtn.textContent = '‚èπÔ∏è';
                    screenInterval.style.display = 'inline';
                    isScreenWatching = true;
                    
                    const interval = parseInt(screenInterval.value);
                    screenCapture.startInterval(interval, async (frame) => {
                        console.log('üì∏ Screen captured');
                        // Auto-send with context
                        const prompt = 'Here is my current screen. What do you see? Any suggestions or observations?';
                        // Convert frame to File-like object
                        const blob = new Blob([frame.image.source.bytes], { type: 'image/jpeg' });
                        const file = new File([blob], 'screen.jpg', { type: 'image/jpeg' });
                        pendingImages.push(file);
                        updateImagePreview();
                        showToast('üì∏ Screen captured');
                    });
                    
                    showToast('Screen watch started');
                } else {
                    showToast('Screen capture failed');
                }
            }
        });
        
        screenInterval.addEventListener('change', () => {
            if (isScreenWatching && screenCapture) {
                screenCapture.stopInterval();
                const interval = parseInt(screenInterval.value);
                screenCapture.startInterval(interval, async (frame) => {
                    const blob = new Blob([frame.image.source.bytes], { type: 'image/jpeg' });
                    const file = new File([blob], 'screen.jpg', { type: 'image/jpeg' });
                    pendingImages.push(file);
                    updateImagePreview();
                });
            }
        });
        
        // Ambient mode handlers
        const ambientBtn = document.getElementById('ambientBtn');
        const autoBtn = document.getElementById('autoBtn');
        const ambientStatus = document.getElementById('ambientStatus');
        
        ambientBtn.addEventListener('click', async () => {
            if (!visionAgent?.ambientMode) return;
            
            const ambient = visionAgent.ambientMode;
            
            if (ambient.running && !ambient.autonomous) {
                // Stop ambient mode
                ambient.stop();
                ambientBtn.classList.remove('active');
                ambientStatus.textContent = '';
            } else {
                // Trigger ambient mode manually - sends as user message
                const prompt = await ambient.triggerManually('ambient');
                if (prompt) {
                    ambientBtn.classList.add('active');
                    autoBtn.classList.remove('active');
                    ambientStatus.textContent = 'üåô thinking...';
                    
                    // Start background ambient watching for future idle triggers
                    ambient.start(false);
                }
            }
        });
        
        autoBtn.addEventListener('click', async () => {
            if (!visionAgent?.ambientMode) return;
            
            const ambient = visionAgent.ambientMode;
            
            if (ambient.autonomous) {
                // Stop autonomous mode
                ambient.stop();
                autoBtn.classList.remove('active');
                ambientBtn.classList.remove('active');
                ambientStatus.textContent = '';
            } else {
                // Trigger autonomous mode manually - sends as user message
                const prompt = await ambient.triggerManually('autonomous');
                if (prompt) {
                    autoBtn.classList.add('active');
                    ambientBtn.classList.remove('active');
                    ambientStatus.textContent = 'üöÄ working...';
                    
                    // Start autonomous background mode
                    ambient.start(true);
                }
            }
        });
        
        // Bluetooth scan handler
        const bluetoothBtn = document.getElementById('bluetoothBtn');
        bluetoothBtn?.addEventListener('click', async () => {
            bluetoothBtn.classList.add('active');
            ambientStatus.textContent = 'üì° scanning...';
            
            try {
                const devices = await contextInjector.scanBluetooth();
                const agiAgents = devices.filter(d => d.isAgiAgent);
                
                if (devices.length === 0) {
                    ambientStatus.textContent = 'üì° no devices';
                    showToast('No Bluetooth devices found');
                } else if (agiAgents.length > 0) {
                    ambientStatus.textContent = `üì° ${agiAgents.length} agents`;
                    showToast(`Found ${agiAgents.length} AGI agent(s) nearby!`);
                } else {
                    ambientStatus.textContent = `üì° ${devices.length} devices`;
                    showToast(`Found ${devices.length} device(s)`);
                }
                
                // Auto-send to agent to process the scan results
                if (devices.length > 0) {
                    const deviceList = devices.map(d => 
                        `${d.name || 'Unknown'} (${d.id.slice(0, 8)}...) ${d.isAgiAgent ? 'ü§ñ AGI Agent' : ''}`
                    ).join('\n');
                    
                    await runAgent(`I just scanned for Bluetooth devices. Here's what I found:\n\n${deviceList}\n\nWhat can you tell me about these devices?`);
                }
            } catch (e) {
                ambientStatus.textContent = 'üì° error';
                showToast(`Bluetooth: ${e.message}`);
            } finally {
                bluetoothBtn.classList.remove('active');
            }
        });
        
        // Map toggle handler
        const mapToggleBtn = document.getElementById('mapToggleBtn');
        mapToggleBtn?.addEventListener('click', async () => {
            const isEnabled = localStorage.getItem('map_enabled') === 'true';
            const apiKey = localStorage.getItem('google_maps_api_key');
            
            if (!apiKey) {
                showToast('Set API key in settings ‚Üí Map');
                window.openSettings();
                // Switch to map tab
                setTimeout(() => {
                    document.querySelector('.tab[data-tab="map"]')?.click();
                }, 100);
                return;
            }
            
            // Toggle map
            localStorage.setItem('map_enabled', (!isEnabled).toString());
            await initMapBackground();
            
            mapToggleBtn.classList.toggle('active', !isEnabled);
            showToast(!isEnabled ? 'Map enabled' : 'Map disabled');
        });
        
        // Update map button state on load
        setTimeout(() => {
            const isEnabled = localStorage.getItem('map_enabled') === 'true';
            mapToggleBtn?.classList.toggle('active', isEnabled);
        }, 100);
        
        console.log('üîÆ Vision controls initialized');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async function init() {
        setStatus('loading...');
        
        // Register service worker first
        await registerServiceWorker();
        
        document.getElementById('provider').value = localStorage.getItem('provider') || 'anthropic';
        document.getElementById('anthropicApiKey').value = localStorage.getItem('anthropic_api_key') || '';
        document.getElementById('anthropicModel').value = localStorage.getItem('anthropic_model') || 'claude-haiku-4-5';
        document.getElementById('anthropicMaxTokens').value = localStorage.getItem('anthropic_max_tokens') || '';
        document.getElementById('anthropicHeaders').value = localStorage.getItem('anthropic_headers') || '';
        document.getElementById('openaiApiKey').value = localStorage.getItem('openai_api_key') || '';
        document.getElementById('openaiModel').value = localStorage.getItem('openai_model') || 'gpt-5-nano-2025-08-07';
        document.getElementById('openaiMaxTokens').value = localStorage.getItem('openai_max_tokens') || '';
        document.getElementById('openaiHeaders').value = localStorage.getItem('openai_headers') || '';
        document.getElementById('bedrockApiKey').value = localStorage.getItem('bedrock_api_key') || '';
        document.getElementById('bedrockRegion').value = localStorage.getItem('bedrock_region') || 'us-east-1';
        document.getElementById('bedrockModel').value = localStorage.getItem('bedrock_model') || 'global.anthropic.claude-opus-4-5-20251101-v1:0';
        document.getElementById('bedrockMaxTokens').value = localStorage.getItem('bedrock_max_tokens') || '';
        document.getElementById('webllmModel').value = localStorage.getItem('webllm_model') || 'Qwen2.5-3B-Instruct-q4f16_1-MLC';
        document.getElementById('systemPrompt').value = localStorage.getItem('system_prompt') || DEFAULT_SYSTEM_PROMPT;
        
        window.updateProviderFields();
        
        const success = await initializeAgent();
        
        // Initialize Vision UI Controls
        initVisionControls();
        
        document.getElementById('inputField').disabled = false;
        document.getElementById('sendBtn').disabled = false;
        document.getElementById('inputField').focus();
        
        // Update notification button state
        updateNotificationButton();
        
        if (!success) {
            addMessage('system', 'Add your API key in settings to get started, or try WebLLM for local inference!');
        }
        
        // Check if running as PWA
        if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('Running as installed PWA');
        }
    }
    
    function updateNotificationButton() {
        const btn = document.getElementById('notifyBtn');
        if (!btn) return;
        
        if (!('Notification' in window)) {
            btn.style.display = 'none';
            return;
        }
        
        if (Notification.permission === 'granted') {
            btn.textContent = 'üîî';
            btn.title = 'Notifications enabled';
        } else if (Notification.permission === 'denied') {
            btn.textContent = 'üîï';
            btn.title = 'Notifications blocked';
        } else {
            btn.textContent = 'üîî';
            btn.title = 'Enable notifications';
        }
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') window.closeSettings();
    });

    // Add event listeners for all interactive elements (module-safe)
    // Header buttons
    document.getElementById('notifyBtn')?.addEventListener('click', requestNotificationPermission);
    document.getElementById('clearBtn')?.addEventListener('click', window.clearChat);
    document.getElementById('settingsBtn')?.addEventListener('click', window.openSettings);
    
    // Modal
    document.getElementById('settingsModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'settingsModal') window.closeSettings();
    });
    document.getElementById('modalCloseBtn')?.addEventListener('click', window.closeSettings);
    
    // Tabs
    document.querySelectorAll('.tab[data-tab]').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.dataset.tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // Update tools tab content when shown
            if (tabName === 'tools') {
                // Render built-in tools with toggle capability
                renderBuiltinTools();
                
                // Update custom tools list
                const customToolsList = document.getElementById('customToolsList');
                if (customToolsList) {
                    const customTools = JSON.parse(localStorage.getItem('agi_custom_tools') || '{}');
                    const toolNames = Object.keys(customTools);
                    if (toolNames.length === 0) {
                        customToolsList.innerHTML = '<em>No custom tools yet. Ask the agent to create one!</em>';
                    } else {
                        customToolsList.innerHTML = toolNames.map(name => {
                            const tool = customTools[name];
                            return `<code>${name}</code> ‚Äî ${tool.description}<br>`;
                        }).join('');
                    }
                }
                
                // Update PWA status
                const pwaStatus = document.getElementById('pwaStatus');
                if (pwaStatus) {
                    const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
                    const hasServiceWorker = 'serviceWorker' in navigator;
                    const notifPermission = 'Notification' in window ? Notification.permission : 'unsupported';
                    
                    pwaStatus.innerHTML = `
                        <strong>Installed:</strong> ${isStandalone ? '‚úÖ Yes' : '‚ùå No (add to home screen)'}<br>
                        <strong>Service Worker:</strong> ${hasServiceWorker ? '‚úÖ Supported' : '‚ùå Not supported'}<br>
                        <strong>Notifications:</strong> ${notifPermission === 'granted' ? '‚úÖ Enabled' : notifPermission === 'denied' ? '‚ùå Blocked' : notifPermission === 'default' ? '‚ö†Ô∏è Not requested' : '‚ùå Not supported'}<br>
                        <strong>Background:</strong> ${isStandalone && hasServiceWorker ? '‚úÖ Ready' : '‚ö†Ô∏è Install PWA for full support'}
                    `;
                }
            }
        });
    });
    
    // Provider select
    document.getElementById('provider')?.addEventListener('change', window.updateProviderFields);
    
    // Form buttons
    document.getElementById('saveCredentialsBtn')?.addEventListener('click', window.saveCredentials);
    document.getElementById('testConnectionBtn')?.addEventListener('click', window.testConnection);
    document.getElementById('saveSystemPromptBtn')?.addEventListener('click', window.saveSystemPrompt);
    
    // Input field
    const inputField = document.getElementById('inputField');
    inputField?.addEventListener('keydown', window.handleKeyDown);
    inputField?.addEventListener('input', (e) => window.autoResize(e.target));
    
    // Send button
    document.getElementById('sendBtn')?.addEventListener('click', window.sendMessage);
    
    // Context tab event handlers
    document.getElementById('contextActivity')?.addEventListener('change', (e) => {
        contextInjector.enable('activity', e.target.checked);
        localStorage.setItem('context_activity', e.target.checked);
    });
    
    document.getElementById('contextGeolocation')?.addEventListener('change', (e) => {
        contextInjector.enable('geolocation', e.target.checked);
        localStorage.setItem('context_geolocation', e.target.checked);
    });
    
    document.getElementById('contextBluetooth')?.addEventListener('change', (e) => {
        contextInjector.enable('bluetooth', e.target.checked);
        localStorage.setItem('context_bluetooth', e.target.checked);
    });
    
    document.getElementById('refreshContextBtn')?.addEventListener('click', () => {
        const preview = document.getElementById('contextPreview');
        if (preview) {
            preview.textContent = contextInjector.getContextString() || 'No context enabled';
        }
    });
    
    document.getElementById('addCustomContextBtn')?.addEventListener('click', () => {
        const keyInput = document.getElementById('customContextKey');
        const valueInput = document.getElementById('customContextValue');
        const key = keyInput?.value?.trim();
        const value = valueInput?.value?.trim();
        
        if (key && value) {
            contextInjector.setCustomContext(key, value);
            keyInput.value = '';
            valueInput.value = '';
            updateCustomContextList();
            showToast(`Added context: ${key}`);
        }
    });
    
    function updateCustomContextList() {
        const list = document.getElementById('customContextList');
        if (!list) return;
        
        const context = contextInjector.getContext();
        const custom = context.custom || {};
        const keys = Object.keys(custom);
        
        if (keys.length === 0) {
            list.innerHTML = '<em>No custom context set</em>';
        } else {
            list.innerHTML = keys.map(k => 
                `<span style="background:rgba(255,255,255,0.05);padding:2px 8px;border-radius:4px;margin-right:4px;">${k}: ${custom[k]} <span onclick="window.agiContext.removeCustom('${k}');this.parentElement.remove();" style="cursor:pointer;color:rgba(255,100,100,0.6);">‚úï</span></span>`
            ).join('');
        }
    }
    
    // Load saved context settings on init
    function loadContextSettings() {
        const activity = localStorage.getItem('context_activity') === 'true';
        const geolocation = localStorage.getItem('context_geolocation') === 'true';
        const bluetooth = localStorage.getItem('context_bluetooth') === 'true';
        
        const activityCheckbox = document.getElementById('contextActivity');
        const geoCheckbox = document.getElementById('contextGeolocation');
        const btCheckbox = document.getElementById('contextBluetooth');
        
        if (activityCheckbox) activityCheckbox.checked = activity;
        if (geoCheckbox) geoCheckbox.checked = geolocation;
        if (btCheckbox) btCheckbox.checked = bluetooth;
        
        if (activity) contextInjector.enable('activity', true);
        if (geolocation) contextInjector.enable('geolocation', true);
        if (bluetooth) contextInjector.enable('bluetooth', true);
    }
    
    // Call on page load
    loadContextSettings();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MAP BACKGROUND INITIALIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let mapBackground = null;
    
    async function initMapBackground() {
        const apiKey = localStorage.getItem('google_maps_api_key');
        const mapId = localStorage.getItem('google_maps_map_id');
        const mapEnabled = localStorage.getItem('map_enabled') === 'true';
        const mapStyle = localStorage.getItem('map_style') || 'dark';
        
        if (!mapEnabled || !apiKey) {
            document.documentElement.classList.remove('map-mode');
            document.body.classList.remove('map-mode');
            if (mapBackground) {
                mapBackground.destroy();
                mapBackground = null;
            }
            return;
        }
        
        // Destroy existing map if any
        if (mapBackground) {
            mapBackground.destroy();
        }
        
        // Create new map
        mapBackground = new MapBackground({
            apiKey: apiKey,
            mapId: mapId,
            styleMode: mapStyle,
            onLocationUpdate: (pos) => {
                // Update location display in settings
                const display = document.getElementById('mapLocationDisplay');
                if (display) {
                    display.innerHTML = `
                        <strong>Lat:</strong> ${pos.lat.toFixed(6)}<br>
                        <strong>Lng:</strong> ${pos.lng.toFixed(6)}<br>
                        <strong>Accuracy:</strong> ${pos.accuracy?.toFixed(0) || 'N/A'}m
                        ${pos.speed ? `<br><strong>Speed:</strong> ${(pos.speed * 3.6).toFixed(1)} km/h` : ''}
                    `;
                }
                
                // Also update context injector with location
                if (contextInjector) {
                    contextInjector.setCustomContext('map_location', `${pos.lat.toFixed(4)},${pos.lng.toFixed(4)}`);
                }
            }
        });
        
        const success = await mapBackground.init();
        
        if (success) {
            document.documentElement.classList.add('map-mode');
            document.body.classList.add('map-mode');
            console.log(`üó∫Ô∏è Map background enabled (${mapId ? 'Advanced' : 'Basic'} markers)`);
        } else {
            document.documentElement.classList.remove('map-mode');
            document.body.classList.remove('map-mode');
            console.warn('üó∫Ô∏è Map background failed to initialize');
        }
    }
    
    function loadMapSettings() {
        const apiKey = localStorage.getItem('google_maps_api_key') || '';
        const mapId = localStorage.getItem('google_maps_map_id') || '';
        const mapEnabled = localStorage.getItem('map_enabled') === 'true';
        const mapStyle = localStorage.getItem('map_style') || 'dark';
        
        const apiKeyInput = document.getElementById('googleMapsApiKey');
        const mapIdInput = document.getElementById('googleMapsMapId');
        const enabledCheckbox = document.getElementById('mapEnabled');
        const styleSelect = document.getElementById('mapStyle');
        
        if (apiKeyInput) apiKeyInput.value = apiKey;
        if (mapIdInput) mapIdInput.value = mapId;
        if (enabledCheckbox) enabledCheckbox.checked = mapEnabled;
        if (styleSelect) styleSelect.value = mapStyle;
    }
    
    // Map settings event handlers
    document.getElementById('saveMapSettingsBtn')?.addEventListener('click', async () => {
        const apiKey = document.getElementById('googleMapsApiKey')?.value || '';
        const mapId = document.getElementById('googleMapsMapId')?.value || '';
        const enabled = document.getElementById('mapEnabled')?.checked || false;
        const style = document.getElementById('mapStyle')?.value || 'dark';
        
        localStorage.setItem('google_maps_api_key', apiKey);
        localStorage.setItem('google_maps_map_id', mapId);
        localStorage.setItem('map_enabled', enabled.toString());
        localStorage.setItem('map_style', style);
        
        await initMapBackground();
        showToast(enabled ? (mapId ? 'Map enabled (Advanced)' : 'Map enabled (Basic)') : 'Map disabled');
    });
    
    document.getElementById('testMapBtn')?.addEventListener('click', async () => {
        const apiKey = document.getElementById('googleMapsApiKey')?.value;
        if (!apiKey) {
            showToast('Enter API key first');
            return;
        }
        
        // Temporarily save and test
        localStorage.setItem('google_maps_api_key', apiKey);
        localStorage.setItem('google_maps_map_id', document.getElementById('googleMapsMapId')?.value || '');
        localStorage.setItem('map_enabled', 'true');
        localStorage.setItem('map_style', document.getElementById('mapStyle')?.value || 'dark');
        
        await initMapBackground();
        showToast('Testing map...');
    });
    
    // Load map settings on page load
    loadMapSettings();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GOOGLE SETTINGS EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function loadGoogleSettings() {
        const config = googleAPI.getConfig();
        if (config) {
            const clientIdInput = document.getElementById('googleClientId');
            const apiKeyInput = document.getElementById('googleApiKey');
            if (clientIdInput) clientIdInput.value = config.clientId || '';
            if (apiKeyInput) apiKeyInput.value = config.apiKey || '';
        }
        
        // Show current origin for authorized origins setup
        const originEl = document.getElementById('currentOrigin');
        if (originEl) originEl.textContent = window.location.origin;
        
        updateGoogleAuthStatus();
    }
    
    async function updateGoogleAuthStatus() {
        const statusEl = document.getElementById('googleAuthStatus');
        if (!statusEl) return;
        
        const config = googleAPI.getConfig();
        if (!config?.clientId) {
            statusEl.innerHTML = '‚ùå <strong>Not configured</strong><br>Add OAuth Client ID above';
            statusEl.style.color = 'rgba(255,100,100,0.8)';
            return;
        }
        
        if (googleAPI.isAuthenticated()) {
            try {
                const userInfo = await googleAPI.getUserInfo();
                statusEl.innerHTML = `‚úÖ <strong>Connected</strong><br>Signed in as: ${userInfo.email}`;
                statusEl.style.color = 'rgba(100,255,100,0.8)';
            } catch (e) {
                statusEl.innerHTML = '‚úÖ <strong>Token stored</strong><br>May need refresh';
                statusEl.style.color = 'rgba(255,200,100,0.8)';
            }
        } else {
            statusEl.innerHTML = '‚ö†Ô∏è <strong>Configured but not signed in</strong><br>Click "Authenticate" to connect';
            statusEl.style.color = 'rgba(255,200,100,0.8)';
        }
    }
    
    document.getElementById('saveGoogleConfigBtn')?.addEventListener('click', () => {
        const clientId = document.getElementById('googleClientId')?.value?.trim();
        const apiKey = document.getElementById('googleApiKey')?.value?.trim();
        
        if (!clientId) {
            showToast('Client ID required');
            return;
        }
        
        googleAPI.saveConfig({
            clientId,
            apiKey: apiKey || undefined,
            scopes: DEFAULT_SCOPES
        });
        
        updateGoogleAuthStatus();
        showToast('Google config saved');
    });
    
    document.getElementById('googleAuthBtn')?.addEventListener('click', async () => {
        const config = googleAPI.getConfig();
        if (!config?.clientId) {
            showToast('Save config first');
            return;
        }
        
        try {
            const statusEl = document.getElementById('googleAuthStatus');
            if (statusEl) {
                statusEl.innerHTML = 'üîÑ <strong>Authenticating...</strong><br>Check popup window';
                statusEl.style.color = 'rgba(100,150,255,0.8)';
            }
            
            await googleAPI.requestToken();
            await updateGoogleAuthStatus();
            showToast('Google authenticated!');
        } catch (e) {
            const statusEl = document.getElementById('googleAuthStatus');
            if (statusEl) {
                statusEl.innerHTML = `‚ùå <strong>Auth failed</strong><br>${e.message}`;
                statusEl.style.color = 'rgba(255,100,100,0.8)';
            }
            showToast('Auth failed: ' + e.message);
        }
    });
    
    document.getElementById('googleRevokeBtn')?.addEventListener('click', async () => {
        try {
            await googleAPI.revokeToken();
            await updateGoogleAuthStatus();
            showToast('Google token revoked');
        } catch (e) {
            showToast('Revoke failed: ' + e.message);
        }
    });
    
    // Load Google settings on page load
    loadGoogleSettings();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENCRYPTED SETTINGS EXPORT/IMPORT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const SETTINGS_KEYS = [
        'provider',
        'anthropic_api_key',
        'anthropic_model',
        'anthropic_max_tokens',
        'anthropic_headers',
        'openai_api_key',
        'openai_model',
        'openai_max_tokens',
        'openai_headers',
        'webllm_model',
        'system_prompt',
        'agi_custom_tools',
        'agi_disabled_tools',
        // Google OAuth (stored as JSON object)
        'google_api_config',
        'google_oauth_token',
        // Google Maps
        'google_maps_api_key',
        'google_maps_map_id',
        'map_enabled',
        'map_style',
        // Context settings
        'context_activity',
        'context_geolocation',
        'context_bluetooth',
        // Message persistence
        'persist_messages'
    ];

    async function deriveKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
            'raw',
            enc.encode(password),
            'PBKDF2',
            false,
            ['deriveKey']
        );
        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: salt,
                iterations: 100000,
                hash: 'SHA-256'
            },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        );
    }

    async function encryptSettings(password) {
        // Gather all settings
        const settings = {};
        for (const key of SETTINGS_KEYS) {
            const value = localStorage.getItem(key);
            if (value !== null) {
                settings[key] = value;
            }
        }
        
        const plaintext = JSON.stringify(settings);
        const enc = new TextEncoder();
        
        // Generate salt and IV
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        // Derive key and encrypt
        const key = await deriveKey(password, salt);
        const ciphertext = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            enc.encode(plaintext)
        );
        
        // Combine salt + iv + ciphertext
        const combined = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
        combined.set(salt, 0);
        combined.set(iv, salt.length);
        combined.set(new Uint8Array(ciphertext), salt.length + iv.length);
        
        // Base64 encode
        return btoa(String.fromCharCode(...combined));
    }

    async function decryptSettings(encryptedBase64, password) {
        // Decode base64
        const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
        
        // Extract salt, iv, ciphertext
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const ciphertext = combined.slice(28);
        
        // Derive key and decrypt
        const key = await deriveKey(password, salt);
        const plaintext = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            key,
            ciphertext
        );
        
        const dec = new TextDecoder();
        return JSON.parse(dec.decode(plaintext));
    }

    function generateExportUrl(encryptedData) {
        const url = new URL(window.location.origin + window.location.pathname);
        url.searchParams.set('import', encryptedData);
        return url.toString();
    }

    function applySettings(settings) {
        for (const [key, value] of Object.entries(settings)) {
            localStorage.setItem(key, value);
        }
        window._agentNeedsReinit = true;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESSAGE PERSISTENCE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const MESSAGES_STORAGE_KEY = 'agi_chat_messages';

    function saveMessagesToStorage() {
        if (localStorage.getItem('persist_messages') === 'false') return;
        
        const messagesInner = document.getElementById('messagesInner');
        if (!messagesInner) return;
        
        const messages = [];
        messagesInner.querySelectorAll('.message').forEach(msgEl => {
            const role = msgEl.classList.contains('user') ? 'user' 
                       : msgEl.classList.contains('assistant') ? 'assistant'
                       : msgEl.classList.contains('error') ? 'error'
                       : 'system';
            
            // Skip system intro message
            if (role === 'system' && msgEl.querySelector('.message-content')?.textContent?.includes('Build your own AGI')) {
                return;
            }
            
            const content = msgEl.querySelector('.message-content')?.innerHTML || '';
            if (content) {
                messages.push({ role, content, timestamp: Date.now() });
            }
        });
        
        // Also save tool blocks
        messagesInner.querySelectorAll('.tool-block').forEach(toolEl => {
            const name = toolEl.querySelector('.tool-name')?.textContent || 'unknown';
            const input = toolEl.querySelector('.tool-input')?.textContent || '';
            messages.push({ role: 'tool', name, input, timestamp: Date.now() });
        });
        
        localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(messages));
    }

    function loadMessagesFromStorage() {
        if (localStorage.getItem('persist_messages') === 'false') return;
        
        const stored = localStorage.getItem(MESSAGES_STORAGE_KEY);
        if (!stored) return;
        
        try {
            const messages = JSON.parse(stored);
            if (!Array.isArray(messages) || messages.length === 0) return;
            
            const inner = document.getElementById('messagesInner');
            
            messages.forEach(msg => {
                if (msg.role === 'tool') {
                    // Restore tool block
                    const tool = document.createElement('div');
                    tool.className = 'tool-block';
                    tool.innerHTML = `
                        <div class="tool-header">
                            <div class="tool-status"></div>
                            <span class="tool-name">${msg.name}</span>
                        </div>
                        <details>
                            <summary style="cursor:pointer;color:var(--text-tertiary);font-size:11px;margin-top:8px;">input</summary>
                            <div class="tool-input">${msg.input}</div>
                        </details>
                    `;
                    inner.appendChild(tool);
                } else {
                    // Restore message
                    const msgEl = document.createElement('div');
                    msgEl.className = `message ${msg.role}`;
                    
                    if (msg.role !== 'system') {
                        const roleLabel = document.createElement('div');
                        roleLabel.className = 'message-role';
                        roleLabel.textContent = msg.role === 'user' ? 'you' : msg.role === 'assistant' ? 'agi' : msg.role;
                        msgEl.appendChild(roleLabel);
                    }
                    
                    const contentEl = document.createElement('div');
                    contentEl.className = 'message-content';
                    contentEl.innerHTML = msg.content;
                    msgEl.appendChild(contentEl);
                    
                    inner.appendChild(msgEl);
                }
            });
            
            smartScroll();
        } catch (e) {
            console.warn('Failed to load messages:', e);
        }
    }

    function getChatHistoryStats() {
        const stored = localStorage.getItem(MESSAGES_STORAGE_KEY);
        if (!stored) return { count: 0, size: 0 };
        
        try {
            const messages = JSON.parse(stored);
            return {
                count: messages.length,
                size: (stored.length / 1024).toFixed(1)
            };
        } catch {
            return { count: 0, size: 0 };
        }
    }

    function updateChatHistoryStats() {
        const stats = getChatHistoryStats();
        const statsEl = document.getElementById('chatHistoryStats');
        if (statsEl) {
            statsEl.textContent = `${stats.count} messages saved (${stats.size} KB)`;
        }
    }

    // Auto-save messages after each interaction
    const originalAddMessage = addMessage;
    window._originalAddMessage = originalAddMessage;
    
    // Override to add persistence
    function addMessageWithPersist(role, content) {
        const inner = document.getElementById('messagesInner');
        const msg = document.createElement('div');
        msg.className = `message ${role}`;
        
        if (role !== 'system') {
            const roleLabel = document.createElement('div');
            roleLabel.className = 'message-role';
            roleLabel.textContent = role === 'user' ? 'you' : role === 'assistant' ? 'agi' : role;
            msg.appendChild(roleLabel);
        }
        
        const contentEl = document.createElement('div');
        contentEl.className = 'message-content';
        
        if (role === 'user') {
            contentEl.textContent = content;
        } else {
            contentEl.innerHTML = `<div class="markdown-content">${marked.parse(content)}</div>`;
        }
        
        msg.appendChild(contentEl);
        inner.appendChild(msg);
        smartScroll();
        
        // Auto-save after adding message
        setTimeout(saveMessagesToStorage, 100);
    }

    // Replace the original addMessage function
    addMessage = addMessageWithPersist;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SYNC TAB EVENT HANDLERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    document.getElementById('exportSettingsBtn')?.addEventListener('click', async () => {
        const password = document.getElementById('exportPassword')?.value;
        if (!password || password.length < 4) {
            showToast('Password must be at least 4 characters');
            return;
        }
        
        try {
            const encrypted = await encryptSettings(password);
            const url = generateExportUrl(encrypted);
            
            document.getElementById('exportedUrl').value = url;
            document.getElementById('exportResult').style.display = 'block';
            
            showToast('Settings exported!');
        } catch (e) {
            console.error('Export failed:', e);
            showToast('Export failed: ' + e.message);
        }
    });

    document.getElementById('copyExportBtn')?.addEventListener('click', () => {
        const url = document.getElementById('exportedUrl')?.value;
        if (url) {
            navigator.clipboard.writeText(url);
            showToast('URL copied to clipboard!');
        }
    });

    document.getElementById('importSettingsBtn')?.addEventListener('click', async () => {
        const urlOrData = document.getElementById('importUrl')?.value?.trim();
        const password = document.getElementById('importPassword')?.value;
        const statusEl = document.getElementById('importStatus');
        
        if (!urlOrData) {
            showToast('Paste the encrypted URL first');
            return;
        }
        if (!password) {
            showToast('Enter decryption password');
            return;
        }
        
        statusEl.style.display = 'block';
        statusEl.innerHTML = 'üîÑ Decrypting...';
        statusEl.style.color = 'rgba(100,150,255,0.8)';
        
        try {
            // Extract encrypted data from URL or use directly
            let encryptedData = urlOrData;
            if (urlOrData.includes('?import=')) {
                const url = new URL(urlOrData);
                encryptedData = url.searchParams.get('import');
            }
            
            const settings = await decryptSettings(encryptedData, password);
            applySettings(settings);
            
            // Update form fields
            document.getElementById('provider').value = settings.provider || 'anthropic';
            document.getElementById('anthropicApiKey').value = settings.anthropic_api_key || '';
            document.getElementById('anthropicModel').value = settings.anthropic_model || 'claude-haiku-4-5';
            document.getElementById('openaiApiKey').value = settings.openai_api_key || '';
            document.getElementById('openaiModel').value = settings.openai_model || 'gpt-5-nano-2025-08-07';
            document.getElementById('systemPrompt').value = settings.system_prompt || DEFAULT_SYSTEM_PROMPT;
            window.updateProviderFields();
            
            statusEl.innerHTML = '‚úÖ Settings imported! Reinitializing...';
            statusEl.style.color = 'rgba(100,255,100,0.8)';
            
            // Reload Google API config
            if (window.googleAPI && typeof window.googleAPI.loadConfig === 'function') {
                window.googleAPI.loadConfig();
            }
            
            // Update Google settings UI
            loadGoogleSettings();
            
            // Update map settings UI and reinitialize map
            loadMapSettings();
            await initMapBackground();
            
            // Reinitialize agent
            await initializeAgent();
            
            showToast('Settings imported successfully!');
            
            // Clear import fields
            document.getElementById('importUrl').value = '';
            document.getElementById('importPassword').value = '';
            
        } catch (e) {
            console.error('Import failed:', e);
            statusEl.innerHTML = '‚ùå Decryption failed. Check password.';
            statusEl.style.color = 'rgba(255,100,100,0.8)';
            showToast('Import failed: Wrong password or corrupted data');
        }
    });

    document.getElementById('persistMessages')?.addEventListener('change', (e) => {
        localStorage.setItem('persist_messages', e.target.checked.toString());
        if (e.target.checked) {
            saveMessagesToStorage();
            showToast('Message persistence enabled');
        } else {
            showToast('Message persistence disabled');
        }
    });

    document.getElementById('exportChatBtn')?.addEventListener('click', () => {
        const stored = localStorage.getItem(MESSAGES_STORAGE_KEY);
        if (!stored) {
            showToast('No messages to export');
            return;
        }
        
        const blob = new Blob([stored], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `agi-chat-${new Date().toISOString().slice(0,10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        showToast('Chat exported!');
    });

    document.getElementById('clearChatHistoryBtn')?.addEventListener('click', () => {
        if (confirm('Clear all saved messages? This cannot be undone.')) {
            localStorage.removeItem(MESSAGES_STORAGE_KEY);
            updateChatHistoryStats();
            showToast('Chat history cleared');
        }
    });

    // Check for import URL on page load
    function checkForImportUrl() {
        const url = new URL(window.location.href);
        const importData = url.searchParams.get('import');
        
        if (importData) {
            // Open settings modal and switch to sync tab
            document.getElementById('settingsModal').classList.add('active');
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector('.tab[data-tab="sync"]')?.classList.add('active');
            document.getElementById('tab-sync')?.classList.add('active');
            
            // Pre-fill import URL
            document.getElementById('importUrl').value = window.location.href;
            
            // Clear URL params without reload
            window.history.replaceState({}, '', window.location.pathname);
            
            showToast('Import URL detected! Enter password to import.');
        }
    }

    // Load persist messages setting
    function loadSyncSettings() {
        const persistEnabled = localStorage.getItem('persist_messages') !== 'false';
        const checkbox = document.getElementById('persistMessages');
        if (checkbox) checkbox.checked = persistEnabled;
        
        updateChatHistoryStats();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BUILT-IN TOOLS WITH TOGGLE FUNCTIONALITY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BUILTIN_TOOLS_INFO = [
        // Core tools
        { name: 'render_ui', desc: 'Render dynamic HTML', category: 'core' },
        { name: 'javascript_eval', desc: 'Execute JavaScript', category: 'core' },
        { name: 'storage_get', desc: 'Read localStorage', category: 'core' },
        { name: 'storage_set', desc: 'Write localStorage', category: 'core' },
        { name: 'fetch_url', desc: 'HTTP requests', category: 'core' },
        { name: 'update_self', desc: 'Self-modify config', category: 'core' },
        { name: 'notify', desc: 'Send push notifications üîî', category: 'core' },
        // Self-modification tools
        { name: 'create_tool', desc: 'Create new tools at runtime', category: 'self-mod' },
        { name: 'list_tools', desc: 'List all available tools', category: 'self-mod' },
        { name: 'delete_tool', desc: 'Remove custom tools', category: 'self-mod' },
        // Context & Communication tools
        { name: 'get_user_context', desc: 'Get user activity, location, etc.', category: 'context' },
        { name: 'set_context', desc: 'Set custom context for injection', category: 'context' },
        { name: 'enable_context_tracking', desc: 'Toggle activity/location/bluetooth', category: 'context' },
        { name: 'scan_bluetooth', desc: 'Scan for nearby devices/agents üì°', category: 'context' },
        { name: 'send_to_agent', desc: 'Message nearby AGI agents', category: 'context' },
        // Map tools
        { name: 'add_map_marker', desc: 'Add marker with emoji/label/color', category: 'map' },
        { name: 'remove_map_marker', desc: 'Remove marker by ID', category: 'map' },
        { name: 'clear_map_markers', desc: 'Clear all markers', category: 'map' },
        { name: 'list_map_markers', desc: 'List all marker IDs', category: 'map' },
        { name: 'pan_map', desc: 'Pan/zoom to location (instant)', category: 'map' },
        { name: 'get_map_location', desc: 'Get current user location', category: 'map' },
        { name: 'fly_to_marker', desc: 'Smooth fly animation to marker üé¨', category: 'map' },
        { name: 'fly_to_location', desc: 'Smooth fly animation to coords', category: 'map' },
        { name: 'tour_markers', desc: 'Animated tour through markers', category: 'map' },
        { name: 'get_marker_position', desc: 'Get marker coordinates', category: 'map' },
        { name: 'get_all_markers', desc: 'Get all markers with positions', category: 'map' },
        // Google API tools
        { name: 'google_auth', desc: 'Authenticate with Google OAuth 2.0', category: 'google' },
        { name: 'use_google', desc: 'Access 200+ Google APIs', category: 'google' },
        { name: 'gmail_send', desc: 'Send emails via Gmail', category: 'google' }
    ];

    const DISABLED_TOOLS_KEY = 'agi_disabled_tools';

    function getDisabledTools() {
        try {
            return JSON.parse(localStorage.getItem(DISABLED_TOOLS_KEY) || '[]');
        } catch {
            return [];
        }
    }

    function setDisabledTools(tools) {
        localStorage.setItem(DISABLED_TOOLS_KEY, JSON.stringify(tools));
    }

    function toggleToolDisabled(toolName) {
        const disabled = getDisabledTools();
        const index = disabled.indexOf(toolName);
        if (index >= 0) {
            disabled.splice(index, 1);
        } else {
            disabled.push(toolName);
        }
        setDisabledTools(disabled);
        window._agentNeedsReinit = true;
        renderBuiltinTools();
        showToast(index >= 0 ? `${toolName} enabled` : `${toolName} disabled`);
    }

    function renderBuiltinTools() {
        const container = document.getElementById('builtinToolsList');
        if (!container) return;
        
        const disabled = getDisabledTools();
        
        // Group tools by category
        const categories = {
            'core': { label: 'üîß Core Tools', tools: [] },
            'self-mod': { label: 'üß† Self-Modification', tools: [] },
            'context': { label: 'üì° Context & Communication', tools: [] },
            'map': { label: 'üó∫Ô∏è Map Tools', tools: [] },
            'google': { label: 'üîê Google API', tools: [] }
        };
        
        BUILTIN_TOOLS_INFO.forEach(tool => {
            const cat = tool.category || 'core';
            if (categories[cat]) {
                categories[cat].tools.push(tool);
            }
        });
        
        let html = '';
        for (const [catKey, cat] of Object.entries(categories)) {
            if (cat.tools.length === 0) continue;
            
            html += `<div style="margin-bottom:16px;">
                <div style="font-size:11px;font-weight:600;color:var(--text-tertiary);margin-bottom:8px;text-transform:uppercase;letter-spacing:0.05em;">${cat.label}</div>`;
            
            html += cat.tools.map(tool => {
                const isDisabled = disabled.includes(tool.name);
                return `<div class="tool-toggle-item" data-tool="${tool.name}" style="cursor:pointer;padding:4px 8px;border-radius:6px;margin-bottom:4px;transition:all 0.2s;${isDisabled ? 'opacity:0.4;' : ''}" 
                    onmouseover="this.style.background='rgba(255,255,255,0.05)'" 
                    onmouseout="this.style.background='transparent'">
                    <code style="${isDisabled ? 'text-decoration:line-through;' : ''}">${tool.name}</code> ‚Äî ${tool.desc}
                    <span style="float:right;color:${isDisabled ? 'rgba(255,100,100,0.6)' : 'rgba(100,255,100,0.6)'};">${isDisabled ? '‚úï' : '‚úì'}</span>
                </div>`;
            }).join('');
            
            html += '</div>';
        }
        
        container.innerHTML = html;
        
        // Add click handlers
        container.querySelectorAll('.tool-toggle-item').forEach(item => {
            item.addEventListener('click', () => {
                toggleToolDisabled(item.dataset.tool);
            });
        });
    }

    // Render tools on page load and when tools tab is shown
    renderBuiltinTools();

    init().catch(e => {
        console.error('Init error:', e);
        setStatus('error');
        addMessage('error', 'Failed to load: ' + e.message);
    }).then(() => {
        // Initialize map background after main init
        initMapBackground();
        // Load persisted messages
        loadMessagesFromStorage();
        // Load sync settings
        loadSyncSettings();
        // Check for import URL
        checkForImportUrl();
    });
    </script>
</body>
</html>
