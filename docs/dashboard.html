<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>agi.diy ‚Äî Mesh Dashboard</title>
<style>
:root {
  --bg: #0a0a0f; --bg-panel: #12121a; --bg-card: #1a1a26; --bg-hover: #22222e;
  --border: #2a2a3a; --text: #e0e0e8; --text-dim: #888898; --text-muted: #555568;
  --accent: #7c5cff; --green: #00ff88; --blue: #00aaff; --pink: #ff88ff;
  --orange: #ffaa00; --red: #ff6666; --cyan: #88ffff;
  --radius: 8px; --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --block-header: 32px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: var(--font); background: var(--bg); color: var(--text); height: 100vh; overflow: hidden; }

/* ‚îÄ‚îÄ Block Layout Engine ‚îÄ‚îÄ */
.layout { display: flex; height: 100vh; width: 100vw; gap: 1px; background: var(--border); }
.layout-col { display: flex; flex-direction: column; gap: 1px; min-width: 0; }
.block { background: var(--bg-panel); display: flex; flex-direction: column; min-height: 0; overflow: hidden; position: relative; }
.block.maximized { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 100; }
.block-header { height: var(--block-header); min-height: var(--block-header); display: flex; align-items: center; padding: 0 10px; gap: 6px; background: var(--bg-card); border-bottom: 1px solid var(--border); cursor: default; user-select: none; }
.block-icon { font-size: 12px; }
.block-title { font-size: 11px; font-weight: 600; color: var(--text-dim); flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.block-btn { background: none; border: none; color: var(--text-muted); font-size: 12px; cursor: pointer; padding: 2px 4px; border-radius: 3px; line-height: 1; }
.block-btn:hover { color: var(--text); background: var(--bg-hover); }
.block-body { flex: 1; overflow-y: auto; overflow-x: hidden; }
.block-body::-webkit-scrollbar { width: 4px; }
.block-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* ‚îÄ‚îÄ Add Block Bar ‚îÄ‚îÄ */
.add-bar { position: fixed; bottom: 0; left: 0; right: 0; height: 36px; background: var(--bg-card); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: center; gap: 8px; z-index: 50; }
.add-btn { background: var(--bg-hover); border: 1px solid var(--border); color: var(--text-dim); font-size: 11px; padding: 4px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
.add-btn:hover { color: var(--text); border-color: var(--accent); }
.wall-clock { font-size: 11px; color: var(--accent); font-variant-numeric: tabular-nums; position: fixed; bottom: 0; right: 12px; height: 36px; display: flex; align-items: center; z-index: 51; }

/* ‚îÄ‚îÄ Agent List ‚îÄ‚îÄ */
.agent-list { display: flex; flex-direction: column; gap: 2px; padding: 6px; }
.agent-card { display: flex; align-items: center; gap: 8px; padding: 7px 8px; border-radius: 6px; cursor: pointer; transition: background .12s; }
.agent-card:hover { background: var(--bg-hover); }
.agent-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.agent-dot.pulse { animation: pulse 2s infinite; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: .4; } }
.agent-info { flex: 1; min-width: 0; }
.agent-name { font-size: 12px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.agent-model { font-size: 10px; color: var(--text-muted); }
.agent-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; background: var(--bg); }

/* ‚îÄ‚îÄ Task Tree ‚îÄ‚îÄ */
.task-tree { display: flex; flex-direction: column; gap: 1px; padding: 6px; }
.task-item { display: flex; align-items: flex-start; gap: 6px; padding: 5px 8px; border-radius: 5px; cursor: pointer; transition: background .12s; border-left: 3px solid transparent; }
.task-item:hover { background: var(--bg-hover); }
.task-item.d1 { padding-left: 22px; } .task-item.d2 { padding-left: 38px; }
.task-status { font-size: 11px; flex-shrink: 0; margin-top: 1px; }
.task-info { flex: 1; min-width: 0; }
.task-title { font-size: 11px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.task-meta { font-size: 9px; color: var(--text-muted); display: flex; gap: 6px; margin-top: 1px; }
.task-item[data-status="complete"] .task-title { color: var(--text-muted); text-decoration: line-through; }

/* ‚îÄ‚îÄ Chat ‚îÄ‚îÄ */
.chat-wrap { display: flex; flex-direction: column; height: 100%; }
.messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
.messages::-webkit-scrollbar { width: 4px; }
.messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.msg { max-width: 85%; padding: 8px 12px; border-radius: 10px; font-size: 12px; line-height: 1.5; }
.msg.user { align-self: flex-end; background: var(--accent); color: #fff; border-bottom-right-radius: 3px; }
.msg.assistant { align-self: flex-start; background: var(--bg-card); border-bottom-left-radius: 3px; }
.msg .msg-agent { font-size: 10px; font-weight: 600; margin-bottom: 3px; }
.msg .msg-time { font-size: 9px; color: var(--text-muted); margin-top: 3px; text-align: right; }
.input-area { padding: 8px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px; }
.input-area textarea { flex: 1; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text); padding: 8px 10px; font-family: var(--font); font-size: 12px; resize: none; outline: none; min-height: 36px; max-height: 100px; }
.input-area textarea:focus { border-color: var(--accent); }
.send-btn { background: var(--accent); border: none; color: #fff; border-radius: var(--radius); padding: 0 14px; cursor: pointer; font-size: 12px; font-weight: 500; }
.send-btn:hover { opacity: .85; }

/* ‚îÄ‚îÄ Ring Buffer ‚îÄ‚îÄ */
.ring-entries { display: flex; flex-direction: column; gap: 4px; padding: 6px; }
.ring-entry { padding: 6px 8px; background: var(--bg-card); border-radius: 5px; border-left: 3px solid var(--border); }
.ring-entry .re-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
.ring-entry .re-agent { font-size: 10px; font-weight: 600; }
.ring-entry .re-time { font-size: 9px; color: var(--text-muted); }
.ring-entry .re-text { font-size: 10px; color: var(--text-dim); line-height: 1.4; }

/* ‚îÄ‚îÄ Task Detail ‚îÄ‚îÄ */
.task-detail-view { padding: 12px; }
.td-back { background: none; border: none; color: var(--text-dim); cursor: pointer; font-size: 16px; padding: 2px 6px; }
.td-back:hover { color: var(--text); }
.td-header { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
.td-title { font-size: 14px; font-weight: 600; }
.td-status { font-size: 10px; padding: 2px 8px; border-radius: 4px; }
.worklog { display: flex; flex-direction: column; gap: 6px; }
.wl-entry { padding: 8px 10px; background: var(--bg-card); border-radius: 6px; border-left: 3px solid var(--border); }
.wl-entry .wl-head { display: flex; justify-content: space-between; font-size: 9px; color: var(--text-muted); margin-bottom: 3px; }
.wl-entry .wl-msg { font-size: 11px; line-height: 1.5; }

/* ‚îÄ‚îÄ Mobile ‚îÄ‚îÄ */
@media (max-width: 768px) {
  .layout { flex-direction: column; }
  .add-bar { gap: 4px; flex-wrap: wrap; height: auto; padding: 6px; }
  .add-btn { font-size: 10px; padding: 3px 8px; }
}
@media (max-width: 480px) {
  .block-header { padding: 0 6px; }
  .block-title { font-size: 10px; }
}

/* ‚îÄ‚îÄ Animations ‚îÄ‚îÄ */
@keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideIn { from { opacity: 0; transform: translateX(-8px); } to { opacity: 1; transform: translateX(0); } }
@keyframes completePop { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
.ring-entry { animation: fadeIn .2s ease-out; }
.task-item { animation: slideIn .15s ease-out; }
.task-item[data-status="complete"] { animation: completePop .3s ease-out; }
.agent-card { animation: fadeIn .2s ease-out; }
.msg { animation: fadeIn .2s ease-out; }

/* ‚îÄ‚îÄ Working Indicator ‚îÄ‚îÄ */
.typing-dots { display: inline-flex; gap: 3px; padding: 4px 0; }
.typing-dots span { width: 5px; height: 5px; border-radius: 50%; background: var(--text-muted); animation: typingBounce .6s infinite; }
.typing-dots span:nth-child(2) { animation-delay: .15s; }
.typing-dots span:nth-child(3) { animation-delay: .3s; }
@keyframes typingBounce { 0%,100% { opacity: .3; transform: translateY(0); } 50% { opacity: 1; transform: translateY(-3px); } }

/* ‚îÄ‚îÄ Task Elapsed Time ‚îÄ‚îÄ */
.task-elapsed { font-size: 9px; color: var(--text-muted); font-variant-numeric: tabular-nums; }
</style>
</head>
<body>
<!-- Layout is built by JS -->
<div id="root"></div>
<div class="add-bar">
  <button class="add-btn" onclick="addBlock('chat')">+ Chat</button>
  <button class="add-btn" onclick="addBlock('agents')">+ Agents</button>
  <button class="add-btn" onclick="addBlock('tasks')">+ Tasks</button>
  <button class="add-btn" onclick="addBlock('ring')">+ Ring</button>
  <button class="add-btn" onclick="addBlock('task-detail')">+ Task Detail</button>
  <button class="add-btn" onclick="addBlock('mesh')">+ Mesh</button>
</div>
<div class="wall-clock" id="wallClock"></div>

<script src="agent-mesh.js"></script>
<script src="agentcore-relay.js"></script>
<script>
if (typeof Symbol.dispose === 'undefined') Symbol.dispose = Symbol('Symbol.dispose');
if (typeof Symbol.asyncDispose === 'undefined') Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
</script>
<script type="module">
import { Agent, tool, z, AnthropicModel, OpenAIModel, BedrockModel, McpClient, StreamableHTTPClientTransport } from './strands.js';
import { WebLLMBrowserModel } from './webllm.js';
import './erc8004-discovery.js';

// ‚ïê‚ïê‚ïê TASK TOOLS ‚ïê‚ïê‚ïê
let taskIdCounter = 100;

const createTaskTool = tool({
  name: 'create_task',
  description: 'Create a new task. Use parentId to create sub-tasks for hierarchical decomposition.',
  inputSchema: z.object({
    title: z.string().describe('Task title'),
    parentId: z.string().optional().describe('Parent task ID for sub-tasks'),
    agentId: z.string().optional().describe('Agent to assign'),
    source: z.string().optional().describe('Origin: manual, jira, slack, email'),
  }),
  callback: (input) => {
    const id = `t${taskIdCounter++}`;
    const task = { id, title: input.title, status: 'pending', agentId: input.agentId || null, parentId: input.parentId || null, children: [], worklog: [], source: input.source || 'manual' };
    state.tasks.set(id, task);
    if (input.parentId) { const p = state.tasks.get(input.parentId); if (p) p.children.push(id); }
    notify('tasks'); saveTasks();
    return JSON.stringify({ id, title: task.title, status: task.status });
  }
});

const updateTaskTool = tool({
  name: 'update_task',
  description: 'Update task status or add a worklog entry.',
  inputSchema: z.object({
    taskId: z.string().describe('Task ID'),
    status: z.enum(['pending','in-progress','waiting','complete','failed']).optional(),
    worklog: z.string().optional().describe('Worklog message to append'),
    agentId: z.string().optional().describe('Reassign to agent'),
  }),
  callback: (input) => {
    const t = state.tasks.get(input.taskId);
    if (!t) return JSON.stringify({ error: 'Task not found' });
    if (input.status) t.status = input.status;
    if (input.agentId) t.agentId = input.agentId;
    if (input.worklog) t.worklog.push({ ts: Date.now(), agentId: input.agentId || t.agentId || 'system', msg: input.worklog });
    notify('tasks'); saveTasks();
    return JSON.stringify({ id: t.id, status: t.status, agentId: t.agentId });
  }
});

const listTasksTool = tool({
  name: 'list_tasks',
  description: 'List tasks, optionally filtered by status or agent.',
  inputSchema: z.object({
    status: z.string().optional(),
    agentId: z.string().optional(),
  }),
  callback: (input) => {
    let tasks = [...state.tasks.values()];
    if (input.status) tasks = tasks.filter(t => t.status === input.status);
    if (input.agentId) tasks = tasks.filter(t => t.agentId === input.agentId);
    return JSON.stringify(tasks.map(t => ({ id: t.id, title: t.title, status: t.status, agentId: t.agentId, parentId: t.parentId })));
  }
});

const claimTaskTool = tool({
  name: 'claim_task',
  description: 'Claim an unassigned task for an agent and set it to in-progress.',
  inputSchema: z.object({
    taskId: z.string(),
    agentId: z.string(),
  }),
  callback: (input) => {
    const t = state.tasks.get(input.taskId);
    if (!t) return JSON.stringify({ error: 'Task not found' });
    t.agentId = input.agentId; t.status = 'in-progress';
    t.worklog.push({ ts: Date.now(), agentId: input.agentId, msg: `Claimed by ${input.agentId}` });
    notify('tasks'); saveTasks();
    return JSON.stringify({ id: t.id, status: t.status, agentId: t.agentId });
  }
});

const TASK_TOOLS = [createTaskTool, updateTaskTool, listTasksTool, claimTaskTool];

// ‚ïê‚ïê‚ïê STORAGE TOOLS (for agents that need localStorage access) ‚ïê‚ïê‚ïê
const storageGetTool = tool({
  name: 'storage_get',
  description: 'Read a value from localStorage by key.',
  inputSchema: z.object({ key: z.string().describe('localStorage key') }),
  callback: (input) => JSON.stringify({ key: input.key, value: localStorage.getItem(input.key) })
});
const storageSetTool = tool({
  name: 'storage_set',
  description: 'Write a value to localStorage by key.',
  inputSchema: z.object({ key: z.string().describe('localStorage key'), value: z.string().describe('Value to store') }),
  callback: (input) => { localStorage.setItem(input.key, input.value); return JSON.stringify({ key: input.key, stored: true }); }
});
const EXTRA_TOOLS = { storage_get: storageGetTool, storage_set: storageSetTool };

// ‚ïê‚ïê‚ïê ORCHESTRATION ‚ïê‚ïê‚ïê
const listAgentsTool = tool({
  name: 'list_agents',
  description: 'List all available agents with their roles and status.',
  inputSchema: z.object({}),
  callback: () => JSON.stringify([...state.agents.values()].map(a => ({ id: a.id, model: a.model, role: a.role, status: a.status })))
});

const delegateTaskTool = tool({
  name: 'delegate_task',
  description: 'Delegate a task to an agent. The agent will work on it asynchronously and update the task status/worklog.',
  inputSchema: z.object({
    taskId: z.string(),
    agentId: z.string(),
    instructions: z.string().describe('Detailed instructions for the agent'),
  }),
  callback: async (input) => {
    const task = state.tasks.get(input.taskId);
    if (!task) return JSON.stringify({ error: 'Task not found' });
    const agentData = state.agents.get(input.agentId);
    if (!agentData) return JSON.stringify({ error: 'Agent not found' });

    // Claim the task
    task.agentId = input.agentId; task.status = 'in-progress';
    task.worklog.push({ ts: Date.now(), agentId: input.agentId, msg: `Delegated: ${input.instructions.slice(0, 100)}` });
    agentData.status = 'processing';
    notify('tasks'); notifyAgentStatus(input.agentId); saveTasks();

    // Run agent asynchronously (don't await ‚Äî fire and forget for parallelism)
    runDelegatedAgent(input.agentId, input.taskId, input.instructions);
    return JSON.stringify({ taskId: input.taskId, agentId: input.agentId, status: 'delegated' });
  }
});

async function runDelegatedAgent(agentId, taskId, instructions) {
  const task = state.tasks.get(taskId);
  const agentData = state.agents.get(agentId);
  if (!agentData || !task) return;

  try {
    const model = createModel(agentData.provider || 'bedrock', { modelId: agentData.modelId, maxTokens: 4096 });
    const agentTools = [updateTaskTool, createTaskTool];

    // Add extra named tools from agent config
    if (agentData.tools) agentData.tools.forEach(n => { if (EXTRA_TOOLS[n]) agentTools.push(EXTRA_TOOLS[n]); });

    // Connect MCP servers from agent config
    if (agentData.mcp) {
      for (const srv of agentData.mcp) {
        const token = srv.tokenKey?.split('.').reduce((o, k) => o?.[k], state.credentials);
        const opts = token ? { requestInit: { headers: { 'Authorization': `Bearer ${token}` } } } : {};
        const client = new McpClient({ transport: new StreamableHTTPClientTransport(srv.url, opts) });
        agentTools.push(client);
      }
    }

    const agent = new Agent({
      model,
      tools: agentTools,
      systemPrompt: `You are agent "${agentId}". You are working on task "${task.title}" (ID: ${taskId}). Use update_task to report progress (add worklog entries) and mark complete when done. If the task needs sub-tasks, use create_task with parentId="${taskId}". Be thorough but concise.`,
      printer: false,
    });

    let result = '';
    for await (const event of agent.stream(instructions)) {
      if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
        result += event.delta.text;
      }
    }

    // Mark complete if agent didn't already
    if (task.status === 'in-progress') {
      task.status = 'complete';
      task.worklog.push({ ts: Date.now(), agentId, msg: result.slice(0, 300) || 'Completed' });
    }

    // Ring buffer
    state.ringBuffer.push({ agentId, content: `[${task.title}] ${result.slice(0, 200)}`, ts: Date.now() });
    notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
    if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext(agentId, 'browser', `[${task.title}] ${result.slice(0, 500)}`);
  } catch (e) {
    task.status = 'failed';
    task.worklog.push({ ts: Date.now(), agentId, msg: `Error: ${e.message}` });
  }

  if (agentData) { agentData.status = 'ready'; notifyAgentStatus(agentId); }
  notify('tasks'); saveTasks();
}

const ORCHESTRATOR_TOOLS = [...TASK_TOOLS, listAgentsTool, delegateTaskTool];

function buildOrchestratorPrompt() {
  return `You are an orchestrator agent in a multi-agent mesh dashboard. Your job:
1. When given a goal, decompose it into tasks using create_task (use parentId for sub-tasks)
2. Delegate tasks to available agents with delegate_task ‚Äî they run in parallel automatically
3. Use list_agents to check available agents and their status
4. Maximize parallelism: delegate multiple tasks at once to minimize wall-clock time
5. Monitor progress with list_tasks and update_task

Be concise. Act immediately ‚Äî create tasks and delegate them, don't just describe what you'd do.`;
}

function seedAgentList(agent) {
  const agents = [...state.agents.values()].map(a => ({ id: a.id, model: a.model, role: a.role, status: a.status }));
  agent.messages.push(
    { role: 'user', content: [{ type: 'textBlock', text: 'list_agents' }] },
    { role: 'assistant', content: [{ type: 'toolUse', toolUseId: 'seed-list', name: 'list_agents', input: {} }] },
    { role: 'user', content: [{ type: 'toolResult', toolUseId: 'seed-list', content: [{ type: 'text', text: JSON.stringify(agents) }] }] }
  );
}

function saveTasks() { try { localStorage.setItem('dashboard_tasks', JSON.stringify([...state.tasks.values()])); } catch(e) {} }
function loadTasks() { try { const d = JSON.parse(localStorage.getItem('dashboard_tasks')); if (d?.length) { state.tasks.clear(); d.forEach(t => state.tasks.set(t.id, t)); return true; } } catch(e) {} return false; }
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SECTION INDEX
// STATE ............. Constants, mock data, layout config
// BLOCKS ............ Block registry, renderers, layout engine
// RENDERERS ......... Per-block-type content renderers
// TASK DETAIL ....... Click-to-zoom task detail
// LAYOUT ............ Build/rebuild layout from config
// INIT .............. Startup
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê
const COLORS = ['#00ff88','#00aaff','#ff88ff','#ffaa00','#ff6666','#88ffff'];
const STATUS_ICON = { pending:'‚¨ú', 'in-progress':'üîµ', waiting:'‚è≥', complete:'üü¢', failed:'üî¥' };
const STATUS_LABEL = { pending:'Pending', 'in-progress':'In Progress', waiting:'Waiting', complete:'Complete', failed:'Failed' };
const BLOCK_META = {
  agents:       { icon:'üë•', title:'Agents' },
  tasks:        { icon:'üìã', title:'Tasks' },
  chat:         { icon:'üí¨', title:'Chat' },
  ring:         { icon:'üîµ', title:'Ring Buffer' },
  'task-detail':{ icon:'üîç', title:'Task Detail' },
  preview:      { icon:'üñºÔ∏è', title:'Preview' },
  mesh:         { icon:'üåê', title:'Mesh' },
};

const state = {
  agents: new Map(),
  tasks: new Map(),
  ringBuffer: [],
  wallClockStart: null,
  chatAgent: null,
  chatMessages: [],
  credentials: {},
  colorIndex: 0,
  layout: [
    { id:'col-left', type:'col', flex:1, children:[
      { id:'b-agents', type:'agents', flex:1 },
      { id:'b-tasks', type:'tasks', flex:2 },
    ]},
    { id:'b-chat', type:'chat', flex:2 },
    { id:'col-right', type:'col', flex:1, children:[
      { id:'b-ring', type:'ring', flex:2 },
      { id:'b-mesh', type:'mesh', flex:1 },
    ]},
  ],
  blockCounter: 10,
  maximizedBlock: null,
};

const DEFAULT_MAX_TOKENS = 60000;

// ‚îÄ‚îÄ Credentials & Model Factory ‚îÄ‚îÄ
function loadCredentials() {
  if (window.AgentMesh?.getCredentials) {
    state.credentials = window.AgentMesh.getCredentials();
  } else {
    try { state.credentials = JSON.parse(localStorage.getItem('agi_shared_credentials') || '{}'); } catch(e) {}
  }
}

function createModel(provider, cfg = {}) {
  const creds = state.credentials[provider] || {};
  if (provider === 'anthropic') return new AnthropicModel({ apiKey: creds.apiKey, modelId: cfg.modelId || creds.model || 'claude-sonnet-4-20250514', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'openai') return new OpenAIModel({ apiKey: creds.apiKey, modelId: cfg.modelId || creds.model || 'gpt-4o', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'bedrock') return new BedrockModel({ apiKey: creds.apiKey, region: creds.region || 'us-east-1', modelId: cfg.modelId || creds.model || 'global.anthropic.claude-sonnet-4-20250514-v1:0', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'webllm') return new WebLLMBrowserModel({ modelId: cfg.modelId || 'Qwen2.5-3B-Instruct-q4f16_1-MLC', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  throw new Error(`Unknown provider: ${provider}`);
}

function detectProvider() {
  const c = state.credentials;
  if (c.bedrock?.apiKey) return 'bedrock';
  if (c.anthropic?.apiKey) return 'anthropic';
  if (c.openai?.apiKey) return 'openai';
  return 'webllm';
}

// ‚îÄ‚îÄ One-time mesh sync at startup ‚îÄ‚îÄ
function initialMeshSync() {
  if (!window.AgentMesh) return;
  const meshAgents = window.AgentMesh.getAllMeshAgents?.() || [];
  for (const ma of meshAgents) {
    if (!state.agents.has(ma.agentId)) {
      state.agents.set(ma.agentId, {
        id: ma.agentId, model: ma.model || ma.agentType || '?',
        status: ma.status || 'idle',
        color: COLORS[state.colorIndex++ % COLORS.length],
        remote: true,
      });
    }
  }
  if (window.AgentMesh.getRingContext) {
    for (const entry of window.AgentMesh.getRingContext()) {
      const isDup = state.ringBuffer.some(e => e.agentId === entry.agentId && Math.abs(e.ts - entry.timestamp) < 5000);
      if (!isDup) state.ringBuffer.push({ agentId: entry.agentId, content: entry.text, ts: entry.timestamp, mesh: true });
    }
    if (state.ringBuffer.length > 100) state.ringBuffer.splice(0, state.ringBuffer.length - 100);
  }
}

// ‚îÄ‚îÄ Granular DOM Updates (no innerHTML replacement) ‚îÄ‚îÄ
function notify(type) {
  document.querySelectorAll('.block').forEach(bl => {
    const cfg = findBlockCfg(bl.id);
    if (!cfg || cfg.type !== type) return;
    const body = bl.querySelector('.block-body');
    RENDERERS[cfg.type]?.(body, cfg);
  });
}

// Targeted updaters for individual elements
function notifyAgentStatus(agentId) {
  document.querySelectorAll(`.agent-card[data-agent="${agentId}"]`).forEach(card => {
    const a = state.agents.get(agentId);
    if (!a) return;
    const dot = card.querySelector('.agent-dot');
    const badge = card.querySelector('.agent-badge');
    dot.className = `agent-dot ${a.status === 'processing' ? 'pulse' : ''}`;
    badge.style.color = a.status === 'processing' ? a.color : 'var(--text-muted)';
    badge.innerHTML = a.status === 'processing' ? '<span class="typing-dots"><span></span><span></span><span></span></span>' : a.status;
  });
}

function notifyNewAgent(agent) {
  document.querySelectorAll('.agent-list').forEach(list => {
    list.insertAdjacentHTML('beforeend', agentCardHTML(agent));
  });
  document.querySelectorAll('.block').forEach(bl => {
    const cfg = findBlockCfg(bl.id);
    if (cfg?.type === 'agents') bl.querySelector('.block-title').textContent = `Agents (${state.agents.size})`;
  });
}

function notifyRingEntry(entry) {
  const agent = state.agents.get(entry.agentId);
  const color = agent?.color || '#888';
  const time = new Date(entry.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const html = `<div class="ring-entry" style="border-left-color:${color}">
    <div class="re-header"><span class="re-agent" style="color:${color}">${entry.agentId}</span><span class="re-time">${time}</span></div>
    <div class="re-text">${(entry.content || '').slice(0,200)}</div>
  </div>`;
  document.querySelectorAll('.ring-entries').forEach(el => {
    el.insertAdjacentHTML('afterbegin', html);
    // Cap at 20 visible entries
    while (el.children.length > 20) el.lastElementChild.remove();
  });
}

function agentCardHTML(a) {
  return `<div class="agent-card" data-agent="${a.id}">
    <div class="agent-dot ${a.status==='processing'?'pulse':''}" style="background:${a.color}"></div>
    <div class="agent-info">
      <div class="agent-name">${a.id}</div>
      <div class="agent-model">${a.model}</div>
    </div>
    <div class="agent-badge" style="color:${a.status==='processing'?a.color:'var(--text-muted)'}">${a.status === 'processing' ? '<span class="typing-dots"><span></span><span></span><span></span></span>' : a.status}</div>
  </div>`;
}

function findBlockCfg(id) {
  for (const n of state.layout) {
    if (n.id === id) return n;
    if (n.children) { const c = n.children.find(x => x.id === id); if (c) return c; }
  }
  return null;
}

// ‚îÄ‚îÄ Chat Agent ‚îÄ‚îÄ
function ensureChatAgent() {
  if (state.chatAgent) return true;
  const chatCfg = state.agents.get('chat');
  if (!chatCfg) return false;
  try {
    const model = createModel(chatCfg.provider || 'bedrock', { modelId: chatCfg.modelId, maxTokens: 8192 });
    state.chatAgent = new Agent({ model, tools: ORCHESTRATOR_TOOLS, systemPrompt: buildOrchestratorPrompt(), printer: false });
    seedAgentList(state.chatAgent);
    if (window.AgentMesh?.registerAgent) window.AgentMesh.registerAgent('chat', 'browser', { model: chatCfg.modelId });
    return true;
  } catch (e) { console.error('Failed to create chat agent:', e); return false; }
}

function startWallClock() {
  if (!state.wallClockStart) state.wallClockStart = Date.now();
}

async function sendChatMessage(text, blockId) {
  if (!text.trim()) return;
  if (!ensureChatAgent()) { alert('Failed to create chat agent. Check Bedrock API key in Settings.'); return; }
  startWallClock();

  const msgEl = document.querySelector(`#msg-${blockId}`);
  if (!msgEl) return;
  const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  // Show user message
  msgEl.insertAdjacentHTML('beforeend', `<div class="msg user">${escapeHtml(text)}<div class="msg-time">${time}</div></div>`);
  msgEl.scrollTop = msgEl.scrollHeight;

  // Add to ring
  state.ringBuffer.push({ agentId: 'user', content: text.slice(0, 300), ts: Date.now() });
  notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
  if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext('chat', 'browser', `[User] ${text.slice(0, 300)}`);

  // Update agent status
  const agentData = state.agents.get('chat');
  if (agentData) { agentData.status = 'processing'; notifyAgentStatus('chat'); }

  // Stream response
  const streamDiv = document.createElement('div');
  streamDiv.className = 'msg assistant';
  streamDiv.innerHTML = `<div class="msg-agent" style="color:${agentData?.color || 'var(--green)'}">chat</div><span class="stream-text"></span>`;
  msgEl.appendChild(streamDiv);

  try {
    let currentText = '';
    // Fresh agent per message for parallelism
    const chatCfg = state.agents.get('chat');
    const model = createModel(chatCfg?.provider || 'bedrock', { modelId: chatCfg?.modelId, maxTokens: 8192 });
    const agent = new Agent({ model, tools: ORCHESTRATOR_TOOLS, systemPrompt: buildOrchestratorPrompt(), printer: false });
    seedAgentList(agent);
    // Inject history
    for (const m of state.chatMessages.slice(-20)) {
      agent.messages.push({ role: m.role, content: [{ type: 'textBlock', text: m.content }] });
    }

    for await (const event of agent.stream(text)) {
      if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
        currentText += event.delta.text;
        streamDiv.querySelector('.stream-text').textContent = currentText;
        msgEl.scrollTop = msgEl.scrollHeight;
      }
    }

    streamDiv.querySelector('.stream-text').textContent = currentText;
    streamDiv.insertAdjacentHTML('beforeend', `<div class="msg-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>`);
    state.chatMessages.push({ role: 'user', content: text }, { role: 'assistant', content: currentText });

    // Ring buffer
    state.ringBuffer.push({ agentId: 'chat', content: currentText.slice(0, 500), ts: Date.now() });
    notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
    if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext('chat', 'browser', currentText.slice(0, 500));
  } catch (e) {
    streamDiv.querySelector('.stream-text').textContent = `Error: ${e.message}`;
    streamDiv.style.color = 'var(--red)';
  }

  if (agentData) { agentData.status = 'ready'; notifyAgentStatus('chat'); }
}

function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function formatElapsed(start, end) {
  const s = Math.floor((end - start) / 1000);
  if (s < 60) return `${s}s`;
  return `${Math.floor(s/60)}m${s%60}s`;
}

// ‚îÄ‚îÄ Default Agents (loaded from agents.json) ‚îÄ‚îÄ
let DEFAULT_AGENTS = [];

async function loadDefaultAgents() {
  try {
    const resp = await fetch('./agents.json');
    DEFAULT_AGENTS = await resp.json();
  } catch (e) { console.warn('Failed to load agents.json, using empty defaults:', e); }
  DEFAULT_AGENTS.forEach((a, i) => {
    if (!state.agents.has(a.id)) {
      state.agents.set(a.id, { ...a, color: a.color || COLORS[i % COLORS.length], status: 'ready' });
    }
  });
  state.colorIndex = state.agents.size;
  // Register all agents with AgentMesh for cross-page discovery
  if (window.AgentMesh?.registerAgent) {
    state.agents.forEach((a, id) => window.AgentMesh.registerAgent(id, 'browser', { model: a.model }));
  }
}

// ‚ïê‚ïê‚ïê RENDERERS ‚ïê‚ïê‚ïê
function renderAgentsBlock(container) {
  container.innerHTML = '<div class="agent-list">' + [...state.agents.values()].map(a => `
    <div class="agent-card" data-agent="${a.id}">
      <div class="agent-dot ${a.status==='processing'?'pulse':''}" style="background:${a.color}"></div>
      <div class="agent-info">
        <div class="agent-name">${a.id}</div>
        <div class="agent-model">${a.model}</div>
      </div>
      <div class="agent-badge" style="color:${a.status==='processing'?a.color:'var(--text-muted)'}">${a.status === 'processing' ? '<span class="typing-dots"><span></span><span></span><span></span></span>' : a.status}</div>
    </div>
  `).join('') + '</div>';
}

function renderTasksBlock(container) {
  const roots = [...state.tasks.values()].filter(t => !t.parentId);
  const html = [];
  function walk(task, depth) {
    const agent = task.agentId ? state.agents.get(task.agentId) : null;
    const color = agent?.color || 'var(--text-muted)';
    html.push(`<div class="task-item d${depth}" data-task="${task.id}" data-status="${task.status}" style="border-left-color:${color}">
      <span class="task-status">${STATUS_ICON[task.status]}</span>
      <div class="task-info">
        <div class="task-title">${task.title}</div>
        <div class="task-meta">
          ${task.agentId ? `<span style="color:${color}">${task.agentId}</span>` : '<span>unassigned</span>'}
          ${task.worklog.length ? `<span>${task.worklog.length} logs</span>` : ''}
          ${task.worklog.length ? `<span class="task-elapsed" data-start="${task.worklog[0].ts}" data-end="${task.status === 'complete' ? task.worklog[task.worklog.length-1].ts : 0}">${formatElapsed(task.worklog[0].ts, task.status === 'complete' ? task.worklog[task.worklog.length-1].ts : Date.now())}</span>` : ''}
        </div>
      </div>
    </div>`);
    (task.children||[]).forEach(cid => { const c = state.tasks.get(cid); if(c) walk(c, depth+1); });
  }
  roots.forEach(t => walk(t, 0));
  container.innerHTML = '<div class="task-tree">' + html.join('') + '</div>';
  container.querySelectorAll('.task-item').forEach(el => {
    el.addEventListener('click', () => openTaskDetail(el.dataset.task));
  });
}

function renderChatBlock(container) {
  if (container.querySelector('.chat-wrap')) return;
  const blockId = container.closest('.block').id;
  container.innerHTML = `<div class="chat-wrap">
    <div class="messages" id="msg-${blockId}"></div>
    <div class="input-area">
      <textarea placeholder="Message the mesh‚Ä¶" rows="1"></textarea>
      <button class="send-btn">Send</button>
    </div>
  </div>`;
  const ta = container.querySelector('textarea');
  const send = () => { const t = ta.value; ta.value = ''; ta.style.height = 'auto'; sendChatMessage(t, blockId); };
  ta.addEventListener('input', () => { ta.style.height = 'auto'; ta.style.height = ta.scrollHeight + 'px'; });
  ta.addEventListener('keydown', e => { if(e.key==='Enter' && !e.shiftKey) { e.preventDefault(); send(); } });
  container.querySelector('.send-btn').addEventListener('click', send);
}

function renderRingBlock(container) {
  const sorted = [...state.ringBuffer].sort((a,b) => b.ts - a.ts);
  container.innerHTML = '<div class="ring-entries">' + sorted.map(e => {
    const agent = state.agents.get(e.agentId);
    const color = agent?.color || '#888';
    const time = new Date(e.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
    return `<div class="ring-entry" style="border-left-color:${color}">
      <div class="re-header"><span class="re-agent" style="color:${color}">${e.agentId}</span><span class="re-time">${time}</span></div>
      <div class="re-text">${e.content.slice(0,200)}</div>
    </div>`;
  }).join('') + '</div>';
}

function renderTaskDetailBlock(container, blockCfg) {
  const taskId = blockCfg?.taskId;
  if (!taskId) { container.innerHTML = '<div style="padding:20px;color:var(--text-muted);font-size:12px;text-align:center">Click a task to view details</div>'; return; }
  const task = state.tasks.get(taskId);
  if (!task) { container.innerHTML = '<div style="padding:20px;color:var(--text-muted);font-size:12px">Task not found</div>'; return; }
  const agent = task.agentId ? state.agents.get(task.agentId) : null;
  const color = agent?.color || 'var(--text-muted)';
  const sc = {'pending':'var(--text-muted)','in-progress':'var(--blue)','waiting':'var(--orange)','complete':'var(--green)','failed':'var(--red)'};
  container.innerHTML = `<div class="task-detail-view">
    <div class="td-header">
      <div><div class="td-title">${task.title}</div>
        <div style="display:flex;gap:8px;margin-top:4px;align-items:center">
          <span class="td-status" style="background:${sc[task.status]}22;color:${sc[task.status]}">${STATUS_ICON[task.status]} ${STATUS_LABEL[task.status]}</span>
          ${task.agentId ? `<span style="font-size:11px;color:${color}">‚¨§ ${task.agentId}</span>` : '<span style="font-size:11px;color:var(--text-muted)">unassigned</span>'}
        </div>
      </div>
    </div>
    <div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin:8px 0 4px">Worklog</div>
    <div class="worklog">${task.worklog.length ? task.worklog.map(w => {
      const wa = state.agents.get(w.agentId); const wc = wa?.color || '#888';
      return `<div class="wl-entry" style="border-left-color:${wc}">
        <div class="wl-head"><span style="color:${wc}">${w.agentId}</span><span>${new Date(w.ts).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span></div>
        <div class="wl-msg">${w.msg}</div>
      </div>`;
    }).join('') : '<div style="font-size:11px;color:var(--text-muted);padding:8px">No worklog entries</div>'}</div>
  </div>`;
}

function renderMeshBlock(container) {
  const M = window.AgentMesh;
  const connected = M?.relayConnected || false;
  const peers = M?.getRelayPeers() || [];
  const url = localStorage.getItem('mesh_relay_url') || '';
  const hasAC = !!window.AgentMesh?.getAgentCoreConfig?.();
  container.innerHTML = `<div style="padding:8px;font-size:12px">
    <div style="display:flex;gap:6px;margin-bottom:8px">
      <input id="meshRelayUrl" value="${url}" placeholder="ws://localhost:10000" style="flex:1;background:var(--bg-secondary);border:1px solid var(--border);color:var(--text);padding:4px 8px;border-radius:4px;font-size:11px">
      <button onclick="const u=document.getElementById('meshRelayUrl').value;if(u)window.AgentMesh?.connectRelay(u)" style="background:var(--green);color:#000;border:none;padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer">Connect</button>
      <button onclick="window.AgentMesh?.disconnectRelay()" style="background:var(--bg-tertiary);color:var(--text);border:1px solid var(--border);padding:4px 10px;border-radius:4px;font-size:11px;cursor:pointer">‚úï</button>
    </div>
    <div style="margin-bottom:8px">Status: ${connected ? '<span style="color:var(--green)">‚óè Connected</span>' + (hasAC ? ' <span style="color:var(--text-muted)">(auto-renew)</span>' : '') : '<span style="color:var(--text-muted)">‚óè Disconnected</span>'}</div>
    <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:4px">Remote Peers (${peers.length})</div>
    <div>${peers.length ? peers.map(p => `<div style="margin-bottom:4px"><span style="color:var(--green)">‚óè</span> ${p.hostname||'?'} <span style="color:var(--text-muted)">(${p.agents?.length||0} agents)</span></div>`).join('') : '<div style="color:var(--text-muted)">None</div>'}</div>
  </div>`;
}

const RENDERERS = { agents: renderAgentsBlock, tasks: renderTasksBlock, chat: renderChatBlock, ring: renderRingBlock, 'task-detail': renderTaskDetailBlock, mesh: renderMeshBlock };

// ‚ïê‚ïê‚ïê BLOCKS ‚ïê‚ïê‚ïê
function makeBlockEl(cfg) {
  const meta = BLOCK_META[cfg.type] || { icon:'üì¶', title:cfg.type };
  const div = document.createElement('div');
  div.className = 'block';
  div.id = cfg.id;
  div.style.flex = cfg.flex || 1;
  div.innerHTML = `<div class="block-header">
    <span class="block-icon">${meta.icon}</span>
    <span class="block-title">${meta.title}</span>
    <button class="block-btn maximize-btn" title="Maximize">‚§¢</button>
    <button class="block-btn close-btn" title="Close">‚úï</button>
  </div><div class="block-body"></div>`;
  div.querySelector('.maximize-btn').addEventListener('click', () => toggleMaximize(cfg.id));
  div.querySelector('.close-btn').addEventListener('click', () => removeBlock(cfg.id));
  const body = div.querySelector('.block-body');
  const renderer = RENDERERS[cfg.type];
  if (renderer) renderer(body, cfg);
  return div;
}

function buildLayout() {
  const root = document.getElementById('root');
  root.innerHTML = '';
  const container = document.createElement('div');
  container.className = 'layout';
  container.style.height = 'calc(100vh - 36px)';

  for (const node of state.layout) {
    if (node.type === 'col') {
      const col = document.createElement('div');
      col.className = 'layout-col';
      col.style.flex = node.flex || 1;
      (node.children || []).forEach(child => col.appendChild(makeBlockEl(child)));
      container.appendChild(col);
    } else {
      container.appendChild(makeBlockEl(node));
    }
  }
  root.appendChild(container);
}

// ‚ïê‚ïê‚ïê BLOCK ACTIONS ‚ïê‚ïê‚ïê
function toggleMaximize(blockId) {
  const el = document.getElementById(blockId);
  if (!el) return;
  if (state.maximizedBlock === blockId) {
    el.classList.remove('maximized');
    state.maximizedBlock = null;
  } else {
    if (state.maximizedBlock) document.getElementById(state.maximizedBlock)?.classList.remove('maximized');
    el.classList.add('maximized');
    state.maximizedBlock = blockId;
  }
}

function findAndRemove(layout, blockId) {
  for (let i = 0; i < layout.length; i++) {
    if (layout[i].id === blockId) { layout.splice(i, 1); return true; }
    if (layout[i].children && findAndRemove(layout[i].children, blockId)) {
      if (layout[i].children.length === 0) layout.splice(i, 1);
      return true;
    }
  }
  return false;
}

function removeBlock(blockId) {
  findAndRemove(state.layout, blockId);
  buildLayout();
}

window.addBlock = function(type) {
  const id = `b-${type}-${state.blockCounter++}`;
  state.layout.push({ id, type, flex: 1 });
  buildLayout();
};

function openTaskDetail(taskId) {
  // Find existing task-detail block or create one
  let found = null;
  function search(nodes) { for (const n of nodes) { if (n.type === 'task-detail') { found = n; return; } if (n.children) search(n.children); } }
  search(state.layout);
  if (found) {
    found.taskId = taskId;
  } else {
    const id = `b-td-${state.blockCounter++}`;
    state.layout.push({ id, type: 'task-detail', flex: 1, taskId });
  }
  buildLayout();
}

// ‚ïê‚ïê‚ïê WALL CLOCK ‚ïê‚ïê‚ïê
function updateWallClock() {
  if (!state.wallClockStart) return;
  const s = Math.floor((Date.now() - state.wallClockStart) / 1000);
  document.getElementById('wallClock').textContent = `‚è± ${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
}

// ‚ïê‚ïê‚ïê INIT ‚ïê‚ïê‚ïê
loadCredentials();
await loadDefaultAgents();
loadTasks();
initialMeshSync();
buildLayout();
setInterval(updateWallClock, 1000);
updateWallClock();

// Lightweight elapsed time updater (no DOM rebuild)
setInterval(() => {
  document.querySelectorAll('.task-elapsed[data-start]').forEach(el => {
    const start = parseInt(el.dataset.start);
    const end = parseInt(el.dataset.end) || Date.now();
    el.textContent = formatElapsed(start, end);
  });
}, 1000);

// Subscribe to mesh events ‚Äî targeted updates, no polling
if (window.AgentMesh) {
  window.AgentMesh.subscribe?.('ring-update', (payload) => {
    if (!payload) return;
    const isDup = state.ringBuffer.some(e => e.agentId === payload.agentId && Math.abs(e.ts - payload.timestamp) < 5000);
    if (!isDup) {
      const entry = { agentId: payload.agentId, content: payload.text, ts: payload.timestamp, mesh: true };
      state.ringBuffer.push(entry);
      notifyRingEntry(entry);
    }
  });
  window.AgentMesh.subscribe?.('ping', (payload, source) => {
    if (!source?.agents) return;
    const before = new Set(state.agents.keys());
    for (const ma of source.agents) {
      if (!state.agents.has(ma.agentId)) {
        const agent = { id: ma.agentId, model: ma.model || ma.agentType || '?', status: ma.status || 'idle', color: COLORS[state.colorIndex++ % COLORS.length], remote: true };
        state.agents.set(ma.agentId, agent);
        notifyNewAgent(agent);
        injectAgentRosterChange(`Agent "${ma.agentId}" joined the mesh.`);
      } else {
        const a = state.agents.get(ma.agentId);
        if (ma.status && ma.status !== a.status) { a.status = ma.status; notifyAgentStatus(ma.agentId); }
      }
    }
  });
  window.AgentMesh.subscribe?.('relay-status', () => { const b = document.querySelector('#b-mesh .block-body'); if (b) renderMeshBlock(b); });
  window.AgentMesh.subscribe?.('relay-peers', () => { const b = document.querySelector('#b-mesh .block-body'); if (b) renderMeshBlock(b); });
}

// Inject agent roster changes into the chat agent's conversation so it stays aware
function injectAgentRosterChange(msg) {
  state.ringBuffer.push({ agentId: 'system', content: msg, ts: Date.now() });
  notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
  // Push into chat history so the orchestrator sees it on next message
  state.chatMessages.push({ role: 'user', content: `[System] ${msg}` });
}
</script>
</body>
</html>
