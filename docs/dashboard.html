<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>agi.diy ‚Äî Mesh Dashboard</title>
<style>
#agent-mesh-nav { display: none !important; }
:root {
  --bg: #0a0a0f; --bg-panel: #12121a; --bg-card: #1a1a26; --bg-hover: #22222e;
  --border: #2a2a3a; --text: #e0e0e8; --text-dim: #888898; --text-muted: #555568;
  --accent: #7c5cff; --green: #00ff88; --blue: #00aaff; --pink: #ff88ff;
  --orange: #ffaa00; --red: #ff6666; --cyan: #88ffff;
  --radius: 8px; --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --block-header: 32px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: var(--font); background: var(--bg); color: var(--text); height: 100vh; overflow: hidden; }

/* ‚îÄ‚îÄ Block Layout Engine ‚îÄ‚îÄ */
.layout { display: flex; height: 100vh; width: 100vw; gap: 1px; background: var(--border); }
.layout-col { display: flex; flex-direction: column; gap: 1px; min-width: 0; }
.block { background: var(--bg-panel); display: flex; flex-direction: column; min-height: 0; overflow: hidden; position: relative; }
.block.maximized { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 100; }
.block-header { height: var(--block-header); min-height: var(--block-header); display: flex; align-items: center; padding: 0 10px; gap: 6px; background: var(--bg-card); border-bottom: 1px solid var(--border); cursor: default; user-select: none; }
.block-icon { font-size: 12px; }
.block-title { font-size: 11px; font-weight: 600; color: var(--text-dim); flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.block-btn { background: none; border: none; color: var(--text-muted); font-size: 12px; cursor: pointer; padding: 2px 4px; border-radius: 3px; line-height: 1; }
.block-btn:hover { color: var(--text); background: var(--bg-hover); }
.block-body { flex: 1; overflow-y: auto; overflow-x: hidden; }
.block-body::-webkit-scrollbar { width: 4px; }
.block-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* ‚îÄ‚îÄ Add Block Bar ‚îÄ‚îÄ */
.add-bar { position: fixed; bottom: 0; left: 0; right: 0; height: 36px; background: var(--bg-card); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: center; gap: 8px; z-index: 50; }
.add-btn { background: var(--bg-hover); border: 1px solid var(--border); color: var(--text-dim); font-size: 11px; padding: 4px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
.add-btn:hover { color: var(--text); border-color: var(--accent); }
.settings-btn { background: none; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; padding: 2px 8px; }
.settings-btn:hover { color: var(--accent); }
.wall-clock { font-size: 11px; color: var(--accent); font-variant-numeric: tabular-nums; position: fixed; bottom: 0; right: 12px; height: 36px; display: flex; align-items: center; z-index: 51; }

/* ‚îÄ‚îÄ Agent List ‚îÄ‚îÄ */
.agent-list { display: flex; flex-direction: column; gap: 2px; padding: 6px; }
.agent-card { display: flex; align-items: center; gap: 8px; padding: 7px 8px; border-radius: 6px; cursor: pointer; transition: background .12s; }
.agent-card:hover { background: var(--bg-hover); }
.agent-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.agent-dot.pulse { animation: pulse 2s infinite; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: .4; } }
.agent-info { flex: 1; min-width: 0; }
.agent-name { font-size: 12px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.agent-model { font-size: 10px; color: var(--text-muted); }
.agent-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; background: var(--bg); }

/* ‚îÄ‚îÄ Task Tree ‚îÄ‚îÄ */
.task-tree { display: flex; flex-direction: column; gap: 1px; padding: 6px; }
.task-item { display: flex; align-items: flex-start; gap: 6px; padding: 5px 8px; border-radius: 5px; cursor: pointer; transition: background .12s; border-left: 3px solid transparent; }
.task-item:hover { background: var(--bg-hover); }
.task-item.d1 { padding-left: 22px; } .task-item.d2 { padding-left: 38px; }
.task-status { font-size: 11px; flex-shrink: 0; margin-top: 1px; }
.task-info { flex: 1; min-width: 0; }
.task-title { font-size: 11px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.task-meta { font-size: 9px; color: var(--text-muted); display: flex; gap: 6px; margin-top: 1px; }
.task-item[data-status="complete"] .task-title { color: var(--text-muted); text-decoration: line-through; }
.task-item[data-status="in-progress"] { background: rgba(59,130,246,.08); border-left-color: #3b82f6 !important; }
.task-item[data-status="in-progress"] .task-status { animation: pulse 1.2s ease-in-out infinite; }
.task-item[data-status="pending"] { opacity: .55; }
.task-item[data-status="waiting"] { opacity: .7; }
.task-item[data-status="failed"] { background: rgba(239,68,68,.08); border-left-color: #ef4444 !important; }

/* ‚îÄ‚îÄ Chat ‚îÄ‚îÄ */
.chat-wrap { display: flex; flex-direction: column; height: 100%; }
.messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
.messages::-webkit-scrollbar { width: 4px; }
.messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.msg { max-width: 85%; padding: 8px 12px; border-radius: 10px; font-size: 12px; line-height: 1.5; }
.msg.user { align-self: flex-end; background: var(--accent); color: #fff; border-bottom-right-radius: 3px; }
.msg.assistant { align-self: flex-start; background: var(--bg-card); border-bottom-left-radius: 3px; }
.msg .msg-agent { font-size: 10px; font-weight: 600; margin-bottom: 3px; }
.msg .msg-time { font-size: 9px; color: var(--text-muted); margin-top: 3px; text-align: right; }
.msg.assistant .stream-text p { margin: 0 0 6px; } .msg.assistant .stream-text p:last-child { margin: 0; }
.msg.assistant .stream-text pre { background: rgba(0,0,0,.3); padding: 6px 8px; border-radius: 4px; overflow-x: auto; font-size: 11px; margin: 4px 0; }
.msg.assistant .stream-text code { background: rgba(0,0,0,.2); padding: 1px 4px; border-radius: 3px; font-size: 11px; }
.msg.assistant .stream-text pre code { background: none; padding: 0; }
.msg.assistant .stream-text ul, .msg.assistant .stream-text ol { margin: 4px 0; padding-left: 18px; }
.input-area { padding: 8px 12px; border-top: 1px solid var(--border); display: flex; gap: 6px; }
.input-area textarea { flex: 1; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); color: var(--text); padding: 8px 10px; font-family: var(--font); font-size: 12px; resize: none; outline: none; min-height: 36px; max-height: 100px; }
.input-area textarea:focus { border-color: var(--accent); }
.send-btn { background: var(--accent); border: none; color: #fff; border-radius: var(--radius); padding: 0 14px; cursor: pointer; font-size: 12px; font-weight: 500; }
.send-btn:hover { opacity: .85; }

/* ‚îÄ‚îÄ Ring Buffer ‚îÄ‚îÄ */
.ring-entries { display: flex; flex-direction: column; gap: 4px; padding: 6px; }
.ring-entry { padding: 6px 8px; background: var(--bg-card); border-radius: 5px; border-left: 3px solid var(--border); }
.ring-entry .re-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
.ring-entry .re-agent { font-size: 10px; font-weight: 600; }
.ring-entry .re-time { font-size: 9px; color: var(--text-muted); }
.ring-entry .re-text { font-size: 10px; color: var(--text-dim); line-height: 1.4; }

/* ‚îÄ‚îÄ Task Detail ‚îÄ‚îÄ */
.task-detail-view { padding: 12px; }
.td-back { background: none; border: none; color: var(--text-dim); cursor: pointer; font-size: 16px; padding: 2px 6px; }
.td-back:hover { color: var(--text); }
.td-header { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
.td-title { font-size: 14px; font-weight: 600; }
.td-status { font-size: 10px; padding: 2px 8px; border-radius: 4px; }
.worklog { display: flex; flex-direction: column; gap: 6px; }
.wl-entry { padding: 8px 10px; background: var(--bg-card); border-radius: 6px; border-left: 3px solid var(--border); }
.wl-entry .wl-head { display: flex; justify-content: space-between; font-size: 9px; color: var(--text-muted); margin-bottom: 3px; }
.wl-entry .wl-msg { font-size: 11px; line-height: 1.5; }

/* ‚îÄ‚îÄ Mobile ‚îÄ‚îÄ */
@media (max-width: 768px) {
  .layout { flex-direction: column; }
  .add-bar { gap: 4px; flex-wrap: wrap; height: auto; padding: 6px; }
  .add-btn { font-size: 10px; padding: 3px 8px; }
}
@media (max-width: 480px) {
  .block-header { padding: 0 6px; }
  .block-title { font-size: 10px; }
}

/* ‚îÄ‚îÄ Animations ‚îÄ‚îÄ */
@keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideIn { from { opacity: 0; transform: translateX(-8px); } to { opacity: 1; transform: translateX(0); } }
@keyframes completePop { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
.ring-entry { animation: fadeIn .2s ease-out; }
.task-item { animation: slideIn .15s ease-out; }
.task-item[data-status="complete"] { animation: completePop .3s ease-out; }
.agent-card { animation: fadeIn .2s ease-out; }
.msg { animation: fadeIn .2s ease-out; }

/* ‚îÄ‚îÄ Working Indicator ‚îÄ‚îÄ */
.typing-dots { display: inline-flex; gap: 3px; padding: 4px 0; }
.typing-dots span { width: 5px; height: 5px; border-radius: 50%; background: var(--text-muted); animation: typingBounce .6s infinite; }
.typing-dots span:nth-child(2) { animation-delay: .15s; }
.typing-dots span:nth-child(3) { animation-delay: .3s; }
@keyframes typingBounce { 0%,100% { opacity: .3; transform: translateY(0); } 50% { opacity: 1; transform: translateY(-3px); } }

/* ‚îÄ‚îÄ Task Elapsed Time ‚îÄ‚îÄ */
.task-elapsed { font-size: 9px; color: var(--text-muted); font-variant-numeric: tabular-nums; }

/* ‚îÄ‚îÄ Drag and Drop ‚îÄ‚îÄ */
.block.dragging { opacity: 0.5; }
.drop-zones { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 10; }
.drop-zone { position: absolute; background: var(--accent); opacity: 0; transition: opacity .15s; }
.drop-zone.active { opacity: 0.3; }
.drop-zone-top { top: 0; left: 0; right: 0; height: 50%; }
.drop-zone-bottom { bottom: 0; left: 0; right: 0; height: 50%; }
.drop-zone-left { top: 0; left: 0; bottom: 0; width: 50%; }
.drop-zone-right { top: 0; right: 0; bottom: 0; width: 50%; }
.drop-zone-center { top: 25%; left: 25%; right: 25%; bottom: 25%; }

/* ‚îÄ‚îÄ Resize Handles ‚îÄ‚îÄ */
.layout-row { display: flex; flex-direction: column; gap: 1px; min-height: 0; }
.resize-handle { background: var(--border); flex-shrink: 0; position: relative; }
.resize-handle-row { height: 4px; cursor: ns-resize; }
.resize-handle-col { width: 4px; cursor: ew-resize; }
.resize-handle:hover { background: var(--accent); }
</style>
</head>
<body>
<!-- Layout is built by JS -->
<div id="root"></div>
<div class="add-bar" id="statusBar">
  <div style="display:flex;align-items:center;gap:4px" id="meshNavSlot"></div>
  <div style="flex:1;display:flex;align-items:center;justify-content:center;gap:8px">
    <button class="add-btn" onclick="addBlock('chat')">+ Chat</button>
    <button class="add-btn" onclick="addBlock('agents')">+ Agents</button>
    <button class="add-btn" onclick="addBlock('agent-detail')">+ Agent Detail</button>
    <button class="add-btn" onclick="addBlock('tasks')">+ Tasks</button>
    <button class="add-btn" onclick="addBlock('task-flow')">+ Task Flow</button>
    <button class="add-btn" onclick="addBlock('ring')">+ Ring</button>
    <button class="add-btn" onclick="addBlock('task-detail')">+ Task Detail</button>
    <button class="add-btn" onclick="addBlock('agent-chat')">+ Agent Chat</button>
    <button class="add-btn" onclick="addBlock('mesh')">+ Mesh</button>
  </div>
  <div style="display:flex;align-items:center;gap:6px">
    <button class="add-btn" onclick="stopAllTasks()" style="background:var(--red);color:#fff" title="Stop all active tasks">‚èπ Stop All</button>
    <button class="add-btn" onclick="clearDoneTasks()" title="Clear completed tasks">üóëÔ∏è Clear Done</button>
    <button class="add-btn" onclick="resetLayout()" title="Reset layout to default">üîÑ Reset Layout</button>
    <button class="add-btn" onclick="showLayoutMenu()" title="Save/Load layouts">üíæ Layouts</button>
  </div>
  <button class="settings-btn" onclick="AgentMesh.settings?.open()" title="Settings">‚öô</button>
</div>
<div class="wall-clock" id="wallClock"></div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="agent-mesh.js?v=2"></script>
<script src="agent-mesh-settings.js?v=2"></script>
<script src="agentcore-relay.js?v=2"></script>
<script>
if (typeof Symbol.dispose === 'undefined') Symbol.dispose = Symbol('Symbol.dispose');
if (typeof Symbol.asyncDispose === 'undefined') Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
</script>
<script type="module">
import widgetRegistry from './widgets/index.js';
import { Agent, tool, z, AnthropicModel, OpenAIModel, BedrockModel, McpClient, StreamableHTTPClientTransport, SlidingWindowConversationManager, NullConversationManager, SummarizingConversationManager } from './strands.js';
import { WebLLMBrowserModel } from './webllm.js';
import { LayoutManager } from './layout-manager.js';
import './erc8004-discovery.js?v=2';

// ‚ïê‚ïê‚ïê CONVERSATION MANAGER FACTORY ‚ïê‚ïê‚ïê
function createConversationManager(config) {
  const cmConfig = config || { type: 'sliding', windowSize: 40 };
  
  if (cmConfig.type === 'null') {
    return new NullConversationManager();
  } else if (cmConfig.type === 'summarizing') {
    return new SummarizingConversationManager({
      summaryRatio: cmConfig.summaryRatio || 0.3,
      preserveRecentMessages: cmConfig.preserveRecentMessages || 10,
      summarizationSystemPrompt: cmConfig.summarizationSystemPrompt
    });
  } else {
    // Default: sliding window
    return new SlidingWindowConversationManager({ 
      windowSize: cmConfig.windowSize || 40 
    });
  }
}

// ‚ïê‚ïê‚ïê TASK TOOLS ‚ïê‚ïê‚ïê
let taskIdCounter = 100;

const createTaskTool = tool({
  name: 'create_task',
  description: 'Create a new task. Use parentId to create sub-tasks for hierarchical decomposition.',
  inputSchema: z.object({
    title: z.string().describe('Task title'),
    parentId: z.string().optional().describe('Parent task ID for sub-tasks'),
    agentId: z.string().optional().describe('Agent to assign'),
    source: z.string().optional().describe('Origin: manual, jira, slack, email'),
  }),
  callback: (input) => {
    const id = `t${taskIdCounter++}`;
    const task = { id, title: input.title, status: 'pending', agentId: input.agentId || null, parentId: input.parentId || null, children: [], worklog: [], source: input.source || 'manual' };
    state.tasks.set(id, task);
    if (input.parentId) { const p = state.tasks.get(input.parentId); if (p) p.children.push(id); }
    notify('tasks'); saveTasks();
    return JSON.stringify({ id, title: task.title, status: task.status });
  }
});

const updateTaskTool = tool({
  name: 'update_task',
  description: 'Update task status or add a worklog entry.',
  inputSchema: z.object({
    taskId: z.string().describe('Task ID'),
    status: z.enum(['pending','in-progress','waiting','complete','failed']).optional(),
    worklog: z.string().optional().describe('Worklog message to append'),
    agentId: z.string().optional().describe('Reassign to agent'),
  }),
  callback: (input) => {
    const t = state.tasks.get(input.taskId);
    if (!t) return JSON.stringify({ error: 'Task not found' });
    if (input.status) t.status = input.status;
    if (input.agentId) t.agentId = input.agentId;
    if (input.worklog) t.worklog.push({ ts: Date.now(), agentId: input.agentId || t.agentId || 'system', msg: input.worklog });
    notify('tasks'); saveTasks();
    return JSON.stringify({ id: t.id, status: t.status, agentId: t.agentId });
  }
});

const listTasksTool = tool({
  name: 'list_tasks',
  description: 'List tasks, optionally filtered by status or agent.',
  inputSchema: z.object({
    status: z.string().optional(),
    agentId: z.string().optional(),
  }),
  callback: (input) => {
    let tasks = [...state.tasks.values()];
    if (input.status) tasks = tasks.filter(t => t.status === input.status);
    if (input.agentId) tasks = tasks.filter(t => t.agentId === input.agentId);
    return JSON.stringify(tasks.map(t => ({ id: t.id, title: t.title, status: t.status, agentId: t.agentId, parentId: t.parentId })));
  }
});

const claimTaskTool = tool({
  name: 'claim_task',
  description: 'Claim an unassigned task for an agent and set it to in-progress.',
  inputSchema: z.object({
    taskId: z.string(),
    agentId: z.string(),
  }),
  callback: (input) => {
    const t = state.tasks.get(input.taskId);
    if (!t) return JSON.stringify({ error: 'Task not found' });
    t.agentId = input.agentId; t.status = 'in-progress';
    t.worklog.push({ ts: Date.now(), agentId: input.agentId, msg: `Claimed by ${input.agentId}` });
    notify('tasks'); saveTasks();
    return JSON.stringify({ id: t.id, status: t.status, agentId: t.agentId });
  }
});

const TASK_TOOLS = [createTaskTool, updateTaskTool, listTasksTool, claimTaskTool];

// ‚ïê‚ïê‚ïê STORAGE TOOLS (for agents that need localStorage access) ‚ïê‚ïê‚ïê
const storageGetTool = tool({
  name: 'storage_get',
  description: 'Read a value from localStorage by key.',
  inputSchema: z.object({ key: z.string().describe('localStorage key') }),
  callback: (input) => JSON.stringify({ key: input.key, value: localStorage.getItem(input.key) })
});
const storageSetTool = tool({
  name: 'storage_set',
  description: 'Write a value to localStorage by key.',
  inputSchema: z.object({ key: z.string().describe('localStorage key'), value: z.string().describe('Value to store') }),
  callback: (input) => { localStorage.setItem(input.key, input.value); return JSON.stringify({ key: input.key, stored: true }); }
});
const EXTRA_TOOLS = { storage_get: storageGetTool, storage_set: storageSetTool };

// ‚ïê‚ïê‚ïê ORCHESTRATION ‚ïê‚ïê‚ïê
const listAgentsTool = tool({
  name: 'list_agents',
  description: 'List all available agents with their roles and status.',
  inputSchema: z.object({}),
  callback: () => JSON.stringify([...state.agents.values()].map(a => ({ id: a.id, model: a.model, role: a.role, status: a.status })))
});

const delegateTaskTool = tool({
  name: 'delegate_task',
  description: 'Delegate a task to an agent. The agent will work on it asynchronously and update the task status/worklog.',
  inputSchema: z.object({
    taskId: z.string(),
    agentId: z.string(),
    instructions: z.string().describe('Detailed instructions for the agent'),
  }),
  callback: async (input) => {
    const task = state.tasks.get(input.taskId);
    if (!task) return JSON.stringify({ error: 'Task not found' });
    const agentData = state.agents.get(input.agentId);
    if (!agentData) return JSON.stringify({ error: 'Agent not found' });

    // Claim the task
    task.agentId = input.agentId; task.status = 'in-progress';
    task.worklog.push({ ts: Date.now(), agentId: input.agentId, msg: `Delegated: ${input.instructions.slice(0, 100)}` });
    agentData.status = 'processing';
    notify('tasks'); notifyAgentStatus(input.agentId); saveTasks();

    // Run agent asynchronously (don't await ‚Äî fire and forget for parallelism)
    runDelegatedAgent(input.agentId, input.taskId, input.instructions);
    return JSON.stringify({ taskId: input.taskId, agentId: input.agentId, status: 'delegated' });
  }
});

async function runDelegatedAgent(agentId, taskId, instructions) {
  const task = state.tasks.get(taskId);
  const agentData = state.agents.get(agentId);
  if (!agentData || !task) return;

  // Track instance
  agentData.instances = (agentData.instances || 0) + 1;
  agentData.workingOn = task.title;
  notifyAgentStatus(agentId);
  
  // Initialize trace
  task.trace = task.trace || [];

  try {
    const model = createModel(agentData.provider || detectProvider(), { modelId: agentData.modelId, maxTokens: 4096 });
    const agentTools = [updateTaskTool, createTaskTool];

    // Add extra named tools from agent config
    if (agentData.tools) agentData.tools.forEach(n => { if (EXTRA_TOOLS[n]) agentTools.push(EXTRA_TOOLS[n]); });

    // Connect MCP servers from agent config
    if (agentData.mcp) {
      for (const srv of agentData.mcp) {
        const token = srv.tokenKey?.split('.').reduce((o, k) => o?.[k], state.credentials);
        const opts = token ? { requestInit: { headers: { 'Authorization': `Bearer ${token}` } } } : {};
        const client = new McpClient({ transport: new StreamableHTTPClientTransport(srv.url, opts) });
        agentTools.push(client);
      }
    }

    const agent = new Agent({
      model,
      tools: agentTools,
      systemPrompt: `You are agent "${agentId}". You are working on task "${task.title}" (ID: ${taskId}). Use update_task to report progress (add worklog entries) and mark complete when done. If the task needs sub-tasks, use create_task with parentId="${taskId}". Be thorough but concise.`,
      printer: false,
      conversationManager: createConversationManager(agentData.conversationManager)
    });

    let result = '';
    for await (const event of agent.stream(instructions)) {
      if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
        result += event.delta.text;
        task.trace.push({ type: 'thinking', content: event.delta.text, ts: Date.now() });
      }
      if (event?.type === 'modelContentBlockStartEvent' && event.contentBlock?.type === 'toolUse') {
        task.trace.push({ type: 'tool', content: `${event.contentBlock.name}(${JSON.stringify(event.contentBlock.input).slice(0,100)})`, ts: Date.now() });
      }
    }

    // Mark complete if agent didn't already
    if (task.status === 'in-progress') {
      task.status = 'complete';
      task.worklog.push({ ts: Date.now(), agentId, msg: result.slice(0, 300) || 'Completed' });
    }

    // Ring buffer
    state.ringBuffer.push({ agentId, content: `[${task.title}] ${result.slice(0, 200)}`, ts: Date.now(), taskId });
    notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
    if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext(agentId, 'browser', `[${task.title}] ${result.slice(0, 500)}`);
  } catch (e) {
    task.status = 'failed';
    task.worklog.push({ ts: Date.now(), agentId, msg: `Error: ${e.message}` });
    task.trace.push({ type: 'error', content: e.message, ts: Date.now() });
  }

  if (agentData) { 
    agentData.instances = Math.max(0, (agentData.instances || 1) - 1);
    agentData.status = agentData.instances > 0 ? 'processing' : 'ready';
    agentData.workingOn = null;
    notifyAgentStatus(agentId);
  }
  notify('tasks'); saveTasks();
}

const ORCHESTRATOR_TOOLS = [...TASK_TOOLS, listAgentsTool, delegateTaskTool];

function buildOrchestratorPrompt() {
  return `You are an orchestrator agent in a multi-agent mesh dashboard. Your job:
1. When given a goal, decompose it into tasks using create_task (use parentId for sub-tasks)
2. Delegate tasks to available agents with delegate_task ‚Äî they run in parallel automatically
3. Use list_agents to check available agents and their status
4. Maximize parallelism: delegate multiple tasks at once to minimize wall-clock time
5. Monitor progress with list_tasks and update_task

Be concise. Act immediately ‚Äî create tasks and delegate them, don't just describe what you'd do.`;
}

function seedAgentList(agent) {
  const agents = [...state.agents.values()].map(a => ({ id: a.id, model: a.model, role: a.role, status: a.status }));
  agent.messages.push(
    { role: 'user', content: [{ type: 'textBlock', text: 'list_agents' }] },
    { role: 'assistant', content: [{ type: 'toolUse', toolUseId: 'seed-list', name: 'list_agents', input: {} }] },
    { role: 'user', content: [{ type: 'toolResult', toolUseId: 'seed-list', content: [{ type: 'text', text: JSON.stringify(agents) }] }] }
  );
}

function saveTasks() { try { localStorage.setItem('dashboard_tasks', JSON.stringify([...state.tasks.values()])); } catch(e) {} }
function loadTasks() { try { const d = JSON.parse(localStorage.getItem('dashboard_tasks')); if (d?.length) { state.tasks.clear(); d.forEach(t => state.tasks.set(t.id, t)); return true; } } catch(e) {} return false; }
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SECTION INDEX
// STATE ............. Constants, mock data, layout config
// BLOCKS ............ Block registry, renderers, layout engine
// RENDERERS ......... Per-block-type content renderers
// TASK DETAIL ....... Click-to-zoom task detail
// LAYOUT ............ Build/rebuild layout from config
// INIT .............. Startup
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê
const COLORS = ['#00ff88','#00aaff','#ff88ff','#ffaa00','#ff6666','#88ffff'];
const STATUS_ICON = { pending:'‚¨ú', 'in-progress':'üîµ', waiting:'‚è≥', complete:'üü¢', failed:'üî¥' };
const STATUS_LABEL = { pending:'Pending', 'in-progress':'In Progress', waiting:'Waiting', complete:'Complete', failed:'Failed' };

const DEFAULT_LAYOUT = [
  { id:'col-left', type:'col', flex:1, children:[
    { id:'b-agents', type:'agents', flex:1 },
    { id:'b-tasks', type:'tasks', flex:2 },
  ]},
  { id:'b-chat', type:'chat', flex:2 },
  { id:'col-right', type:'col', flex:1, children:[
    { id:'b-ring', type:'ring', flex:2 },
    { id:'b-mesh', type:'mesh', flex:1 },
  ]},
];

const state = {
  agents: new Map(),
  tasks: new Map(),
  ringBuffer: [],
  wallClockStart: null,
  chatAgent: null,
  chatMessages: [],
  credentials: {},
  colorIndex: 0,
  layout: JSON.parse(JSON.stringify(DEFAULT_LAYOUT)),
  blockCounter: 10,
  maximizedBlock: null,
};

window.dashboardState = state;
window.widgetRegistry = widgetRegistry;

const DEFAULT_MAX_TOKENS = 60000;

// ‚îÄ‚îÄ Layout Manager ‚îÄ‚îÄ
const layoutManager = new LayoutManager({
  rootEl: document.getElementById('root'),
  widgetRegistry,
  state,
  onLayoutChange: () => {}
});

window.resetLayout = () => layoutManager.resetLayout(DEFAULT_LAYOUT);

window.showLayoutMenu = () => {
  const presets = layoutManager.getLayoutPresets();
  const menu = `
    <div style="padding:16px">
      <h3>Layout Presets</h3>
      <div style="margin:12px 0">
        <input id="layout-name" placeholder="Layout name" style="padding:6px;width:200px">
        <button onclick="saveCurrentLayout()" style="margin-left:8px">üíæ Save Current</button>
      </div>
      <div style="margin-top:16px">
        ${presets.length ? presets.map(name => `
          <div style="display:flex;align-items:center;gap:8px;margin:8px 0">
            <button onclick="loadLayoutPreset('${name}')" style="flex:1;text-align:left">${name}</button>
            <button onclick="deleteLayoutPreset('${name}')" style="color:red">üóëÔ∏è</button>
          </div>
        `).join('') : '<p style="color:var(--text-muted)">No saved layouts</p>'}
      </div>
    </div>
  `;
  
  const modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10000';
  modal.innerHTML = `<div style="background:var(--bg);border-radius:8px;max-width:400px;width:90%">${menu}</div>`;
  modal.onclick = (e) => e.target === modal && modal.remove();
  document.body.appendChild(modal);
};

window.saveCurrentLayout = () => {
  const name = document.getElementById('layout-name').value.trim();
  if (!name) return alert('Enter a layout name');
  layoutManager.saveLayoutAs(name);
  document.querySelector('[onclick="showLayoutMenu()"]').click();
  showLayoutMenu();
};

window.loadLayoutPreset = (name) => {
  layoutManager.loadLayout(name);
  document.querySelector('div[style*="position:fixed"]')?.remove();
};

window.deleteLayoutPreset = (name) => {
  if (confirm(`Delete layout "${name}"?`)) {
    layoutManager.deleteLayoutPreset(name);
    showLayoutMenu();
  }
};


// ‚îÄ‚îÄ Credentials & Model Factory ‚îÄ‚îÄ
function loadCredentials() {
  if (window.AgentMesh?.getCredentials) {
    state.credentials = window.AgentMesh.getCredentials();
  } else {
    try { state.credentials = JSON.parse(localStorage.getItem('agi_shared_credentials') || '{}'); } catch(e) {}
  }
}

function createModel(provider, cfg = {}) {
  const creds = state.credentials[provider] || {};
  if (provider === 'anthropic') return new AnthropicModel({ apiKey: creds.apiKey, modelId: cfg.modelId || creds.model || 'claude-sonnet-4-20250514', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'openai') return new OpenAIModel({ apiKey: creds.apiKey, modelId: cfg.modelId || creds.model || 'gpt-4o', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'bedrock') return new BedrockModel({ apiKey: creds.apiKey, region: creds.region || 'us-east-1', modelId: cfg.modelId || creds.model || 'global.anthropic.claude-sonnet-4-20250514-v1:0', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  if (provider === 'webllm') return new WebLLMBrowserModel({ modelId: cfg.modelId || 'Qwen2.5-3B-Instruct-q4f16_1-MLC', maxTokens: cfg.maxTokens || DEFAULT_MAX_TOKENS });
  throw new Error(`Unknown provider: ${provider}`);
}

function detectProvider() {
  const c = state.credentials;
  if (c.bedrock?.apiKey) return 'bedrock';
  if (c.anthropic?.apiKey) return 'anthropic';
  if (c.openai?.apiKey) return 'openai';
  return 'webllm';
}

// ‚îÄ‚îÄ One-time mesh sync at startup ‚îÄ‚îÄ
function initialMeshSync() {
  if (!window.AgentMesh) return;
  const meshAgents = window.AgentMesh.getAllMeshAgents?.() || [];
  for (const ma of meshAgents) {
    if (!state.agents.has(ma.agentId)) {
      state.agents.set(ma.agentId, {
        id: ma.agentId, model: ma.model || ma.agentType || '?',
        status: ma.status || 'idle',
        color: COLORS[state.colorIndex++ % COLORS.length],
        remote: true,
      });
    }
  }
  if (window.AgentMesh.getRingContext) {
    for (const entry of window.AgentMesh.getRingContext()) {
      const isDup = state.ringBuffer.some(e => e.agentId === entry.agentId && Math.abs(e.ts - entry.timestamp) < 5000);
      if (!isDup) state.ringBuffer.push({ agentId: entry.agentId, content: entry.text, ts: entry.timestamp, mesh: true });
    }
    if (state.ringBuffer.length > 100) state.ringBuffer.splice(0, state.ringBuffer.length - 100);
  }
}

// ‚îÄ‚îÄ Granular DOM Updates (no innerHTML replacement) ‚îÄ‚îÄ
function notify(type) {
  document.querySelectorAll('.block').forEach(bl => {
    const cfg = findBlockCfg(bl.id);
    if (!cfg || (cfg.type !== type && !(type === 'tasks' && cfg.type === 'task-flow'))) return;
    const body = bl.querySelector('.block-body');
    widgetRegistry.render(cfg.type, body, cfg);
  });
  widgetRegistry.emit(type, { type });
}

// Targeted updaters for individual elements
function notifyAgentStatus(agentId) {
  widgetRegistry.emit('agent-status', { agentId });
}

function notifyNewAgent(agent) {
  document.querySelectorAll('.agent-list').forEach(list => {
    list.insertAdjacentHTML('beforeend', agentCardHTML(agent));
  });
  document.querySelectorAll('.block').forEach(bl => {
    const cfg = findBlockCfg(bl.id);
    if (cfg?.type === 'agents') bl.querySelector('.block-title').textContent = `Agents (${state.agents.size})`;
  });
}

function notifyRingEntry(entry) {
  widgetRegistry.emit('ring-entry', entry);
  const agent = state.agents.get(entry.agentId);
  const color = agent?.color || '#888';
  const time = new Date(entry.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const html = `<div class="ring-entry" data-agent="${entry.agentId}" data-ts="${entry.ts}" style="border-left-color:${color}">
    <div class="re-header"><span class="re-agent" style="color:${color}">${entry.agentId}</span><span class="re-time">${time}</span></div>
    <div class="re-text">${(entry.content || '').slice(0,200)}</div>
  </div>`;
  document.querySelectorAll('.ring-entries').forEach(el => {
    el.insertAdjacentHTML('afterbegin', html);
    el.firstElementChild?.addEventListener('dblclick', () => openAgentChat(entry.agentId, entry.ts));
    while (el.children.length > 20) el.lastElementChild.remove();
  });
  function findCfg(nodes) { for (const n of nodes) { if (n.type === 'agent-chat' && n.agentId === entry.agentId) { const el = document.querySelector(`#${n.id} .block-body`); if (el) widgetRegistry.render('agent-chat', el, n); } if (n.children) findCfg(n.children); } }
  findCfg(state.layout);
}

function agentCardHTML(a) {
  const instances = a.instances || 1;
  const working = a.workingOn ? `<div style="font-size:9px;color:var(--text-muted);margin-top:2px">${a.workingOn.slice(0,40)}...</div>` : '';
  return `<div class="agent-card" data-agent="${a.id}">
    <div class="agent-dot ${a.status==='processing'?'pulse':''}" style="background:${a.color}"></div>
    <div class="agent-info">
      <div class="agent-name">${a.id}${instances>1?` (√ó${instances})`:''}</div>
      <div class="agent-model">${a.model}</div>
      ${working}
    </div>
    <div class="agent-badge" style="color:${a.status==='processing'?a.color:'var(--text-muted)'}">${a.status === 'processing' ? '<span class="typing-dots"><span></span><span></span><span></span></span>' : a.status}</div>
  </div>`;
}

function findBlockCfg(id) {
  for (const n of state.layout) {
    if (n.id === id) return n;
    if (n.children) { const c = n.children.find(x => x.id === id); if (c) return c; }
  }
  return null;
}

// ‚îÄ‚îÄ Chat Agent ‚îÄ‚îÄ
function ensureChatAgent() {
  if (state.chatAgent) return true;
  const chatCfg = state.agents.get('chat');
  if (!chatCfg) return false;
  try {
    const model = createModel(chatCfg.provider || detectProvider(), { modelId: chatCfg.modelId, maxTokens: 8192 });
    state.chatAgent = new Agent({ 
      model, 
      tools: ORCHESTRATOR_TOOLS, 
      systemPrompt: buildOrchestratorPrompt(), 
      printer: false, 
      conversationManager: createConversationManager(chatCfg.conversationManager)
    });
    seedAgentList(state.chatAgent);
    if (window.AgentMesh?.registerAgent) window.AgentMesh.registerAgent('chat', 'browser', { model: chatCfg.modelId });
    return true;
  } catch (e) { console.error('Failed to create chat agent:', e); return false; }
}

function startWallClock() {
  if (!state.wallClockStart) state.wallClockStart = Date.now();
}

async function sendChatMessage(text, blockId) {
  if (!text.trim()) return;
  if (!ensureChatAgent()) { alert('Failed to create chat agent. Check API key in Settings or select WebLLM.'); return; }
  startWallClock();

  const msgEl = document.querySelector(`#msg-${blockId}`);
  if (!msgEl) return;
  const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  // Show user message
  msgEl.insertAdjacentHTML('beforeend', `<div class="msg user">${escapeHtml(text)}<div class="msg-time">${time}</div></div>`);
  msgEl.scrollTop = msgEl.scrollHeight;

  // Add to ring
  state.ringBuffer.push({ agentId: 'user', content: text.slice(0, 300), ts: Date.now() });
  notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
  if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext('chat', 'browser', `[User] ${text.slice(0, 300)}`);

  // Update agent status
  const agentData = state.agents.get('chat');
  if (agentData) { agentData.status = 'processing'; notifyAgentStatus('chat'); }

  // Stream response
  const streamDiv = document.createElement('div');
  streamDiv.className = 'msg assistant';
  streamDiv.innerHTML = `<div class="msg-agent" style="color:${agentData?.color || 'var(--green)'}">chat</div><span class="stream-text"></span>`;
  msgEl.appendChild(streamDiv);

  try {
    let currentText = '';
    // Fresh agent per message for parallelism
    const chatCfg = state.agents.get('chat');
    const model = createModel(chatCfg?.provider || detectProvider(), { modelId: chatCfg?.modelId, maxTokens: 8192 });
    const agent = new Agent({ 
      model, 
      tools: ORCHESTRATOR_TOOLS, 
      systemPrompt: buildOrchestratorPrompt(), 
      printer: false, 
      conversationManager: createConversationManager(chatCfg?.conversationManager)
    });
    seedAgentList(agent);
    // Inject history
    for (const m of state.chatMessages.slice(-20)) {
      agent.messages.push({ role: m.role, content: [{ type: 'textBlock', text: m.content }] });
    }

    for await (const event of agent.stream(text)) {
      if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
        currentText += event.delta.text;
        streamDiv.querySelector('.stream-text').textContent = currentText;
        msgEl.scrollTop = msgEl.scrollHeight;
      }
    }

    streamDiv.querySelector('.stream-text').innerHTML = typeof marked !== 'undefined' ? marked.parse(currentText) : escapeHtml(currentText);
    streamDiv.insertAdjacentHTML('beforeend', `<div class="msg-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>`);
    state.chatMessages.push({ role: 'user', content: text }, { role: 'assistant', content: currentText });

    // Ring buffer
    state.ringBuffer.push({ agentId: 'chat', content: currentText.slice(0, 500), ts: Date.now() });
    notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
    if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext('chat', 'browser', currentText.slice(0, 500));
  } catch (e) {
    streamDiv.querySelector('.stream-text').textContent = `Error: ${e.message}`;
    streamDiv.style.color = 'var(--red)';
  }

  if (agentData) { agentData.status = 'ready'; notifyAgentStatus('chat'); }
}

function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function formatElapsed(start, end) {
  const s = Math.floor((end - start) / 1000);
  if (s < 60) return `${s}s`;
  return `${Math.floor(s/60)}m${s%60}s`;
}

// ‚îÄ‚îÄ Default Agents (loaded from agents.json) ‚îÄ‚îÄ
let DEFAULT_AGENTS = [];

async function loadDefaultAgents() {
  try {
    const resp = await fetch('./agents.json');
    DEFAULT_AGENTS = await resp.json();
  } catch (e) { console.warn('Failed to load agents.json, using empty defaults:', e); }
  DEFAULT_AGENTS.forEach((a, i) => {
    if (!state.agents.has(a.id)) {
      state.agents.set(a.id, { ...a, color: a.color || COLORS[i % COLORS.length], status: 'ready' });
    }
  });
  state.colorIndex = state.agents.size;
  // Register all agents with AgentMesh for cross-page discovery
  if (window.AgentMesh?.registerAgent) {
    state.agents.forEach((a, id) => window.AgentMesh.registerAgent(id, 'browser', { model: a.model }));
  }
}

// All render functions moved to their respective widgets

// Generic widget opener - data-driven
function openWidget(widgetType, params = {}, options = {}) {
  const { reuse = true, matchKey = null } = options;
  
  let found = null;
  if (reuse) {
    function search(nodes) {
      for (const n of nodes) {
        if (n.type === widgetType && (!matchKey || n[matchKey] === params[matchKey])) {
          found = n;
          return;
        }
        if (n.children) search(n.children);
      }
    }
    search(state.layout);
  }
  
  if (found) {
    Object.assign(found, params);
  } else {
    const id = `b-${widgetType}-${state.blockCounter++}`;
    state.layout.push({ id, type: widgetType, flex: 1, ...params });
  }
  layoutManager.render();
}

// Convenience wrappers
window.openAgentChat = (agentId, scrollTs) => openWidget('agent-chat', { agentId, _scrollTs: scrollTs || 0 }, { matchKey: 'agentId' });
window.openAgentDetail = (agentId) => openWidget('agent-detail', { agentId }, { reuse: true });
window.openTaskDetail = (taskId) => openWidget('task-detail', { taskId }, { reuse: true });

window.addBlock = (type) => openWidget(type, {}, { reuse: false });

// All layout functions moved to layout-manager.js

// ‚ïê‚ïê‚ïê CHAT AGENT ‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê WALL CLOCK ‚ïê‚ïê‚ïê
function updateWallClock() {
  if (!state.wallClockStart) return;
  const s = Math.floor((Date.now() - state.wallClockStart) / 1000);
  document.getElementById('wallClock').textContent = `‚è± ${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`;
}

// ‚ïê‚ïê‚ïê MESH NAV IN STATUS BAR ‚ïê‚ïê‚ïê
function populateMeshNav() {
  const slot = document.getElementById('meshNavSlot');
  if (!slot || !window.AgentMesh?.pages) return;
  const pages = window.AgentMesh.pages;
  const current = window.AgentMesh.currentPage?.id;
  slot.innerHTML = Object.entries(pages).map(([file, p]) =>
    `<a href="${file}" class="add-btn" style="${p.id===current?'color:var(--accent);border-color:var(--accent)':''}" title="${p.label}">${p.icon}</a>`
  ).join('');
  // Hide the floating mesh nav injected by agent-mesh.js
  const floatingNav = document.getElementById('agent-mesh-nav');
  if (floatingNav) floatingNav.style.display = 'none';
}

// ‚ïê‚ïê‚ïê INIT ‚ïê‚ïê‚ïê
loadCredentials();
await loadDefaultAgents();
loadTasks();
layoutManager.loadLayout() || layoutManager.render();
initialMeshSync();
setTimeout(populateMeshNav, 500); // after mesh-pages.json loads

// Discover on-chain agents (non-blocking)
if (window.AgentMesh?.erc8004) {
  const erc = AgentMesh.erc8004;
  erc.discoverAgents('sepolia').then(agents => {
    for (const a of agents) {
      const id = a.registration?.name || `erc8004-${a.agentId}`;
      if (state.agents.has(id)) continue;
      const agent = { id, model: `ERC-8004 #${a.agentId} ¬∑ Sepolia`, status: 'on-chain',
        color: COLORS[state.colorIndex++ % COLORS.length], chain: 'sepolia', onChain: true,
        owner: a.owner, services: a.registration?.services };
      state.agents.set(id, agent);
      notifyNewAgent(agent);
    }
  }).catch(e => console.warn('[ERC8004] Discovery failed:', e));
}
setInterval(updateWallClock, 1000);
updateWallClock();

// Lightweight elapsed time updater (no DOM rebuild)
setInterval(() => {
  document.querySelectorAll('.task-elapsed[data-start]').forEach(el => {
    const start = parseInt(el.dataset.start);
    const end = parseInt(el.dataset.end) || Date.now();
    el.textContent = formatElapsed(start, end);
  });
}, 1000);

// Subscribe to mesh events ‚Äî targeted updates, no polling
if (window.AgentMesh) {
  window.AgentMesh.subscribe?.('ring-update', (payload) => {
    if (!payload) return;
    const isDup = state.ringBuffer.some(e => e.agentId === payload.agentId && Math.abs(e.ts - payload.timestamp) < 5000);
    if (!isDup) {
      const entry = { agentId: payload.agentId, content: payload.text, ts: payload.timestamp, mesh: true };
      state.ringBuffer.push(entry);
      notifyRingEntry(entry);
    }
  });
  window.AgentMesh.subscribe?.('ping', (payload, source) => {
    if (!source?.agents) return;
    const before = new Set(state.agents.keys());
    for (const ma of source.agents) {
      if (!state.agents.has(ma.agentId)) {
        const agent = { id: ma.agentId, model: ma.model || ma.agentType || '?', status: ma.status || 'idle', color: COLORS[state.colorIndex++ % COLORS.length], remote: true };
        state.agents.set(ma.agentId, agent);
        notifyNewAgent(agent);
        injectAgentRosterChange(`Agent "${ma.agentId}" joined the mesh.`);
      } else {
        const a = state.agents.get(ma.agentId);
        if (ma.status && ma.status !== a.status) { a.status = ma.status; notifyAgentStatus(ma.agentId); }
      }
    }
  });
  window.AgentMesh.subscribe?.('relay-status', () => { const b = document.querySelector('#b-mesh .block-body'); if (b) renderMeshBlock(b); });
  window.AgentMesh.subscribe?.('relay-peers', () => { const b = document.querySelector('#b-mesh .block-body'); if (b) renderMeshBlock(b); });
}

// Inject agent roster changes into the chat agent's conversation so it stays aware
function injectAgentRosterChange(msg) {
  state.ringBuffer.push({ agentId: 'system', content: msg, ts: Date.now() });
  notifyRingEntry(state.ringBuffer[state.ringBuffer.length - 1]);
  // Push into chat history so the orchestrator sees it on next message
  state.chatMessages.push({ role: 'user', content: `[System] ${msg}` });
}

// Register SW and re-cache assets on every page load
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then(() => {
    navigator.serviceWorker.ready.then(reg => reg.active?.postMessage({ type: 'RECACHE' }));
  });
}
</script>
</body>
</html>
