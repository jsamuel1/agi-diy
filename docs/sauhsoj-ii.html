<!--
  sauhsoj-ii.html ‚Äî forked from agi.html for structured transcript refactor

  BASELINES (for merging/rebasing):
    Upstream fork point:  47f93bd (cagataycali/agi-diy) "fix: show edit/kill buttons on mobile"
    sauhsoj-ii fork point: 8f213ab (jsamuel1/agi-diy)  "chore: fork agi.html to sauhsoj-ii.html for transcript refactor"

  To incorporate upstream changes:
    1. git diff 202c0bb origin/main -- docs/agi.html   (review what changed upstream)
    2. For each change, evaluate its INTENTION ‚Äî don't blindly apply patches
    3. The same logical change may need different code in sauhsoj-ii.html
       due to the structured transcript refactor
    4. After incorporating, update the upstream fork point above
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>agi.diy ‚Äî multi-agent</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óà</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #0a0a0a;
            --bg-elevated: #111111;
            --glass: rgba(255,255,255,0.03);
            --glass-border: rgba(255,255,255,0.06);
            --glass-hover: rgba(255,255,255,0.08);
            --text: rgba(255,255,255,0.92);
            --text-secondary: rgba(255,255,255,0.55);
            --text-tertiary: rgba(255,255,255,0.35);
            --accent: rgba(255,255,255,0.9);
            --divider: rgba(255,255,255,0.08);
            --agent-colors: #00ff88, #00aaff, #ff88ff, #ffaa00, #ff6666, #88ffff, #ff8888, #88ff88;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            touch-action: pan-x pan-y;
            -webkit-text-size-adjust: 100%; /* Prevent text size adjustment on iOS */
        }
        ::selection { background: rgba(255,255,255,0.15); }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

        /* Layout */
        .app { display: flex; height: 100vh; }
        
        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--bg-elevated);
            border-right: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
        }
        .brand {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .brand-sub {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 400;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .sidebar-section {
            margin-bottom: 24px;
        }
        .sidebar-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        /* Agent Cards */
        .agent-list { display: flex; flex-direction: column; gap: 8px; }
        .agent-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover { border-color: rgba(255,255,255,0.15); }
        .agent-card:active { transform: scale(0.98); }
        .agent-card.active { border-color: rgba(255,255,255,0.3); background: var(--glass-hover); }
        .agent-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .agent-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .agent-name {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .agent-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(100,255,100,0.2);
            color: rgba(100,255,100,0.9);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .agent-status.processing { background: rgba(255,200,100,0.2); color: rgba(255,200,100,0.9); animation: pulse 1.5s infinite; }
        .agent-status.error { background: rgba(255,100,100,0.2); color: rgba(255,100,100,0.9); }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
        .agent-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            justify-content: space-between;
        }
        .agent-kill {
            opacity: 0;
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            transition: opacity 0.2s;
            padding: 4px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover .agent-kill { opacity: 1; }
        .agent-card.active .agent-kill { opacity: 1; } /* Show on active/selected */
        .agent-kill:hover { color: rgba(255,100,100,1); }
        .agent-edit {
            opacity: 0;
            cursor: pointer;
            color: var(--text-tertiary);
            transition: opacity 0.2s;
            margin-right: 8px;
            padding: 4px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover .agent-edit { opacity: 1; }
        .agent-card.active .agent-edit { opacity: 1; } /* Show on active/selected */
        .agent-edit:hover { color: var(--text); }
        
        /* Mobile: always show edit/kill buttons */
        @media (max-width: 900px) {
            .agent-kill, .agent-edit { opacity: 0.7; }
            .agent-card.active .agent-kill,
            .agent-card.active .agent-edit { opacity: 1; }
        }
        
        /* Tools Grid */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        .tool-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }
        .tool-item:hover { border-color: rgba(255,255,255,0.2); }
        .tool-item.enabled { border-color: rgba(100,255,100,0.4); background: rgba(100,255,100,0.1); }
        .tool-item input[type="checkbox"] {
            accent-color: #0f0;
        }
        .tool-item-name { font-weight: 500; }
        .tool-item-desc {
            font-size: 9px;
            color: var(--text-tertiary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Spawn Button */
        .spawn-btn {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 2px dashed var(--glass-border);
            border-radius: 12px;
            color: var(--text-tertiary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px; /* Touch target minimum */
            margin-top: 12px;
            -webkit-tap-highlight-color: transparent;
        }
        .spawn-btn:hover {
            border-color: rgba(255,255,255,0.2);
            color: var(--text-secondary);
        }
        
        /* Scheduled Tasks */
        .schedule-item {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .schedule-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .schedule-cron {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .schedule-delete {
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            font-size: 14px;
        }
        .schedule-delete:hover { color: rgba(255,100,100,1); }
        
        /* Main Area */
        .content-area { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .content-panels { flex: 1; display: flex; min-height: 0; }
        .chat-panel { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .panel-resizer { width: 4px; cursor: col-resize; background: var(--divider); flex-shrink: 0; }
        .panel-resizer:hover, .panel-resizer.dragging { background: var(--accent, #00ff88); }
        .activity-panel { flex: 1; border-left: none; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }
        .activity-panel-header { padding: 8px 12px; border-bottom: 1px solid var(--divider); display: flex; align-items: center; gap: 6px; }
        .activity-panel-header select { flex: 1; background: transparent; border: none; color: var(--text-secondary); font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: .05em; cursor: pointer; outline: none; }
        .activity-panel-header select option { background: var(--bg); color: var(--text); }
        .verbosity-select { background: transparent; border: 1px solid var(--divider); color: var(--text-tertiary); font-size: 10px; border-radius: 4px; padding: 2px 4px; cursor: pointer; outline: none; }
        .verbosity-select option { background: var(--bg); color: var(--text); }
        /* Verbosity: 1=chat, 2=+widgets, 3=+tool summary, 4=+tool details */
        [data-verbosity="1"] .tool-block, [data-verbosity="1"] .sandbox-wrap { display: none !important; }
        [data-verbosity="2"] .tool-block { display: none !important; }
        [data-verbosity="3"] .tool-block details { display: none !important; }
        .activity-feed { flex: 1; overflow-y: auto; padding: 8px 12px; font-size: 12px; }
        .activity-feed .af-agent { font-weight: 600; margin-top: 8px; padding: 2px 0; }
        .activity-feed .af-agent:first-child { margin-top: 0; }
        .activity-feed .af-msg { color: #ccc; padding: 1px 0 1px 8px; border-left: 2px solid var(--agent-color, #555); line-height: 1.5; }
        .activity-feed .af-tool { color: #888; padding: 1px 0 1px 8px; border-left: 2px solid var(--agent-color, #555); font-style: italic; }
        
        /* Header */
        .header {
            padding: 16px 24px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .current-agent {
            font-size: 14px;
            font-weight: 500;
        }
        .current-agent-model {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        .header-right {
            display: flex;
            gap: 8px;
        }
        .header-btn {
            padding: 8px 14px;
            border-radius: 8px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            min-height: 36px;
            -webkit-tap-highlight-color: transparent;
        }
        .header-btn:hover { background: var(--glass-hover); color: var(--text); }
        .header-btn:active { transform: scale(0.95); }
        
        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .messages-inner {
            max-width: 800px;
            margin: 0 auto;
        }
        .message {
            margin-bottom: 32px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .message-role {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 1px 4px;
            border-radius: 3px;
            background: var(--glass);
            color: var(--text-tertiary);
        }
        .message-agent {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--glass);
        }
        .message-arrow {
            color: var(--text-tertiary);
            opacity: 0.6;
            font-size: 14px;
        }
        .message-time {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .message-content {
            font-size: 14px;
            line-height: 1.8;
        }
        .message.user .message-content { color: var(--text-secondary); }
        .message.system {
            padding: 20px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
        }
        .message.system .message-content {
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        /* Tool Block */
        .tool-block {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 12px 16px;
            margin: 16px 0;
        }
        .tool-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }
        .tool-status.running { background: var(--text); animation: pulse 1.5s infinite; }
        .tool-status.error { background: rgba(255,100,100,0.8); }
        .tool-name {
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .tool-input {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            overflow-x: auto;
            white-space: pre-wrap;
            color: var(--text-tertiary);
        }
        
        /* Dynamic UI */
        .dynamic-ui {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        /* Markdown */
        .markdown-content { padding: 4px 8px; }
        .markdown-content h1,.markdown-content h2,.markdown-content h3 { margin:20px 0 10px; font-weight:600; }
        .markdown-content h1 { font-size:18px; }
        .markdown-content h2 { font-size:16px; }
        .markdown-content h3 { font-size:14px; }
        .markdown-content code { background:rgba(255,255,255,0.06); padding:2px 6px; border-radius:4px; font-family:'SF Mono',monospace; font-size:12px; }
        .markdown-content pre { background:rgba(0,0,0,0.4); padding:14px; border-radius:8px; overflow-x:auto; margin:14px 0; }
        .markdown-content pre code { background:none; padding:0; }
        .markdown-content a { color:var(--text); text-decoration:underline; text-underline-offset:3px; }
        
        /* Input */
        .input-container {
            padding: 16px 24px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            border-top: 1px solid var(--divider);
        }
        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
        }
        .target-select {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0 12px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            min-width: 100px;
            height: 50px;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.5)' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 28px;
        }
        .target-select:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            resize: none;
            min-height: 50px;
            max-height: 150px;
            -webkit-appearance: none;
            appearance: none;
        }
        .input-field:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field::placeholder { color: var(--text-tertiary); }
        .send-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        .send-btn:hover { background: var(--glass-hover); color: var(--text); }
        .send-btn:active { transform: scale(0.92); }
        .send-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* Thinking */
        .thinking { display:flex; gap:6px; padding:8px 0; }
        .thinking-dot { width:6px; height:6px; border-radius:50%; background:var(--text-tertiary); animation:bounce 1.4s infinite ease-in-out both; }
        .thinking-dot:nth-child(1) { animation-delay:-0.32s; }
        .thinking-dot:nth-child(2) { animation-delay:-0.16s; }
        @keyframes bounce { 0%,80%,100%{transform:scale(0);opacity:0.3} 40%{transform:scale(1);opacity:1} }
        
        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-title { font-size: 15px; font-weight: 600; }
        .modal-close {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            color: var(--text-tertiary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }
        .modal-close:hover { background: var(--glass); color: var(--text); }
        .modal-close:active { transform: scale(0.9); }
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .form-group { margin-bottom: 20px; }
        .form-label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            font-weight: 600;
        }
        .form-input {
            width: 100%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px 14px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            font-family: inherit;
            -webkit-appearance: none;
            appearance: none;
        }
        .form-input:focus { 
            outline: none; 
            border-color: rgba(255,255,255,0.2);
        }
        textarea.form-input { 
            min-height: 80px; 
            resize: vertical; 
            font-family: inherit; 
        }
        .form-hint { font-size: 11px; color: var(--text-tertiary); margin-top: 6px; }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px; /* Touch target minimum */
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { background: var(--glass-hover); color: var(--text); }
        .btn-primary { background: var(--text); color: var(--bg); border-color: var(--text); }
        .btn-primary:hover { background: rgba(255,255,255,0.85); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--glass);
            border-radius: 8px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .tabs::-webkit-scrollbar { display: none; }
        .tab {
            flex: 0 0 auto;
            padding: 10px 16px;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            min-height: 40px;
            -webkit-tap-highlight-color: transparent;
        }
        .tab:hover { color: var(--text-secondary); }
        .tab:active { transform: scale(0.95); }
        .tab.active { background: var(--bg); color: var(--text); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 10px 18px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0;
            transition: all 0.3s;
            z-index: 300;
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        /* Ring Context Panel */
        .ring-panel {
            width: 240px;
            background: var(--bg-elevated);
            border-left: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .ring-header {
            padding: 16px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .ring-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ring-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(100,255,100,0.6);
            animation: pulse 2s infinite;
        }
        .ring-clear-btn {
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-tertiary);
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ring-clear-btn:hover {
            background: var(--glass);
            color: rgba(255,100,100,0.8);
            border-color: rgba(255,100,100,0.3);
        }
        .ring-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .ring-entry {
            background: var(--glass);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 11px;
            position: relative;
        }
        .ring-entry:hover .ring-entry-delete {
            opacity: 1;
        }
        .ring-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .ring-entry-agent {
            font-weight: 500;
        }
        .ring-entry-meta {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ring-entry-time {
            color: var(--text-tertiary);
            font-size: 10px;
        }
        .ring-entry-delete {
            opacity: 0;
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            font-size: 12px;
            transition: opacity 0.2s, color 0.2s;
            padding: 2px 4px;
        }
        .ring-entry-delete:hover {
            color: rgba(255,100,100,1);
        }
        .ring-entry-content {
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Mobile */
        @media (max-width: 900px) {
            .sidebar { display: none; }
            .ring-panel { display: none; }
            .header { 
                padding: 10px 16px;
                padding-top: calc(10px + env(safe-area-inset-top));
                flex-wrap: wrap;
                gap: 8px;
            }
            .header-left {
                gap: 8px;
                flex: 1;
                min-width: 0;
            }
            .header-right {
                gap: 6px;
            }
            .header-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            .current-agent {
                font-size: 13px;
            }
            .current-agent-model {
                font-size: 10px;
            }
            .messages-container { 
                padding: 12px; 
            }
            .messages-inner {
                max-width: 100%;
            }
            .message {
                margin-bottom: 24px;
            }
            .message-content {
                font-size: 14px;
            }
            .input-container { 
                padding: 10px 12px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom));
            }
            .input-wrapper {
                gap: 8px;
            }
            .target-select { 
                min-width: 70px; 
                font-size: 12px;
                padding: 0 8px;
            }
            .input-field {
                padding: 12px 14px;
                min-height: 44px;
            }
            .send-btn {
                width: 44px;
                height: 44px;
            }
            .modal-content {
                max-height: 90vh;
                border-radius: 16px;
            }
            .modal-body {
                padding: 20px;
            }
            .modal-header {
                padding: 16px 20px;
            }
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .tabs::-webkit-scrollbar {
                display: none;
            }
            .tab {
                padding: 8px 12px;
                font-size: 12px;
                white-space: nowrap;
            }
            .tools-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Extra small mobile */
        @media (max-width: 480px) {
            .header-right {
                gap: 4px;
            }
            .header-btn {
                padding: 5px 8px;
                font-size: 10px;
            }
            .header-btn:not(:first-child):not(:last-child) {
                /* Hide middle buttons on very small screens */
            }
        }
        
        /* Mobile menu */
        .mobile-menu-btn {
            display: none;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        @media (max-width: 900px) {
            .mobile-menu-btn { display: block; }
        }
        .mobile-sidebar {
            position: fixed;
            inset: 0;
            background: var(--bg-elevated);
            z-index: 150;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        .mobile-sidebar.active { transform: translateX(0); }
        .mobile-sidebar-close {
            position: absolute;
            top: calc(16px + env(safe-area-inset-top));
            right: 16px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        /* Pipeline Panel */
        .pipeline-panel { display: none; }
        .pipeline-header { padding: 16px; border-bottom: 1px solid var(--divider); display: flex; justify-content: space-between; align-items: center; }
        .pipeline-header-title { font-size: 13px; font-weight: 500; color: var(--text-secondary); }
        .pipeline-pills { display: flex; align-items: center; gap: 4px; padding: 12px 16px; overflow-x: auto; flex-wrap: wrap; border-bottom: 1px solid var(--divider); min-height: 48px; }
        .phase-pill { padding: 5px 14px; border-radius: 20px; cursor: pointer; font-size: 12px; white-space: nowrap; transition: all 0.3s; }
        .phase-pending { border: 1px dashed #555; color: #888; }
        .phase-working { border: 1px solid var(--task-color, #ffaa00); color: var(--task-color, #ffaa00); animation: pillPulse 2s infinite; }
        .phase-done { border: 1px solid #00ff88; color: #00ff88; background: rgba(0,255,136,0.08); }
        .phase-error { border: 1px solid #ff6666; color: #ff6666; }
        .phase-connector { width: 16px; border-top: 1px dashed #444; display: inline-block; vertical-align: middle; }
        @keyframes pillPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.65; } }
        .activity-log { flex: 1; overflow-y: auto; padding: 12px 16px; }
        .activity-heading { font-size: 13px; font-weight: 600; margin-top: 12px; margin-bottom: 4px; }
        .activity-heading:first-child { margin-top: 0; }
        .activity-line { font-size: 12px; color: #ccc; padding: 2px 0; line-height: 1.5; }
        .activity-done { color: #00ff88; }
        .completion-cards { display: flex; gap: 8px; padding: 12px 16px; border-top: 1px solid var(--divider); }
        .completion-card { flex: 1; padding: 12px; border-radius: 8px; border: 1px solid var(--glass-border); background: var(--glass); text-decoration: none; display: flex; flex-direction: column; gap: 4px; transition: background 0.2s; }
        .completion-card:hover { background: var(--glass-hover); }
        .completion-card strong { font-size: 12px; color: var(--text); }
        .completion-card span { font-size: 11px; color: var(--text-tertiary); }
        .pipeline-empty { padding: 40px 16px; text-align: center; color: var(--text-tertiary); font-size: 12px; }
        /* Pipeline Flow (above chat) */
        .pipeline-flow { display: none; padding: 12px 24px; border-bottom: 1px solid var(--divider); overflow-x: auto; }
        .pipeline-flow.active { display: block; }
        .pipeline-flow-inner { display: flex; align-items: center; gap: 0; min-height: 40px; position: relative; }
        .pf-node { width: 20ch; height: 40px; padding: 4px 8px; border-radius: 6px; font-size: 11px; line-height: 1.4; overflow: hidden; display: flex; align-items: center; justify-content: center; text-align: center; border: 1px dashed #555; color: #888; background: transparent; transition: all .3s; flex-shrink: 0; box-sizing: border-box; }
.pf-node span { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .pf-node.pending { border: 1px dashed #555; color: #888; }
        .pf-node.working { border: 1px solid var(--task-color, #ffaa00); color: var(--task-color, #ffaa00); animation: pillPulse 2s infinite; background: rgba(255,170,0,.06); }
        .pf-node.done, .pf-node.success { border: 1px solid #00ff88; color: #00ff88; background: rgba(0,255,136,.08); }
        .pf-node.error, .pf-node.failed { border: 1px solid #ff6666; color: #ff6666; background: rgba(255,102,102,.08); }
        .pf-node.partial { border: 1px solid #ff9933; color: #ff9933; background: rgba(255,153,51,.08); animation: pillPulse 3s infinite; }
        .pf-edge { width: 24px; height: 0; border-top: 1px solid #444; flex-shrink: 0; }
        .pf-edge.done { border-color: #00ff88; }
        .pf-edge.working { border-color: var(--task-color, #ffaa00); border-style: solid; }
        .pf-back { position: absolute; border: 1px dashed #ff6666; border-radius: 0 0 8px 8px; pointer-events: none; }
        /* Preview mode ‚Äî sandbox as background, chat overlays */
        #previewBackground { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; pointer-events: none; }
        #previewBackground iframe { width: 100%; height: 100%; border: none; }
        body.preview-mode, body.preview-mode .app, body.preview-mode .messages-container, body.preview-mode .messages-inner { background: transparent !important; }
        body.preview-mode .header, body.preview-mode .input-field, body.preview-mode .send-btn, body.preview-mode .message.system, body.preview-mode .tool-block, body.preview-mode .dynamic-ui { background: rgba(0,0,0,0.75) !important; backdrop-filter: none !important; }
        body.preview-mode .message.assistant .message-content { background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 12px; }
        body.preview-mode .sidebar, body.preview-mode .activity-panel { background: rgba(10,10,15,0.9) !important; }
        body.preview-mode .pipeline-flow { background: rgba(0,0,0,0.75) !important; }
        body.preview-mode .input-container { background: transparent !important; }
        /* Sandbox */
        .sandbox-wrap { margin: 8px 0; border: 1px solid var(--glass-border); border-radius: 8px; overflow: hidden; }
        .sandbox-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 12px; background: var(--glass); font-size: 12px; color: var(--text-secondary); }
        .sandbox-header button { background: none; border: none; color: var(--text-tertiary); cursor: pointer; font-size: 14px; }
        @media (max-width: 1100px) { .activity-panel { display: none; } }
    </style>
</head>
<body>
    <div id="previewBackground"></div>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="brand" id="brandTitle">
                    agi.diy
                    <span class="brand-sub">multi-agent</span>
                </div>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <div class="sidebar-title">Agents</div>
                    <div class="agent-list" id="agentList">
                        <!-- Populated by JS -->
                    </div>
                    <button class="spawn-btn" onclick="openSpawnModal()">+ New Agent</button>
                </div>
                <div class="sidebar-section">
                    <div class="sidebar-title">Scheduled Tasks</div>
                    <div id="scheduleList">
                        <div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Content Area -->
        <div class="content-area">
            <header class="header">
                <div class="header-left">
                    <button class="mobile-menu-btn" onclick="toggleMobileSidebar()">‚ò∞</button>
                    <div>
                        <div class="current-agent" id="currentAgentName">No Agent Selected</div>
                        <div class="current-agent-model" id="currentAgentModel">‚Äî</div>
                    </div>
                </div>
                <div class="header-right">
                    <a href="index.html" class="header-btn" title="Single Agent Mode">‚óà single</a>
                    <button class="header-btn" onclick="broadcastMessage()">üì¢ Broadcast</button>
                    <button class="header-btn" onclick="clearChat()">üóëÔ∏è Clear</button>
                    <button class="header-btn" onclick="clearAllChats()">üóëÔ∏è Clear All</button>
                    <button class="header-btn" id="previewToggle" onclick="togglePreviewMode()" title="Toggle app preview background">üñºÔ∏è Preview</button>
                    <button class="header-btn" onclick="openSettingsModal()">‚öôÔ∏è Settings</button>
                </div>
            </header>
            
            <div class="pipeline-flow" id="pipelineFlow"></div>
            <div class="content-panels">
                <main class="chat-panel" data-verbosity="2">
                    <div style="padding:4px 12px;border-bottom:1px solid var(--divider);display:flex;justify-content:flex-end;">
                        <select class="verbosity-select" onchange="this.closest('[data-verbosity]').dataset.verbosity=this.value">
                            <option value="1">Chat</option><option value="2" selected>Chat + Widgets</option><option value="3">+ Tool Summary</option><option value="4">+ Tool Details</option>
                        </select>
                    </div>
                    <div class="messages-container" id="messagesContainer">
                        <div class="messages-inner" id="messagesInner">
                            <div class="message system">
                                <div class="message-content">
                                    <strong>Multi-Agent AGI</strong><br><br>
                                    Start chatting immediately ‚Äî a default agent is created with your saved credentials.<br><br>
                                    ‚Ä¢ <strong>use_agent</strong>: Create sub-agents for parallel tasks<br>
                                    ‚Ä¢ <strong>scheduler</strong>: Schedule recurring tasks with cron<br>
                                    ‚Ä¢ <strong>create_tool</strong>: Build new tools at runtime<br>
                                    ‚Ä¢ <strong>update_self</strong>: Modify agent system prompts<br>
                                    ‚Ä¢ <strong>Ring Attention</strong>: Agents share context automatically<br><br>
                                    Click "+ New Agent" to spawn additional agents, or ‚öôÔ∏è Settings to configure API keys.
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="input-container">
                        <div class="input-wrapper">
                            <select class="target-select" id="targetAgent" onchange="if(this.value!=='all')selectAgent(this.value)">
                                <option value="all">All Agents</option>
                            </select>
                            <textarea class="input-field" id="inputField" placeholder="Send a message..." rows="1" onkeydown="handleKeyDown(event)"></textarea>
                            <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                    <polyline points="12 5 19 12 12 19"></polyline>
                                </svg>
                            </button>
                            <button class="send-btn" id="interruptBtn" title="Send as interrupt (inject into running agent)" onclick="sendInterrupt()" style="background:var(--warning);display:none;">‚ö°</button>
                        </div>
                    </div>
                </main>
                
                <div class="panel-resizer" id="panelResizer"></div>
                <aside class="activity-panel" id="activityPanel" data-verbosity="4">
                    <div class="activity-panel-header"><select id="activityFilter" onchange="filterActivityFeed()"><option value="all">All Agents</option></select><select class="verbosity-select" id="activityVerbosity" onchange="document.querySelector('.activity-panel').dataset.verbosity=this.value"><option value="1">Chat</option><option value="2">Chat + Widgets</option><option value="3">+ Tool Summary</option><option value="4" selected>+ Tool Details</option></select></div>
                    <div class="activity-feed" id="activityFeed"></div>
                </aside>
            </div>
        </div>
        
        <!-- Hidden: old pipeline panel kept for data functions -->
        <aside class="pipeline-panel" id="pipelinePanel" style="display:none;">
            <div class="pipeline-pills" id="pipelinePills"></div>
            <div class="activity-log" id="activityLog"></div>
            <div class="completion-cards" id="completionCards" style="display:none;"></div>
        </aside>
    </div>
    
    <!-- Mobile Sidebar -->
    <div class="mobile-sidebar" id="mobileSidebar">
        <button class="mobile-sidebar-close" onclick="toggleMobileSidebar()">√ó</button>
        <div style="padding:60px 20px 20px;">
            <div class="sidebar-section">
                <div class="sidebar-title">Agents</div>
                <div class="agent-list" id="mobileAgentList"></div>
                <button class="spawn-btn" onclick="openSpawnModal();toggleMobileSidebar();">+ New Agent</button>
            </div>
        </div>
    </div>
    
    <!-- Spawn Modal -->
    <div class="modal" id="spawnModal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="modal-title">Spawn New Agent</span>
                <button class="modal-close" onclick="closeModal('spawnModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Agent ID</label>
                    <input type="text" class="form-input" id="spawnId" placeholder="e.g., researcher, coder">
                </div>
                <div class="form-group">
                    <label class="form-label">Model Provider</label>
                    <select class="form-input" id="spawnProvider" onchange="updateSpawnModelDefaults()">
                        <option value="bedrock">Amazon Bedrock</option>
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Model ID (optional)</label>
                    <input type="text" class="form-input" id="spawnModelId" list="spawnModelList" placeholder="Leave empty for default" value="global.anthropic.claude-opus-4-6-v1" oninput="onModelSelected('spawn')">
                    <div class="form-hint" id="spawnModelHint">Default: global.anthropic.claude-opus-4-6-v1</div>
                </div>
                <div class="form-group">
                    <label class="form-label">System Prompt</label>
                    <textarea class="form-input" id="spawnPrompt" rows="4" placeholder="You are a helpful assistant..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" class="form-input" id="spawnMaxTokens" value="60000">
                </div>
                <div class="form-group" id="spawnAdditionalFieldsGroup">
                    <label class="form-label">Additional Request Fields (JSON)</label>
                    <textarea class="form-input" id="spawnAdditionalFields" rows="3" placeholder='{"thinking": {"type": "adaptive"}}'></textarea>
                    <div class="form-hint">Extended thinking, betas, etc. For Anthropic/Bedrock.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">MCP Servers (optional)</label>
                    <div id="spawnMcpServers"></div>
                    <div style="display:flex;gap:4px;margin-top:4px;">
                        <button class="btn" type="button" onclick="addMcpServerEntry('spawnMcpServers')" style="font-size:11px;padding:2px 8px;">+ Add MCP Server</button>
                        <button class="btn" type="button" onclick="importMcpFromJson('spawnMcpServers')" style="font-size:11px;padding:2px 8px;">üìã Import JSON</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Tools</label>
                    <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px;">
                        <button class="btn" onclick="selectToolGroup('all')" style="font-size:11px;padding:2px 8px;">All</button>
                        <button class="btn" onclick="selectToolGroup('core')" style="font-size:11px;padding:2px 8px;">Core</button>
                        <button class="btn" onclick="selectToolGroup('sandbox')" style="font-size:11px;padding:2px 8px;">Sandbox</button>
                        <button class="btn" onclick="selectToolGroup('pipeline')" style="font-size:11px;padding:2px 8px;">Pipeline</button>
                        <button class="btn" onclick="selectToolGroup('agents')" style="font-size:11px;padding:2px 8px;">Agents</button>
                        <button class="btn" onclick="selectToolGroup('github')" style="font-size:11px;padding:2px 8px;">GitHub</button>
                        <button class="btn" onclick="selectToolGroup('none')" style="font-size:11px;padding:2px 8px;">None</button>
                    </div>
                    <div id="spawnToolsList" class="tools-grid"></div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('spawnModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="spawnAgent()">Spawn Agent</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Settings</span>
                <button class="modal-close" onclick="closeModal('settingsModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="tabs">
                    <button class="tab active" onclick="showTab(event,'credentials')">API Keys</button>
                    <button class="tab" onclick="showTab(event,'network')">Network</button>
                    <button class="tab" onclick="showTab(event,'tools')">Tools</button>
                    <button class="tab" onclick="showTab(event,'sync')">Sync</button>
                    <button class="tab" onclick="showTab(event,'export')">Export</button>
                </div>
                
                <div class="tab-content active" id="tab-credentials">
                    <div class="form-group">
                        <label class="form-label">Anthropic API Key</label>
                        <input type="password" class="form-input" id="anthropicKey" placeholder="sk-ant-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">OpenAI API Key</label>
                        <input type="password" class="form-input" id="openaiKey" placeholder="sk-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock API Key</label>
                        <input type="password" class="form-input" id="bedrockKey" placeholder="bedrock-api-key">
                        <div class="form-hint">Generate at AWS Bedrock Console ‚Üí API Keys</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock Region</label>
                        <select class="form-input" id="bedrockRegion">
                            <option value="us-east-1">us-east-1</option>
                            <option value="us-west-2">us-west-2</option>
                            <option value="eu-west-1">eu-west-1</option>
                            <option value="ap-southeast-2">ap-southeast-2</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">GitHub Token (PAT or Device Flow)</label>
                        <input type="password" class="form-input" id="githubToken" placeholder="ghp_... or click Authenticate">
                        <button class="btn" onclick="githubDeviceFlow()" style="margin-top:4px;font-size:11px;">üîë Authenticate via Device Flow</button>
                    </div>
                    <button class="btn btn-primary" onclick="saveCredentials()">Save Credentials</button>
                </div>
                
                <div class="tab-content" id="tab-network">
                    <div class="form-group">
                        <label class="form-label">üåê P2P Network Mode</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Connect to remote agents via WebSocket relay. Local agents use BroadcastChannel automatically.
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Relay Server URL</label>
                        <input type="text" class="form-input" id="relayUrl" placeholder="wss://your-relay.example.com">
                        <div class="form-hint">WebSocket URL for cross-browser/device P2P</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Instance ID</label>
                        <input type="text" class="form-input" id="instanceId" placeholder="Leave blank for auto-generated">
                        <div class="form-hint">Unique identifier for this browser instance</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Connection Status</label>
                        <div id="networkStatus" style="font-family:'SF Mono',monospace;font-size:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;">
                            <div>Local: <span style="color:#0f0">‚óè BroadcastChannel active</span></div>
                            <div>Remote: <span id="wsStatus" style="color:#f66">‚óè Disconnected</span></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Remote Peers</label>
                        <div id="remotePeersList" style="font-size:12px;color:var(--text-tertiary);padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;min-height:40px;">
                            No remote peers connected
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="connectRelay()">Connect</button>
                        <button class="btn" onclick="disconnectRelay()">Disconnect</button>
                    </div>
                </div>
                
                <div class="tab-content" id="tab-tools">
                    <div class="form-group">
                        <label class="form-label">Built-in Tools</label>
                        <div style="font-size:12px;color:var(--text-secondary);line-height:2;">
                            <strong>Core:</strong> <code>render_ui</code> <code>javascript_eval</code> <code>storage_get</code> <code>storage_set</code> <code>fetch_url</code> <code>notify</code><br>
                            <strong>Self-Mod:</strong> <code>update_self</code> <code>create_tool</code> <code>list_tools</code> <code>delete_tool</code><br>
                            <strong>Agents:</strong> <code>use_agent</code> <code>scheduler</code><br>
                            <strong>Mesh:</strong> <code>invoke_agent</code> <code>broadcast_to_agents</code> <code>list_agents</code> <code>invoke_remote_agent</code><br>
                            <strong>PubSub:</strong> <code>subscribe_topic</code> <code>publish_topic</code>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Custom Tools</label>
                        <div id="customToolsList" style="font-size:12px;color:var(--text-tertiary);">
                            Agents can create tools with <code>create_tool</code>. Use <code>list_tools</code> to see all, <code>delete_tool</code> to remove.
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="tab-sync">
                    <div class="form-group">
                        <label class="form-label">üîó Sync via URL</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;">
                            Export your API keys as an encrypted URL for iPhone shortcuts or syncing to another device.
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">üì§ Export Settings</label>
                        <div style="display:flex;gap:8px;margin-bottom:12px;">
                            <input type="password" class="form-input" id="syncExportPassword" placeholder="Encryption password" style="flex:1;">
                            <button class="btn btn-primary" onclick="exportSyncUrl()">Export</button>
                        </div>
                        <div id="syncExportResult" style="display:none;">
                            <textarea class="form-input" id="syncExportedUrl" rows="3" readonly style="font-size:11px;"></textarea>
                            <button class="btn" onclick="navigator.clipboard.writeText(document.getElementById('syncExportedUrl').value);showToast('Copied!');" style="margin-top:8px;">üìã Copy URL</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;padding-top:24px;border-top:1px solid var(--divider);">
                        <label class="form-label">üì• Import Settings</label>
                        <textarea class="form-input" id="syncImportUrl" rows="2" placeholder="Paste encrypted URL..." style="font-size:11px;margin-bottom:8px;"></textarea>
                        <div style="display:flex;gap:8px;">
                            <input type="password" class="form-input" id="syncImportPassword" placeholder="Decryption password" style="flex:1;">
                            <button class="btn btn-primary" onclick="importSyncUrl()">Import</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top:24px;">
                        <label class="form-label">üì± iPhone Shortcut</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.6;">
                            Use <code>?q=your+message</code> URL param to trigger queries:<br>
                            <code style="font-size:10px;">https://agi.diy/agi.html?q=what%20time%20is%20it</code>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="tab-export">
                    <div class="form-group">
                        <label class="form-label">Export All Agents</label>
                        <button class="btn" onclick="exportAllAgents()">üì¶ Export State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Import Agents</label>
                        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importAgents(event)">
                        <button class="btn" onclick="document.getElementById('importFile').click()">üì• Import State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Clear All Data</label>
                        <button class="btn" style="color:rgba(255,100,100,0.8)" onclick="clearAllData()">üóëÔ∏è Clear Everything</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Agent Modal -->
    <div class="modal" id="editAgentModal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="modal-title">Edit Agent: <span id="editAgentTitle"></span></span>
                <button class="modal-close" onclick="closeModal('editAgentModal')">√ó</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editAgentId">
                <div class="form-group">
                    <label class="form-label">Model Provider</label>
                    <select class="form-input" id="editProvider" onchange="updateEditModelDefaults()">
                        <option value="bedrock">Amazon Bedrock</option>
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Model ID</label>
                    <input type="text" class="form-input" id="editModelId" list="editModelList" placeholder="Leave empty for default" oninput="onModelSelected('edit')">
                    <div class="form-hint" id="editModelHint">Default: global.anthropic.claude-opus-4-6-v1</div>
                </div>
                <div class="form-group">
                    <label class="form-label">System Prompt</label>
                    <textarea class="form-input" id="editPrompt" rows="4" placeholder="You are a helpful assistant..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" class="form-input" id="editMaxTokens" value="60000">
                </div>
                <div class="form-group" id="editAdditionalFieldsGroup">
                    <label class="form-label">Additional Request Fields (JSON)</label>
                    <textarea class="form-input" id="editAdditionalFields" rows="3" placeholder='{"thinking": {"type": "adaptive"}}'></textarea>
                    <div class="form-hint">Extended thinking, betas, etc. For Anthropic/Bedrock.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">MCP Servers (optional)</label>
                    <div id="editMcpServers"></div>
                    <div style="display:flex;gap:4px;margin-top:4px;">
                        <button class="btn" type="button" onclick="addMcpServerEntry('editMcpServers')" style="font-size:11px;padding:2px 8px;">+ Add MCP Server</button>
                        <button class="btn" type="button" onclick="importMcpFromJson('editMcpServers')" style="font-size:11px;padding:2px 8px;">üìã Import JSON</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Tools</label>
                    <div id="editToolsList" class="tools-grid"></div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('editAgentModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="saveAgentEdit()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Schedule Modal -->
    <div class="modal" id="scheduleModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Schedule Task</span>
                <button class="modal-close" onclick="closeModal('scheduleModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" class="form-input" id="scheduleName" placeholder="daily-summary">
                </div>
                <div class="form-group">
                    <label class="form-label">Agent</label>
                    <select class="form-input" id="scheduleAgent"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Prompt</label>
                    <textarea class="form-input" id="schedulePrompt" rows="3" placeholder="What should the agent do?"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Schedule Type</label>
                    <select class="form-input" id="scheduleType" onchange="toggleScheduleFields()">
                        <option value="once">Once (delayed)</option>
                        <option value="cron">Recurring (cron)</option>
                    </select>
                </div>
                <div class="form-group" id="delayField">
                    <label class="form-label">Delay (seconds)</label>
                    <input type="number" class="form-input" id="scheduleDelay" value="60">
                </div>
                <div class="form-group" id="cronField" style="display:none;">
                    <label class="form-label">Cron Expression</label>
                    <input type="text" class="form-input" id="scheduleCron" placeholder="*/5 * * * *">
                    <div class="form-hint">e.g., */5 * * * * = every 5 minutes</div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('scheduleModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createSchedule()">Schedule</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <!-- Polyfills -->
    <script>
    if (typeof Symbol.dispose === 'undefined') Symbol.dispose = Symbol('Symbol.dispose');
    if (typeof Symbol.asyncDispose === 'undefined') Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
    </script>

    <script type="module">
    import { Agent, tool, Model, z, BeforeModelCallEvent, AfterInvocationEvent, SlidingWindowConversationManager, BedrockModel, McpClient, StreamableHTTPClientTransport } from './strands.js?v=2';
    
    // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    // ‚ïë  agi.html ‚Äî Multi-Agent System                                          ‚ïë
    // ‚ïë                                                                         ‚ïë
    // ‚ïë  SECTION INDEX (search for ‚ïê‚ïê‚ïê SECTION_NAME to jump)                    ‚ïë
    // ‚ïë                                                                         ‚ïë
    // ‚ïë  STATE ................ App state, constants, config                     ‚ïë
    // ‚ïë  PIPELINE MODEL ....... getPipelines, topoSort, renderPipelineFlow      ‚ïë
    // ‚ïë  MODEL PROVIDERS ...... AnthropicModel, OpenAIModel, BedrockModel       ‚ïë
    // ‚ïë  TOOLS ................ render_ui, javascript_eval, storage, fetch       ‚ïë
    // ‚ïë  AGENT MESH ........... P2P messaging, processIncomingCommand            ‚ïë
    // ‚ïë  MESH TOOLS ........... invoke_agent, broadcast, list_agents             ‚ïë
    // ‚ïë  SELF-MODIFICATION .... create_tool, update_self, custom tools           ‚ïë
    // ‚ïë  PIPELINE TOOLS ....... create_pipeline, add_task, update_task_status    ‚ïë
    // ‚ïë  SANDBOX TOOLS ........ sandbox_create, sandbox_update, preview mode     ‚ïë
    // ‚ïë  HOOKS ................ InterruptHook, SummarizingManager                ‚ïë
    // ‚ïë  GITHUB ............... github auth, search, read, create PR             ‚ïë
    // ‚ïë  AGENT MANAGEMENT ..... createAgent, updateAgentUI, selectAgent          ‚ïë
    // ‚ïë  MESSAGING ............ runAgentMessage, sendMessage, clearChat          ‚ïë
    // ‚ïë  TRANSCRIPT ........... transcriptPushText, transcriptFullText helpers   ‚ïë
    // ‚ïë  ACTIVITY FEED ........ appendActivityFeed, filterActivityFeed           ‚ïë
    // ‚ïë  UI RENDERING ......... addMessageToUI, streaming, tool calls, ring      ‚ïë
    // ‚ïë  MODALS ............... spawn, edit, settings                            ‚ïë
    // ‚ïë  SYNC ................. encrypted export/import via URL                  ‚ïë
    // ‚ïë  PERSISTENCE .......... saveState, loadState, credentials               ‚ïë
    // ‚ïë  CUSTOM TOOLS UI ...... tool management panel                           ‚ïë
    // ‚ïë  INIT ................. DOMContentLoaded, query params, startup          ‚ïë
    // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const state = {
        agents: new Map(),          // agentId -> { agent, model, config, messages, status }
        activeAgentId: null,
        ringBuffer: [],             // Shared context
        schedules: new Map(),       // scheduleId -> { name, agentId, prompt, type, cron/delay, timer }
        credentials: {
            anthropic: { apiKey: '', model: 'claude-opus-4-6' },
            openai: { apiKey: '', model: 'gpt-5.2-2025-12-11' },
            bedrock: { apiKey: '', region: 'us-east-1', model: 'global.anthropic.claude-opus-4-6-v1' },
            github: { token: '' }
        },
        agentColors: ['#00ff88', '#00aaff', '#ff88ff', '#ffaa00', '#ff6666', '#88ffff'],
        colorIndex: 0
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PIPELINE MODEL ‚Äî getPipelines, topoSort, renderPipelineFlow, updatePipelineUI
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const TASK_COLORS = { requirements:'#00ff88', planning:'#9966ff', coding:'#ff8800', testing:'#00cccc', review:'#00ff88', pr:'#00ff88', docs:'#00ff88', custom:'#ffaa00' };

    function getPipelines() { try { return JSON.parse(localStorage.getItem('agi_pipelines') || '{}'); } catch { return {}; } }
    function savePipelines(p) { localStorage.setItem('agi_pipelines', JSON.stringify(p)); }
    function getActivePipeline(pipelines) { const p = pipelines || getPipelines(); const keys = Object.keys(p); return keys.length ? p[keys[keys.length - 1]] : null; }

    function getReadyTasks(pipeline) {
        return pipeline.tasks.filter(t => t.status === 'pending' && t.dependsOn.every(d => pipeline.tasks.find(x => x.id === d)?.status === 'done'));
    }

    function topoSort(tasks) {
        const visited = new Set(), result = [], taskMap = Object.fromEntries(tasks.map(t => [t.id, t]));
        function visit(id) { if (visited.has(id)) return; visited.add(id); const t = taskMap[id]; if (t) { t.dependsOn.forEach(visit); result.push(t); } }
        tasks.forEach(t => visit(t.id));
        return result;
    }

    function renderPipelinePills(pipeline) {
        const el = document.getElementById('pipelinePills');
        if (!pipeline) { el.innerHTML = ''; return; }
        el.innerHTML = '';
        topoSort(pipeline.tasks).forEach((task, i) => {
            if (i > 0) { const c = document.createElement('span'); c.className = 'phase-connector'; el.appendChild(c); }
            const pill = document.createElement('span');
            pill.className = `phase-pill phase-${task.status}`;
            if (task.status === 'working') pill.style.setProperty('--task-color', task.color || TASK_COLORS.custom);
            pill.textContent = task.name;
            pill.onclick = () => { const h = document.querySelector(`[data-task-id="${task.id}"]`); if (h) h.scrollIntoView({ behavior: 'smooth' }); };
            el.appendChild(pill);
        });
    }

    function renderPipelineActivity() {
        const pipeline = getActivePipeline();
        const log = document.getElementById('activityLog');
        if (!pipeline) { log.innerHTML = '<div class="pipeline-empty">No active pipeline. Agents will create one for complex tasks.</div>'; return; }
        log.innerHTML = '';
        const active = pipeline.tasks.filter(t => t.activities && t.activities.length > 0).sort((a, b) => a.activities[0].ts - b.activities[0].ts);
        active.forEach(task => {
            const h = document.createElement('div');
            h.className = 'activity-heading'; h.dataset.taskId = task.id;
            h.style.color = task.status === 'done' ? '#00ff88' : (task.color || '#ccc');
            h.textContent = task.name;
            log.appendChild(h);
            task.activities.forEach(a => {
                const line = document.createElement('div');
                line.className = 'activity-line';
                if (a.done) { line.style.color = '#00ff88'; line.textContent = a.text + ' ‚úì'; }
                else { line.textContent = a.text; }
                log.appendChild(line);
            });
        });
        log.scrollTop = log.scrollHeight;
        renderCompletionCards(pipeline);
    }

    function renderCompletionCards(pipeline) {
        const el = document.getElementById('completionCards');
        if (!pipeline.completionActions || !pipeline.completionActions.length) { el.style.display = 'none'; return; }
        el.style.display = 'flex'; el.innerHTML = '';
        pipeline.completionActions.forEach(a => {
            const card = document.createElement('a');
            card.className = 'completion-card'; card.href = a.url || '#'; card.target = '_blank';
            card.innerHTML = `<strong>${a.label}</strong><span>${a.description || ''}</span>`;
            el.appendChild(card);
        });
    }

    function updatePipelineUI() { const p = getActivePipeline(); renderPipelinePills(p); renderPipelineActivity(); renderPipelineFlow(p); }

    function renderPipelineFlow(pipeline) {
        const el = document.getElementById('pipelineFlow');
        if (!pipeline || !pipeline.tasks.length) { el.classList.remove('active'); el.innerHTML = ''; return; }
        el.classList.add('active');
        const sorted = topoSort(pipeline.tasks);
        const idxMap = {}; sorted.forEach((t, i) => idxMap[t.id] = i);
        const inner = document.createElement('div');
        inner.className = 'pipeline-flow-inner';
        // Clear button
        const clearBtn = document.createElement('span');
        clearBtn.textContent = '√ó';
        clearBtn.style.cssText = 'cursor:pointer;color:#666;font-size:16px;margin-right:8px;flex-shrink:0;';
        clearBtn.onclick = () => { localStorage.removeItem('agi_pipelines'); updatePipelineUI(); updateActivityFilterOptions(); const sel = document.getElementById('activityFilter'); if (sel) sel.value = 'all'; filterActivityFeed(); };
        inner.appendChild(clearBtn);
        const nodeEls = [];
        sorted.forEach((task, i) => {
            if (i > 0) {
                const edge = document.createElement('span');
                edge.className = 'pf-edge' + (task.status === 'done' || task.status === 'success' ? ' done' : task.status === 'working' ? ' working' : task.status === 'error' || task.status === 'failed' ? ' error' : '');
                inner.appendChild(edge);
            }
            const node = document.createElement('span');
            node.className = 'pf-node ' + task.status;
            node.dataset.taskId = task.id;
            node.style.cursor = 'pointer';
            if (task.status === 'working') node.style.setProperty('--task-color', task.color || '#ffaa00');
            const label = document.createElement('span');
            label.textContent = task.name.split(' ‚Äî ')[0].split(' - ')[0];
            node.appendChild(label);
            node.onclick = () => {
                const sel = document.getElementById('activityFilter');
                // Add task option if not present
                if (!sel.querySelector(`option[value="task:${task.id}"]`)) {
                    sel.add(new Option(task.name.split(' ‚Äî ')[0], 'task:' + task.id));
                }
                sel.value = 'task:' + task.id;
                filterActivityFeed();
            };
            inner.appendChild(node);
            nodeEls.push(node);
        });
        el.innerHTML = '';
        el.appendChild(inner);
        // Scroll active (working/pending) box into view, prefer working
        requestAnimationFrame(() => {
            const target = inner.querySelector('.pf-node.working') || inner.querySelector('.pf-node.partial') || inner.querySelector('.pf-node.pending');
            if (target) target.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
        });
        // Draw back-lines for deps that go backward (iteration)
        requestAnimationFrame(() => {
            sorted.forEach((task, i) => {
                task.dependsOn.forEach(depId => {
                    const di = idxMap[depId];
                    if (di !== undefined && di > i) {
                        const from = nodeEls[i], to = nodeEls[di];
                        if (!from || !to) return;
                        const pr = inner.getBoundingClientRect(), fr = from.getBoundingClientRect(), tr = to.getBoundingClientRect();
                        const line = document.createElement('div');
                        line.className = 'pf-back';
                        line.style.left = (fr.left - pr.left + fr.width / 2) + 'px';
                        line.style.width = (tr.left - fr.left) + 'px';
                        line.style.top = (fr.bottom - pr.top + 2) + 'px';
                        line.style.height = '10px';
                        line.style.borderTop = 'none';
                        inner.appendChild(line);
                    }
                });
            });
        });
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODEL PROVIDERS ‚Äî AnthropicModel, OpenAIModel, BedrockModel, createModel
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    class AnthropicModel extends Model {
        constructor(config) {
            super();
            this.config = config;
        }
        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens, additionalRequestFields } = this.config;
            if (!apiKey) throw new Error('Anthropic API key not set');
            
            const anthropicMessages = messages.map(msg => {
                const content = msg.content.map(b => {
                    if (b.type === 'textBlock') {
                        // Skip empty text blocks
                        if (!b.text || b.text.trim() === '') return null;
                        return { type: 'text', text: b.text };
                    }
                    if (b.type === 'toolUseBlock') return { type: 'tool_use', id: b.toolUseId, name: b.name, input: b.input };
                    if (b.type === 'toolResultBlock') {
                        const resultContent = b.content.map(c => {
                            if (c.type === 'textBlock') {
                                if (!c.text || c.text.trim() === '') return null;
                                return { type: 'text', text: c.text };
                            }
                            return { type: 'text', text: JSON.stringify(c.json || c) };
                        }).filter(Boolean);
                        if (resultContent.length === 0) resultContent.push({ type: 'text', text: '(empty result)' });
                        return { type: 'tool_result', tool_use_id: b.toolUseId, content: resultContent };
                    }
                    const str = String(b);
                    if (!str || str.trim() === '') return null;
                    return { type: 'text', text: str };
                }).filter(Boolean);
                // Ensure message has at least some content
                if (content.length === 0) {
                    content.push({ type: 'text', text: '(continue)' });
                }
                return { role: msg.role, content };
            });
            
            const body = { model: modelId, max_tokens: maxTokens, messages: anthropicMessages, stream: true };
            if (options?.systemPrompt) body.system = typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.filter(b => b.type === 'textBlock').map(b => b.text).join('\n');
            if (options?.toolSpecs?.length) body.tools = options.toolSpecs.map(s => ({ name: s.name, description: s.description, input_schema: s.inputSchema }));
            
            // Add additional request fields (thinking, betas, etc.)
            if (additionalRequestFields) {
                Object.assign(body, additionalRequestFields);
            }
            
            const headers = { 
                'Content-Type': 'application/json', 
                'x-api-key': apiKey, 
                'anthropic-version': '2023-06-01', 
                'anthropic-dangerous-direct-browser-access': 'true' 
            };
            
            // Add beta header if specified
            if (additionalRequestFields?.anthropic_beta) {
                headers['anthropic-beta'] = Array.isArray(additionalRequestFields.anthropic_beta) 
                    ? additionalRequestFields.anthropic_beta.join(',') 
                    : additionalRequestFields.anthropic_beta;
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers,
                body: JSON.stringify(body)
            });
            if (!response.ok) throw new Error(`Anthropic error: ${await response.text()}`);
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                    if (!line.startsWith('data: ')) continue;
                    try {
                        const event = JSON.parse(line.slice(6));
                        if (event.type === 'message_start') yield { type: 'modelMessageStartEvent', role: 'assistant' };
                        else if (event.type === 'content_block_start') {
                            if (event.content_block?.type === 'tool_use') yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', name: event.content_block.name, toolUseId: event.content_block.id } };
                            else yield { type: 'modelContentBlockStartEvent' };
                        }
                        else if (event.type === 'content_block_delta') {
                            if (event.delta?.type === 'text_delta') yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: event.delta.text } };
                            else if (event.delta?.type === 'input_json_delta') yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: event.delta.partial_json } };
                        }
                        else if (event.type === 'content_block_stop') yield { type: 'modelContentBlockStopEvent' };
                        else if (event.type === 'message_delta') {
                            if (event.delta?.stop_reason) {
                                const map = { 'tool_use': 'toolUse', 'max_tokens': 'maxTokens', 'stop_sequence': 'stopSequence' };
                                yield { type: 'modelMessageStopEvent', stopReason: map[event.delta.stop_reason] || 'endTurn' };
                            }
                        }
                    } catch {}
                }
            }
        }
    }
    
    class OpenAIModel extends Model {
        constructor(config) {
            super();
            this.config = config;
        }
        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens } = this.config;
            if (!apiKey) throw new Error('OpenAI API key not set');
            
            const openaiMessages = [];
            if (options?.systemPrompt) {
                const text = typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.filter(b => b.type === 'textBlock').map(b => b.text).join('\n');
                if (text) openaiMessages.push({ role: 'system', content: text });
            }
            
            for (const msg of messages) {
                if (msg.role === 'user') {
                    const toolResults = msg.content.filter(b => b.type === 'toolResultBlock');
                    const other = msg.content.filter(b => b.type !== 'toolResultBlock');
                    if (other.length) openaiMessages.push({ role: 'user', content: other.map(b => b.type === 'textBlock' ? { type: 'text', text: b.text } : { type: 'text', text: String(b) }) });
                    for (const tr of toolResults) openaiMessages.push({ role: 'tool', tool_call_id: tr.toolUseId, content: tr.content.map(c => c.type === 'textBlock' ? c.text : JSON.stringify(c.json || c)).join('') });
                } else {
                    const toolCalls = [];
                    const texts = [];
                    for (const b of msg.content) {
                        if (b.type === 'textBlock') texts.push(b.text);
                        else if (b.type === 'toolUseBlock') toolCalls.push({ id: b.toolUseId, type: 'function', function: { name: b.name, arguments: JSON.stringify(b.input) } });
                    }
                    const m = { role: 'assistant', content: texts.join('') };
                    if (toolCalls.length) m.tool_calls = toolCalls;
                    openaiMessages.push(m);
                }
            }
            
            const body = { model: modelId, max_completion_tokens: maxTokens, messages: openaiMessages, stream: true, stream_options: { include_usage: true } };
            if (options?.toolSpecs?.length) body.tools = options.toolSpecs.map(s => ({ type: 'function', function: { name: s.name, description: s.description, parameters: s.inputSchema } }));
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(body)
            });
            if (!response.ok) throw new Error(`OpenAI error: ${await response.text()}`);
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let started = false;
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                    if (!line.startsWith('data: ') || line === 'data: [DONE]') continue;
                    try {
                        const chunk = JSON.parse(line.slice(6));
                        if (!chunk.choices?.length) continue;
                        const choice = chunk.choices[0];
                        const delta = choice.delta;
                        
                        if (delta?.role && !started) { started = true; yield { type: 'modelMessageStartEvent', role: delta.role }; }
                        if (delta?.content) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: delta.content } };
                        if (delta?.tool_calls) {
                            for (const tc of delta.tool_calls) {
                                if (tc.id && tc.function?.name) yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', name: tc.function.name, toolUseId: tc.id } };
                                if (tc.function?.arguments) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: tc.function.arguments } };
                            }
                        }
                        if (choice.finish_reason) {
                            yield { type: 'modelContentBlockStopEvent' };
                            const map = { 'stop': 'endTurn', 'tool_calls': 'toolUse', 'length': 'maxTokens' };
                            yield { type: 'modelMessageStopEvent', stopReason: map[choice.finish_reason] || 'endTurn' };
                        }
                    } catch {}
                }
            }
        }
    }
    
    
    function createModel(provider, customConfig = {}) {
        const creds = state.credentials[provider];
        const modelId = customConfig.modelId || creds?.model || DEFAULT_MODELS[provider];
        const catalogFlags = getModelFlags(provider, modelId);
        const additionalFields = customConfig.additionalRequestFields ?? catalogFlags ?? (provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null);
        if (provider === 'anthropic') {
            return new AnthropicModel({
                apiKey: creds.apiKey,
                modelId,
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: additionalFields
            });
        } else if (provider === 'openai') {
            return new OpenAIModel({
                apiKey: creds.apiKey,
                modelId,
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS
            });
        } else if (provider === 'bedrock') {
            return new BedrockModel({
                apiKey: creds.apiKey,
                region: creds.region || 'us-east-1',
                modelId,
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: additionalFields
            });
        }
        throw new Error(`Unknown provider: ${provider}`);
    }
    
    // Default models per provider
    const DEFAULT_MODELS = {
        bedrock: 'global.anthropic.claude-opus-4-6-v1',
        anthropic: 'claude-opus-4-6',
        openai: 'gpt-5.2-2025-12-11'
    };
    
    // Model catalog: autocomplete + per-model feature flags
    const MODEL_CATALOG = {
        bedrock: [
            { id: 'global.anthropic.claude-opus-4-6-v1', name: 'Opus 4.6 (Global)', flags: { thinking: { type: 'adaptive' } } },
            { id: 'us.anthropic.claude-opus-4-6-v1', name: 'Opus 4.6 (US)', flags: { thinking: { type: 'adaptive' } } },
            { id: 'eu.anthropic.claude-opus-4-6-v1', name: 'Opus 4.6 (EU)', flags: { thinking: { type: 'adaptive' } } },
            { id: 'apac.anthropic.claude-opus-4-6-v1', name: 'Opus 4.6 (APAC)', flags: { thinking: { type: 'adaptive' } } },
            { id: 'global.anthropic.claude-sonnet-4-5-20250929-v1:0', name: 'Sonnet 4.5 (Global)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'us.anthropic.claude-sonnet-4-5-20250929-v1:0', name: 'Sonnet 4.5 (US)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'eu.anthropic.claude-sonnet-4-5-20250929-v1:0', name: 'Sonnet 4.5 (EU)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'apac.anthropic.claude-sonnet-4-5-20250929-v1:0', name: 'Sonnet 4.5 (APAC)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'global.anthropic.claude-sonnet-4-20250514-v1:0', name: 'Sonnet 4 (Global)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'us.anthropic.claude-sonnet-4-20250514-v1:0', name: 'Sonnet 4 (US)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'eu.anthropic.claude-sonnet-4-20250514-v1:0', name: 'Sonnet 4 (EU)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'apac.anthropic.claude-sonnet-4-20250514-v1:0', name: 'Sonnet 4 (APAC)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'global.anthropic.claude-opus-4-5-20251101-v1:0', name: 'Opus 4.5 (Global)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'us.anthropic.claude-opus-4-5-20251101-v1:0', name: 'Opus 4.5 (US)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'global.anthropic.claude-opus-4-20250514-v1:0', name: 'Opus 4 (Global)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'us.anthropic.claude-opus-4-20250514-v1:0', name: 'Opus 4 (US)', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'global.anthropic.claude-haiku-4-5-20251001-v1:0', name: 'Haiku 4.5 (Global)', flags: { thinking: { type: 'enabled', budget_tokens: 5000 } } },
            { id: 'us.anthropic.claude-haiku-4-5-20251001-v1:0', name: 'Haiku 4.5 (US)', flags: { thinking: { type: 'enabled', budget_tokens: 5000 } } },
        ],
        anthropic: [
            { id: 'claude-opus-4-6', name: 'Opus 4.6', flags: { thinking: { type: 'adaptive' } } },
            { id: 'claude-sonnet-4-5-20250929', name: 'Sonnet 4.5', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'claude-sonnet-4-20250514', name: 'Sonnet 4', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'claude-opus-4-5-20251101', name: 'Opus 4.5', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'claude-opus-4-20250514', name: 'Opus 4', flags: { thinking: { type: 'enabled', budget_tokens: 10000 } } },
            { id: 'claude-haiku-4-5-20251001', name: 'Haiku 4.5', flags: { thinking: { type: 'enabled', budget_tokens: 5000 } } },
        ],
        openai: [
            { id: 'gpt-5.2-2025-12-11', name: 'GPT-5.2' },
            { id: 'gpt-5-2025-04-14', name: 'GPT-5' },
            { id: 'o3-2025-04-16', name: 'o3 (Reasoning)' },
            { id: 'o4-mini-2025-04-16', name: 'o4-mini (Reasoning)' },
            { id: 'gpt-4.1-2025-04-14', name: 'GPT-4.1' },
        ]
    };

    function getModelFlags(provider, modelId) {
        return (MODEL_CATALOG[provider] || []).find(m => m.id === modelId)?.flags || null;
    }

    function updateModelDatalist(provider, datalistId) {
        let dl = document.getElementById(datalistId);
        if (!dl) { dl = document.createElement('datalist'); dl.id = datalistId; document.body.appendChild(dl); }
        dl.innerHTML = (MODEL_CATALOG[provider] || []).map(m => `<option value="${m.id}" label="${m.name}">`).join('');
    }

    // Default additional request fields for bedrock (extended thinking)
    const DEFAULT_BEDROCK_ADDITIONAL_FIELDS = {
        "thinking": {"type": "adaptive"}
    };
    
    const DEFAULT_MAX_TOKENS = 60000;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOOLS ‚Äî render_ui, javascript_eval, storage, fetch, notify, use_agent, scheduler
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const renderUiTool = tool({
        name: 'render_ui',
        description: 'Render HTML/CSS/JS in the chat',
        inputSchema: z.object({ html: z.string(), css: z.string().optional(), script: z.string().optional(), title: z.string().optional() }),
        callback: async (input) => {
            const container = document.createElement('div');
            container.className = 'dynamic-ui';
            if (input.title) container.innerHTML = `<div style="font-size:11px;color:var(--text-tertiary);margin-bottom:12px;text-transform:uppercase;letter-spacing:0.05em;">${input.title}</div>`;
            if (input.css) container.innerHTML += `<style>${input.css}</style>`;
            container.innerHTML += input.html;
            document.getElementById('messagesInner').appendChild(container);
            scrollToBottom();
            if (input.script) { try { new Function(input.script).call(container); } catch (e) { return { error: e.message }; } }
            return { rendered: true };
        }
    });
    
    const javascriptEvalTool = tool({
        name: 'javascript_eval',
        description: 'Execute JavaScript',
        inputSchema: z.object({ code: z.string() }),
        callback: async (input) => { try { return { result: String(eval(input.code)) }; } catch (e) { return { error: e.message }; } }
    });
    
    const storageGetTool = tool({
        name: 'storage_get',
        description: 'Get localStorage value',
        inputSchema: z.object({ key: z.string() }),
        callback: async (input) => ({ key: input.key, value: localStorage.getItem(input.key) })
    });
    
    const storageSetTool = tool({
        name: 'storage_set',
        description: 'Set localStorage value',
        inputSchema: z.object({ key: z.string(), value: z.string() }),
        callback: async (input) => { localStorage.setItem(input.key, input.value); return { success: true }; }
    });
    
    const fetchUrlTool = tool({
        name: 'fetch_url',
        description: 'HTTP request',
        inputSchema: z.object({ url: z.string(), method: z.string().optional(), headers: z.record(z.string(), z.string()).optional(), body: z.string().optional() }),
        callback: async (input) => {
            try {
                const r = await fetch(input.url, { method: input.method || 'GET', headers: input.headers, body: input.body });
                const ct = r.headers.get('content-type');
                const data = ct?.includes('json') ? await r.json() : await r.text();
                return { status: r.status, data };
            } catch (e) { return { error: e.message }; }
        }
    });
    
    const notifyTool = tool({
        name: 'notify',
        description: 'Send browser notification',
        inputSchema: z.object({ title: z.string(), body: z.string() }),
        callback: async (input) => {
            if (Notification.permission === 'granted') {
                new Notification(input.title, { body: input.body });
                return { success: true };
            }
            return { error: 'Notifications not permitted' };
        }
    });
    
    // use_agent - spawn sub-agent
    const useAgentTool = tool({
        name: 'use_agent',
        description: 'Create a sub-agent to handle a specific task. The sub-agent runs asynchronously.',
        inputSchema: z.object({
            agentId: z.string().describe('Unique ID for the sub-agent'),
            provider: z.enum(['anthropic', 'openai', 'bedrock']).describe('Model provider'),
            systemPrompt: z.string().describe('System prompt for sub-agent'),
            prompt: z.string().describe('Initial prompt to send'),
            maxTokens: z.number().optional()
        }),
        callback: async (input) => {
            try {
                // Check if agent already exists
                if (state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} already exists` };
                }
                
                // Create sub-agent with default bedrock settings if using bedrock
                const modelConfig = { 
                    maxTokens: input.maxTokens || DEFAULT_MAX_TOKENS 
                };
                if (input.provider === 'bedrock') {
                    modelConfig.additionalRequestFields = DEFAULT_BEDROCK_ADDITIONAL_FIELDS;
                }
                const model = createModel(input.provider, modelConfig);
                
                const subAgent = new Agent({
                    model,
                    tools: [renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool],
                    systemPrompt: input.systemPrompt,
                    printer: false
                });
                
                const color = state.agentColors[state.colorIndex % state.agentColors.length];
                state.colorIndex++;
                
                state.agents.set(input.agentId, {
                    agent: subAgent,
                    model,
                    config: { 
                        provider: input.provider, 
                        systemPrompt: input.systemPrompt, 
                        maxTokens: input.maxTokens || DEFAULT_MAX_TOKENS,
                        additionalRequestFields: input.provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
                    },
                    messages: [],
                    status: 'ready',
                    color
                });
                
                updateAgentUI();
                
                // Run prompt asynchronously
                setTimeout(() => runAgentMessage(input.agentId, input.prompt), 0);
                
                return { success: true, agentId: input.agentId, message: 'Sub-agent spawned and processing prompt' };
            } catch (e) {
                return { error: e.message };
            }
        }
    });
    
    // scheduler - schedule tasks
    const schedulerTool = tool({
        name: 'scheduler',
        description: 'Schedule a task to run once or on a recurring basis (cron pattern)',
        inputSchema: z.object({
            action: z.enum(['create', 'list', 'delete']),
            name: z.string().optional().describe('Task name'),
            agentId: z.string().optional().describe('Agent to run the task'),
            prompt: z.string().optional().describe('Prompt for the agent'),
            type: z.enum(['once', 'cron']).optional(),
            delay: z.number().optional().describe('Delay in seconds for once'),
            cron: z.string().optional().describe('Cron expression for recurring')
        }),
        callback: async (input) => {
            if (input.action === 'list') {
                const schedules = [];
                for (const [id, s] of state.schedules) {
                    schedules.push({ id, name: s.name, agentId: s.agentId, type: s.type, cron: s.cron, delay: s.delay });
                }
                return { schedules };
            }
            
            if (input.action === 'delete') {
                if (!input.name) return { error: 'Name required for delete' };
                for (const [id, s] of state.schedules) {
                    if (s.name === input.name) {
                        if (s.timer) clearTimeout(s.timer);
                        if (s.interval) clearInterval(s.interval);
                        state.schedules.delete(id);
                        updateScheduleUI();
                        return { success: true, deleted: input.name };
                    }
                }
                return { error: 'Schedule not found' };
            }
            
            if (input.action === 'create') {
                if (!input.name || !input.agentId || !input.prompt || !input.type) {
                    return { error: 'name, agentId, prompt, and type required' };
                }
                if (!state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} not found` };
                }
                
                const id = `schedule-${Date.now()}`;
                const schedule = {
                    name: input.name,
                    agentId: input.agentId,
                    prompt: input.prompt,
                    type: input.type,
                    delay: input.delay,
                    cron: input.cron
                };
                
                if (input.type === 'once') {
                    const delayMs = (input.delay || 60) * 1000;
                    schedule.timer = setTimeout(() => {
                        runAgentMessage(input.agentId, input.prompt);
                        state.schedules.delete(id);
                        updateScheduleUI();
                    }, delayMs);
                    schedule.runAt = new Date(Date.now() + delayMs).toISOString();
                } else if (input.type === 'cron') {
                    // Simple cron parser for common patterns
                    const cronParts = (input.cron || '* * * * *').split(' ');
                    const minute = cronParts[0];
                    
                    // Parse interval from cron (simplified)
                    let intervalMs = 60000; // default 1 minute
                    if (minute.startsWith('*/')) {
                        intervalMs = parseInt(minute.slice(2)) * 60000;
                    }
                    
                    schedule.interval = setInterval(() => {
                        runAgentMessage(input.agentId, input.prompt);
                    }, intervalMs);
                    schedule.nextRun = new Date(Date.now() + intervalMs).toISOString();
                }
                
                state.schedules.set(id, schedule);
                updateScheduleUI();
                saveState();
                
                return { success: true, scheduleId: id, name: input.name, type: input.type };
            }
            
            return { error: 'Invalid action' };
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MESH ‚Äî P2P messaging, processIncomingCommand, sendTo
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const agentMesh = {
        // Local mesh (same-origin tabs)
        bus: new BroadcastChannel('agi-mesh'),
        
        // Remote mesh (WebSocket relay)
        ws: null,
        wsConnected: false,
        instanceId: localStorage.getItem('mesh_instance_id') || `agi-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,6)}`,
        remotePeers: new Map(), // instanceId -> { agents: [], lastSeen, hostname }
        heartbeatInterval: null,
        
        // Shared state
        pendingRequests: new Map(),
        messageLog: [],
        
        init() {
            // Save instance ID
            localStorage.setItem('mesh_instance_id', this.instanceId);
            
            // Local mesh
            this.bus.onmessage = (e) => this.handleMessage(e.data, 'local');
            
            // Auto-connect if relay URL saved
            const savedRelay = localStorage.getItem('mesh_relay_url');
            if (savedRelay) {
                setTimeout(() => this.connectRelay(savedRelay), 1000);
            }
            
            console.log(`üîó Agent mesh initialized (instance: ${this.instanceId})`);
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // WebSocket Relay Connection
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        connectRelay(url) {
            if (this.ws) this.disconnectRelay();
            
            try {
                this.ws = new WebSocket(url);
                
                this.ws.onopen = () => {
                    this.wsConnected = true;
                    console.log('üåê WebSocket relay connected');
                    this.updateWsStatus(true);
                    
                    // Send presence announcement
                    this.sendRemote({
                        type: 'presence',
                        from: this.instanceId,
                        data: {
                            agents: [...state.agents.keys()],
                            hostname: location.hostname,
                            timestamp: Date.now()
                        }
                    });
                    
                    // Start heartbeat
                    this.heartbeatInterval = setInterval(() => {
                        if (this.wsConnected) {
                            this.sendRemote({
                                type: 'heartbeat',
                                from: this.instanceId,
                                data: { agents: [...state.agents.keys()], timestamp: Date.now() }
                            });
                            // Clean stale peers (no heartbeat in 30s)
                            const now = Date.now();
                            for (const [id, peer] of this.remotePeers) {
                                if (now - peer.lastSeen > 30000) {
                                    this.remotePeers.delete(id);
                                }
                            }
                            this.updateRemotePeersUI();
                        }
                    }, 10000);
                    
                    localStorage.setItem('mesh_relay_url', url);
                    showToast('Relay connected');
                };
                
                this.ws.onmessage = (e) => {
                    try {
                        const msg = JSON.parse(e.data);
                        if (msg.from !== this.instanceId) {
                            this.handleMessage(msg, 'remote');
                        }
                    } catch (err) {
                        console.warn('Invalid relay message:', err);
                    }
                };
                
                this.ws.onclose = () => {
                    this.wsConnected = false;
                    this.updateWsStatus(false);
                    if (this.heartbeatInterval) {
                        clearInterval(this.heartbeatInterval);
                        this.heartbeatInterval = null;
                    }
                    console.log('üåê WebSocket relay disconnected');
                };
                
                this.ws.onerror = (err) => {
                    console.error('WebSocket error:', err);
                    showToast('Relay connection failed');
                };
                
            } catch (err) {
                console.error('Failed to connect relay:', err);
                showToast('Invalid relay URL');
            }
        },
        
        disconnectRelay() {
            if (this.ws) {
                this.ws.close();
                this.ws = null;
            }
            this.wsConnected = false;
            this.remotePeers.clear();
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
                this.heartbeatInterval = null;
            }
            this.updateWsStatus(false);
            this.updateRemotePeersUI();
            showToast('Relay disconnected');
        },
        
        sendRemote(msg) {
            if (this.ws && this.wsConnected) {
                this.ws.send(JSON.stringify(msg));
            }
        },
        
        updateWsStatus(connected) {
            const el = document.getElementById('wsStatus');
            if (el) {
                el.innerHTML = connected 
                    ? '<span style="color:#0f0">‚óè Connected</span>'
                    : '<span style="color:#f66">‚óè Disconnected</span>';
            }
        },
        
        updateRemotePeersUI() {
            const el = document.getElementById('remotePeersList');
            if (!el) return;
            
            if (this.remotePeers.size === 0) {
                el.innerHTML = 'No remote peers connected';
                return;
            }
            
            const peerHtml = [...this.remotePeers.entries()].map(([id, peer]) => {
                const agentCount = peer.agents?.length || 0;
                const age = Math.round((Date.now() - peer.lastSeen) / 1000);
                return `<div style="margin-bottom:4px;">
                    <span style="color:#0f0">‚óè</span> ${id.slice(0,12)}... 
                    <span style="color:var(--text-tertiary)">(${agentCount} agents, ${age}s ago)</span>
                </div>`;
            }).join('');
            
            el.innerHTML = peerHtml;
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Message Handling (both local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        handleMessage(msg, source) {
            const { type, from, to, turnId, data, timestamp } = msg;
            
            // Log for watching
            this.messageLog.push({ type, from, to, turnId, source, data: typeof data === 'string' ? data.slice(0, 100) : data, timestamp });
            if (this.messageLog.length > 200) this.messageLog.shift();
            updateMeshLog();
            
            // Handle presence/heartbeat from remote peers
            if ((type === 'presence' || type === 'heartbeat') && source === 'remote') {
                this.remotePeers.set(from, {
                    agents: data.agents || [],
                    hostname: data.hostname || 'unknown',
                    lastSeen: Date.now()
                });
                this.updateRemotePeersUI();
                return;
            }
            
            // Handle broadcast command
            if (type === 'broadcast' || type === 'direct') {
                // Skip if from ourselves (same instance) - only for remote messages
                if (source === 'remote' && from === this.instanceId) return;
                
                // Process with local agents
                for (const [agentId, agentData] of state.agents) {
                    // For direct messages, only process the target agent
                    if (type === 'direct' && agentId !== to) continue;
                    // Never let an agent process its own message
                    if (from === agentId) continue;
                    
                    this.processIncomingCommand(agentId, from, turnId, data.command, source);
                }
                return;
            }
            
            // Handle response streams
            if (type === 'stream' || type === 'ack' || type === 'turn_end' || type === 'error') {
                const pending = this.pendingRequests.get(turnId);
                if (!pending) return;
                
                if (type === 'stream') {
                    if (!pending.streamed[from]) pending.streamed[from] = '';
                    pending.streamed[from] += data.chunk;
                    updateStreamingResponse(turnId, from, pending.streamed[from]);
                }
                else if (type === 'ack') {
                    addMeshEvent(from, 'Processing...', 'ack');
                }
                else if (type === 'turn_end') {
                    pending.responses.push({ from, result: data.result, lastResponse: data.lastResponse, transcript: data.transcript, chunks: data.chunks });
                    pending.completed++;
                    if (pending.completed >= pending.expected || pending.timeout) {
                        pending.resolve(pending);
                    }
                }
                else if (type === 'error') {
                    pending.responses.push({ from, error: data.error });
                    pending.completed++;
                }
            }
        },
        
        async processIncomingCommand(agentId, fromId, turnId, command, source) {
            const agentData = state.agents.get(agentId);
            if (!agentData) return;
            
            // Send ACK
            this.publish({ type: 'ack', from: agentId, to: fromId, turnId, timestamp: Date.now() });
            
            agentData.status = 'processing';
            updateAgentUI();
            
            try {
                const transcript = [];
                let chunkCount = 0;
                
                const sourceLabel = source === 'remote' ? `[Remote: ${fromId}]` : `[From agent ${fromId}]`;
                
                for await (const event of agentData.agent.stream(`${sourceLabel}: ${command}`)) {
                    if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                        transcriptPushText(transcript, event.delta.text);
                        chunkCount++;
                        this.publish({
                            type: 'stream',
                            from: agentId,
                            to: fromId,
                            turnId,
                            data: { chunk: event.delta.text, chunkNum: chunkCount },
                            timestamp: Date.now()
                        });
                    }
                    else if (event?.type === 'beforeToolCallEvent') {
                        const tn = event.toolUse?.name, ti = event.toolUse?.input;
                        transcript.push({ type: 'tool_use', name: tn, toolId: event.toolUse?.toolUseId, input: ti });
                        const fl = tn === 'invoke_agent' && ti?.targetAgentId ? `üîß invoke_agent ‚Üí ${ti.targetAgentId}` : `üîß ${tn}`;
                        appendActivityFeed(agentId, fl, 'tool', { input: ti });
                    }
                    else if (event?.type === 'afterToolCallEvent') {
                        transcript.push({ type: 'tool_result', name: event.toolUse?.name, toolId: event.toolUse?.toolUseId, status: event.result?.status || 'success', output: event.result });
                        const last = activityLog.findLast(e => e.type === 'tool' && e.agentId === agentId);
                        if (last && event.result) { last.extra = { ...last.extra, output: event.result }; const feed = document.getElementById('activityFeed'); if (feed) renderActivityEntry(feed, last); }
                    }
                }
                
                const fullText = transcriptFullText(transcript);
                this.publish({
                    type: 'turn_end',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { result: fullText, lastResponse: transcriptLastText(transcript), transcript, chunks: chunkCount },
                    timestamp: Date.now()
                });
                
                agentData.messages.push({ role: 'user', content: `${sourceLabel}: ${command}`, timestamp: Date.now() });
                agentData.messages.push({ role: 'assistant', transcript, content: transcriptLastText(transcript), timestamp: Date.now() });
                if (fullText) appendActivityFeed(agentId, fullText.replace(/[#*`]/g, '').substring(0, 1000));
                
                state.ringBuffer.push({ agentId, role: 'assistant', content: fullText, timestamp: Date.now() });
                if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext(agentId, 'multi', fullText.slice(0, 500));
                updateRingUI();
                
            } catch (e) {
                this.publish({
                    type: 'error',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { error: e.message },
                    timestamp: Date.now()
                });
                console.error(`Agent ${agentId} processIncomingCommand error:`, e);
                agentData.status = 'error';
                appendActivityFeed(agentId, `‚ùå Error: ${e.message}`, 'msg');
            }
            
            if (agentData.status !== 'error') agentData.status = 'ready';
            updateAgentUI();
            updatePipelineUI(); // Refresh pipeline in case tools modified it
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Publishing (bridges local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        publish(msg) {
            // Always publish to local BroadcastChannel
            this.bus.postMessage(msg);
            
            // Also publish to WebSocket relay if connected
            if (this.wsConnected) {
                this.sendRemote({ ...msg, instanceId: this.instanceId });
            }
            
            // Handle locally for same-tab agents
            setTimeout(() => this.handleMessage(msg, 'local'), 0);
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // High-level API
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        async broadcast(fromAgentId, command, waitTime = 30) {
            const turnId = crypto.randomUUID().slice(0, 8);
            
            // Count local + remote agents
            let peerCount = state.agents.size - 1;
            for (const [, peer] of this.remotePeers) {
                peerCount += peer.agents?.length || 0;
            }
            
            if (peerCount === 0) {
                return { error: 'No other agents to broadcast to' };
            }
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: peerCount,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Publish broadcast
                this.publish({
                    type: 'broadcast',
                    from: fromAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },
        
        async sendTo(fromAgentId, toAgentId, command, waitTime = 60) {
            const turnId = crypto.randomUUID().slice(0, 8);
            
            if (!state.agents.has(toAgentId)) {
                return { error: `Agent ${toAgentId} not found` };
            }
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Publish direct message
                this.publish({
                    type: 'direct',
                    from: fromAgentId,
                    to: toAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },
        
        listAgents(includeRemote = true) {
            const agents = [];
            
            // Local agents
            for (const [id, data] of state.agents) {
                agents.push({
                    id,
                    location: 'local',
                    instanceId: this.instanceId,
                    status: data.status,
                    provider: data.config.provider,
                    model: data.config.modelId || 'default',
                    messageCount: data.messages.length
                });
            }
            
            // Remote agents
            if (includeRemote) {
                for (const [instanceId, peer] of this.remotePeers) {
                    for (const agentId of peer.agents || []) {
                        agents.push({
                            id: agentId,
                            location: 'remote',
                            instanceId: instanceId,
                            hostname: peer.hostname,
                            lastSeen: peer.lastSeen
                        });
                    }
                }
            }
            
            return agents;
        },
        
        // Send to remote instance
        async sendToRemoteAgent(fromAgentId, targetInstanceId, targetAgentId, command, waitTime = 60) {
            if (!this.wsConnected) {
                return { error: 'Not connected to relay' };
            }
            
            const peer = this.remotePeers.get(targetInstanceId);
            if (!peer || !peer.agents.includes(targetAgentId)) {
                return { error: `Remote agent ${targetAgentId}@${targetInstanceId} not found` };
            }
            
            const turnId = crypto.randomUUID().slice(0, 8);
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Send direct to remote
                this.sendRemote({
                    type: 'direct',
                    from: fromAgentId,
                    to: targetAgentId,
                    instanceId: this.instanceId,
                    targetInstanceId: targetInstanceId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        }
    };
    
    // Initialize mesh
    agentMesh.init();
    
    // Mesh UI helpers
    function updateMeshLog() {
        // Update ring panel with recent mesh activity
        const recent = agentMesh.messageLog.slice(-10).reverse();
        const meshHtml = recent.map(m => {
            const icon = m.type === 'broadcast' ? 'üì¢' : m.type === 'direct' ? 'üì®' : m.type === 'stream' ? 'üì°' : m.type === 'turn_end' ? '‚úÖ' : '‚Ä¢';
            return `<div style="font-size:10px;color:var(--text-tertiary);margin-bottom:4px;">${icon} ${m.from}${m.to ? '‚Üí' + m.to : ''}: ${m.type}</div>`;
        }).join('');
        
        const meshSection = document.getElementById('meshActivity');
        if (meshSection) meshSection.innerHTML = meshHtml || '<div style="font-size:10px;color:var(--text-tertiary);">No mesh activity</div>';
    }
    
    function updateStreamingResponse(turnId, from, text) {
        // Show streaming in a special area or update existing message
        const el = document.getElementById(`mesh-stream-${turnId}-${from}`);
        if (el) {
            el.querySelector('.markdown-content').innerHTML = marked.parse(text);
        }
    }
    
    function addMeshEvent(agentId, message, type) {
        const color = state.agents.get(agentId)?.color || '#888';
        showToast(`üîó ${agentId}: ${message}`);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESH TOOLS ‚Äî invoke_agent, broadcast, list_agents
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // invoke_agent - Call another agent and get response
    const invokeAgentTool = tool({
        name: 'invoke_agent',
        description: 'Send a message to another agent and wait for their response. Use this to delegate tasks or collaborate with other agents.',
        inputSchema: z.object({
            targetAgentId: z.string().describe('ID of the agent to invoke'),
            message: z.string().describe('Message/command to send'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find which agent is calling this
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            if (!state.agents.has(input.targetAgentId)) {
                return { error: `Agent '${input.targetAgentId}' not found`, available: [...state.agents.keys()] };
            }
            
            if (input.targetAgentId === callerAgentId) {
                return { error: 'Cannot invoke yourself' };
            }
            
            const result = await agentMesh.sendTo(callerAgentId, input.targetAgentId, input.message, input.waitTime || 60);
            
            if (result.error) return { error: result.error };
            
            const response = result.responses[0];
            if (response?.error) return { error: response.error };
            
            const fullResponse = result.streamed[input.targetAgentId] || response?.result || 'No response';
            const transcript = response?.transcript;
            return {
                success: true,
                from: input.targetAgentId,
                response: transcript ? transcriptLastText(transcript) : (response?.lastResponse || fullResponse.slice(-2000)),
                chunks: response?.chunks || 0,
                toolCalls: transcript ? transcript.filter(e => e.type === 'tool_use').length : 0
            };
        }
    });
    
    // broadcast_to_agents - Send to all agents
    const broadcastToAgentsTool = tool({
        name: 'broadcast_to_agents',
        description: 'Broadcast a message to ALL other agents. Each will process and respond.',
        inputSchema: z.object({
            message: z.string().describe('Message to broadcast'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 30)')
        }),
        callback: async (input, { agent }) => {
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            const result = await agentMesh.broadcast(callerAgentId, input.message, input.waitTime || 30);
            
            if (result.error) return { error: result.error };
            
            const responses = [];
            for (const [agentId, text] of Object.entries(result.streamed)) {
                responses.push({ agentId, response: text });
            }
            for (const r of result.responses) {
                if (r.result && !result.streamed[r.from]) {
                    responses.push({ agentId: r.from, response: r.result });
                }
            }
            
            return {
                success: true,
                broadcastedTo: state.agents.size - 1,
                responses
            };
        }
    });
    
    // list_agents - See available agents (local + remote)
    const listAgentsTool = tool({
        name: 'list_agents',
        description: 'List all available agents with their roles and status. ALWAYS call this first before delegating tasks to know which agents exist and what they do.',
        inputSchema: z.object({
            includeRemote: z.boolean().optional().describe('Include remote agents from relay (default: true)')
        }),
        callback: async (input) => {
            const includeRemote = input?.includeRemote !== false;
            const agents = agentMesh.listAgents(includeRemote);
            // Enrich local agents with role info from system prompt
            for (const a of agents) {
                if (a.location === 'local') {
                    const data = state.agents.get(a.id);
                    if (data?.config?.systemPrompt) {
                        a.role = data.config.systemPrompt.substring(0, 150);
                    }
                    a.enabledTools = data?.config?.enabledTools || 'all';
                }
            }
            const localCount = agents.filter(a => a.location === 'local').length;
            const remoteCount = agents.filter(a => a.location === 'remote').length;
            return { 
                agents,
                summary: {
                    local: localCount,
                    remote: remoteCount,
                    total: agents.length,
                    relayConnected: agentMesh.wsConnected
                },
                hint: 'Use invoke_agent with targetAgentId to send tasks to these agents'
            };
        }
    });
    
    // invoke_remote_agent - Call an agent on a remote instance
    const invokeRemoteAgentTool = tool({
        name: 'invoke_remote_agent',
        description: 'Send a message to an agent running on a different browser/device via the relay server. Use list_agents to see remote agents first.',
        inputSchema: z.object({
            instanceId: z.string().describe('Remote instance ID (from list_agents)'),
            agentId: z.string().describe('Agent ID on the remote instance'),
            message: z.string().describe('Message to send'),
            waitTime: z.number().optional().describe('Seconds to wait for response (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find caller agent
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            const result = await agentMesh.sendToRemoteAgent(
                callerAgentId,
                input.instanceId,
                input.agentId,
                input.message,
                input.waitTime || 60
            );
            
            if (result.error) return { error: result.error };
            
            const response = result.responses[0];
            if (response?.error) return { error: response.error };
            
            return {
                success: true,
                from: `${input.agentId}@${input.instanceId}`,
                response: result.streamed[input.agentId] || response?.result || 'No response'
            };
        }
    });
    
    // subscribe_topic - Watch for messages on a topic
    const subscribeTopicTool = tool({
        name: 'subscribe_topic',
        description: 'Subscribe to a topic to receive messages. Creates a listener that triggers on new messages.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name to subscribe to'),
            handler: z.string().describe('JavaScript code to run when message received (receives msg parameter)')
        }),
        callback: async (input) => {
            // Store subscription
            if (!state.subscriptions) state.subscriptions = new Map();
            
            const subId = `sub-${Date.now()}`;
            state.subscriptions.set(subId, {
                topic: input.topic,
                handler: new Function('msg', input.handler)
            });
            
            return { success: true, subscriptionId: subId, topic: input.topic };
        }
    });
    
    // publish_topic - Publish to a topic
    const publishTopicTool = tool({
        name: 'publish_topic',
        description: 'Publish a message to a topic. All subscribers will receive it.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name'),
            message: z.any().describe('Message to publish (string or object)')
        }),
        callback: async (input) => {
            agentMesh.publish({
                type: 'topic',
                topic: input.topic,
                data: input.message,
                timestamp: Date.now()
            });
            
            // Notify local subscribers
            if (state.subscriptions) {
                for (const [id, sub] of state.subscriptions) {
                    if (sub.topic === input.topic) {
                        try {
                            sub.handler(input.message);
                        } catch (e) {
                            console.error(`Subscription ${id} error:`, e);
                        }
                    }
                }
            }
            
            return { success: true, topic: input.topic };
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SELF-MODIFICATION ‚Äî create_tool, update_self, custom tools
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Storage key for custom tools
    const CUSTOM_TOOLS_KEY = 'agi_multi_custom_tools';

    // Load custom tools from localStorage
    function loadCustomTools() {
        try {
            const stored = localStorage.getItem(CUSTOM_TOOLS_KEY);
            if (!stored) return {};
            return JSON.parse(stored);
        } catch (e) {
            console.warn('Failed to load custom tools:', e);
            return {};
        }
    }

    // Save custom tools to localStorage
    function saveCustomTools(tools) {
        localStorage.setItem(CUSTOM_TOOLS_KEY, JSON.stringify(tools));
    }

    // Create a tool from stored definition
    function createToolFromDefinition(name, def) {
        try {
            // Build the Zod schema from the stored schema definition
            const schemaObj = {};
            for (const [key, prop] of Object.entries(def.inputSchema.properties || {})) {
                let zodType;
                switch (prop.type) {
                    case 'number': zodType = z.number(); break;
                    case 'boolean': zodType = z.boolean(); break;
                    case 'array': zodType = z.array(z.any()); break;
                    case 'object': zodType = z.object({}).passthrough(); break;
                    default: zodType = z.string();
                }
                if (prop.description) zodType = zodType.describe(prop.description);
                if (!(def.inputSchema.required || []).includes(key)) zodType = zodType.optional();
                schemaObj[key] = zodType;
            }

            // Create the callback function from stored code
            const callbackFn = new Function('input', `
                return (async () => {
                    ${def.code}
                })();
            `);

            return tool({
                name: name,
                description: def.description,
                inputSchema: z.object(schemaObj),
                callback: callbackFn
            });
        } catch (e) {
            console.error(`Failed to create tool ${name}:`, e);
            return null;
        }
    }

    // Build all custom tools as actual tool objects
    function buildCustomTools() {
        const customToolDefs = loadCustomTools();
        const tools = [];
        for (const [name, def] of Object.entries(customToolDefs)) {
            const t = createToolFromDefinition(name, def);
            if (t) tools.push(t);
        }
        return tools;
    }

    // update_self - Update agent configuration
    const updateSelfTool = tool({
        name: 'update_self',
        description: 'Update agent configuration (system prompt, etc.)',
        inputSchema: z.object({
            section: z.enum(['system_prompt', 'config']).describe('Section'),
            content: z.string().describe('Content'),
            action: z.enum(['replace', 'append', 'prepend']).optional().describe('Action')
        }),
        callback: async (input, { agent }) => {
            const action = input.action || 'replace';
            
            // Find which agent is calling this
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            const agentData = state.agents.get(callerAgentId);
            if (!agentData) {
                return { error: 'Agent not found' };
            }
            
            if (input.section === 'system_prompt') {
                const current = agentData.config.systemPrompt || '';
                let newPrompt;
                if (action === 'append') {
                    newPrompt = current + '\n' + input.content;
                } else if (action === 'prepend') {
                    newPrompt = input.content + '\n' + current;
                } else {
                    newPrompt = input.content;
                }
                agentData.config.systemPrompt = newPrompt;
                saveState();
                return { success: true, message: `System prompt updated for agent ${callerAgentId}.` };
            }
            
            return { error: `Unknown section: ${input.section}` };
        }
    });

    // create_tool - Create new tools at runtime
    const createToolTool = tool({
        name: 'create_tool',
        description: `Create a new tool that will be available to all agents. The tool persists across sessions.
        
IMPORTANT: The 'code' parameter should be the BODY of an async function that receives 'input' as parameter.
Return a result object. You have access to: fetch, localStorage, document, console, etc.

Example - create a tool that gets weather:
{
    "name": "get_weather",
    "description": "Get weather for a city",
    "inputSchema": {
        "type": "object",
        "properties": {
            "city": { "type": "string", "description": "City name" }
        },
        "required": ["city"]
    },
    "code": "const response = await fetch('https://wttr.in/' + input.city + '?format=j1');\\nconst data = await response.json();\\nreturn { temperature: data.current_condition[0].temp_C, description: data.current_condition[0].weatherDesc[0].value };"
}`,
        inputSchema: z.object({
            name: z.string().describe('Tool name (snake_case)'),
            description: z.string().describe('What the tool does'),
            inputSchema: z.object({
                type: z.literal('object'),
                properties: z.record(z.string(), z.object({
                    type: z.string(),
                    description: z.string().optional()
                })),
                required: z.array(z.string()).optional()
            }).describe('JSON Schema for tool inputs'),
            code: z.string().describe('JavaScript code - body of async function with input parameter. Must return a result.')
        }),
        callback: async (input) => {
            try {
                // Validate the tool name
                if (!/^[a-z][a-z0-9_]*$/.test(input.name)) {
                    return { error: 'Tool name must be snake_case (lowercase, underscores, start with letter)' };
                }

                // Check for reserved names
                const reserved = ['create_tool', 'list_tools', 'delete_tool', 'update_self', 'render_ui', 'javascript_eval', 
                                  'storage_get', 'storage_set', 'fetch_url', 'notify', 'use_agent', 'scheduler',
                                  'invoke_agent', 'broadcast_to_agents', 'list_agents', 'invoke_remote_agent',
                                  'subscribe_topic', 'publish_topic'];
                if (reserved.includes(input.name)) {
                    return { error: `Cannot override built-in tool: ${input.name}` };
                }

                // Test that the code compiles
                try {
                    new Function('input', input.code);
                } catch (e) {
                    return { error: `Invalid JavaScript code: ${e.message}` };
                }

                // Store the tool definition
                const customTools = loadCustomTools();
                const toolDef = {
                    description: input.description,
                    inputSchema: input.inputSchema,
                    code: input.code,
                    createdAt: new Date().toISOString()
                };
                customTools[input.name] = toolDef;
                saveCustomTools(customTools);

                // Immediately add tool to all existing agents (hot-reload!)
                const newTool = createToolFromDefinition(input.name, toolDef);
                if (newTool) {
                    for (const [id, agentData] of state.agents) {
                        if (agentData.agent && agentData.agent.tools) {
                            agentData.agent.tools.push(newTool);
                        }
                    }
                }

                return { 
                    success: true, 
                    message: `Tool '${input.name}' created and ready to use immediately!`,
                    tool: input.name
                };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    // list_tools - List all available tools
    const listToolsTool = tool({
        name: 'list_tools',
        description: 'List all available tools, including custom tools created by agents',
        inputSchema: z.object({
            includeBuiltIn: z.boolean().optional().describe('Include built-in tools (default: true)')
        }),
        callback: async (input = {}) => {
            const includeBuiltIn = input?.includeBuiltIn !== false;
            const result = { custom: [], builtIn: [] };

            // Custom tools
            const customTools = loadCustomTools();
            for (const [name, def] of Object.entries(customTools)) {
                result.custom.push({
                    name,
                    description: def.description,
                    createdAt: def.createdAt
                });
            }

            // Built-in tools
            if (includeBuiltIn) {
                result.builtIn = [
                    'render_ui', 'javascript_eval', 'storage_get', 'storage_set',
                    'fetch_url', 'notify', 'update_self', 'create_tool', 'list_tools', 'delete_tool',
                    'use_agent', 'scheduler', 'invoke_agent', 'broadcast_to_agents', 
                    'list_agents', 'invoke_remote_agent', 'subscribe_topic', 'publish_topic'
                ];
            }

            return result;
        }
    });

    // delete_tool - Delete custom tools
    const deleteToolTool = tool({
        name: 'delete_tool',
        description: 'Delete a custom tool created by an agent',
        inputSchema: z.object({
            name: z.string().describe('Name of the tool to delete')
        }),
        callback: async (input) => {
            const customTools = loadCustomTools();
            
            if (!customTools[input.name]) {
                return { error: `Tool '${input.name}' not found in custom tools` };
            }

            delete customTools[input.name];
            saveCustomTools(customTools);

            return { 
                success: true, 
                message: `Tool '${input.name}' deleted. Restart agents to remove from tool list.`
            };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PIPELINE TOOLS ‚Äî create_pipeline, add_task, update_task_status, read_pipeline
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const createPipelineTool = tool({
        name: 'create_pipeline', description: 'Create a pipeline with tasks and dependencies. Tasks with all deps done can run in parallel.',
        inputSchema: z.object({
            name: z.string().describe('Pipeline name'),
            tasks: z.array(z.object({
                id: z.string(), name: z.string(),
                dependsOn: z.array(z.string()).default([]),
                color: z.string().optional().describe('Hex color for active state')
            })).describe('Tasks with dependency IDs')
        }),
        callback: async (input) => {
            const id = 'pipe-' + Date.now().toString(36);
            const pipelines = getPipelines();
            pipelines[id] = {
                id, name: input.name,
                tasks: input.tasks.map(t => ({ ...t, status: 'pending', assignedTo: null, color: t.color || TASK_COLORS[t.id] || TASK_COLORS.custom, activities: [] })),
                completionActions: []
            };
            savePipelines(pipelines); updatePipelineUI();
            return { created: id, readyTasks: getReadyTasks(pipelines[id]).map(t => t.id) };
        }
    });

    const readPipelineTool = tool({
        name: 'read_pipeline', description: 'Read the current active pipeline state.',
        inputSchema: z.object({}),
        callback: async () => { const p = getActivePipeline(); return p || { error: 'No active pipeline' }; }
    });

    const addTaskTool = tool({
        name: 'add_task', description: 'Add a task to the active pipeline (for new requirements or review fixes).',
        inputSchema: z.object({ id: z.string(), name: z.string(), dependsOn: z.array(z.string()).default([]), color: z.string().optional() }),
        callback: async (input) => {
            const pipelines = getPipelines(); const p = getActivePipeline(pipelines);
            if (!p) return { error: 'No active pipeline' };
            p.tasks.push({ id: input.id, name: input.name, dependsOn: input.dependsOn, status: 'pending', assignedTo: null, color: input.color || TASK_COLORS[input.id] || TASK_COLORS.custom, activities: [] });
            savePipelines(pipelines); updatePipelineUI();
            return { added: input.id, readyTasks: getReadyTasks(p).map(t => t.id) };
        }
    });

    const updateTaskStatusTool = tool({
        name: 'update_task_status', description: 'Update a pipeline task status and optionally add an activity message.',
        inputSchema: z.object({ taskId: z.string(), status: z.enum(['pending', 'working', 'done', 'success', 'error', 'failed', 'partial']), agentId: z.string().optional(), activity: z.string().optional() }),
        callback: async (input) => {
            const pipelines = getPipelines(); const p = getActivePipeline(pipelines);
            if (!p) return { error: 'No active pipeline' };
            const task = p.tasks.find(t => t.id === input.taskId);
            if (!task) return { error: 'Task not found' };
            if (input.status === 'working' && task.assignedTo && task.assignedTo !== input.agentId) return { error: `Locked by ${task.assignedTo}` };
            task.status = input.status;
            task.assignedTo = input.status === 'working' ? (input.agentId || null) : null;
            if (input.activity) task.activities.push({ text: input.activity, ts: Date.now(), done: input.status === 'done' });
            savePipelines(pipelines); updatePipelineUI();
            return { updated: input.taskId, status: input.status, readyTasks: getReadyTasks(p).map(t => t.id) };
        }
    });

    const updateTaskDepsTool = tool({
        name: 'update_task_deps', description: 'Change a task\'s dependencies (e.g. for review cycles).',
        inputSchema: z.object({ taskId: z.string(), dependsOn: z.array(z.string()) }),
        callback: async (input) => {
            const pipelines = getPipelines(); const p = getActivePipeline(pipelines);
            if (!p) return { error: 'No active pipeline' };
            const task = p.tasks.find(t => t.id === input.taskId);
            if (!task) return { error: 'Task not found' };
            task.dependsOn = input.dependsOn;
            savePipelines(pipelines); updatePipelineUI();
            return { updated: input.taskId, dependsOn: input.dependsOn };
        }
    });

    const completePipelineTool = tool({
        name: 'complete_pipeline', description: 'Mark pipeline complete and set action cards.',
        inputSchema: z.object({ actions: z.array(z.object({ label: z.string(), description: z.string().optional(), url: z.string().optional() })).optional() }),
        callback: async (input) => {
            const pipelines = getPipelines(); const p = getActivePipeline(pipelines);
            if (!p) return { error: 'No active pipeline' };
            p.completionActions = input.actions || [];
            savePipelines(pipelines); updatePipelineUI();
            return { completed: p.id };
        }
    });

    const emitStatusTool = tool({
        name: 'emit_status', description: 'Emit a short status update for the pipeline activity log. Keep under 100 chars.',
        inputSchema: z.object({ taskId: z.string(), text: z.string(), done: z.boolean().optional() }),
        callback: async (input) => {
            const pipelines = getPipelines(); const p = getActivePipeline(pipelines);
            if (!p) return { error: 'No active pipeline' };
            const task = p.tasks.find(t => t.id === input.taskId);
            if (!task) return { error: 'Task not found' };
            task.activities.push({ text: input.text, ts: Date.now(), done: input.done || false });
            savePipelines(pipelines); renderPipelineActivity();
            return { emitted: true };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SANDBOX TOOLS ‚Äî sandbox_create, sandbox_update, togglePreviewMode
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let latestSandboxId = null;
    window.togglePreviewMode = function() {
        const bg = document.getElementById('previewBackground');
        const isActive = document.body.classList.toggle('preview-mode');
        document.getElementById('previewToggle').style.color = isActive ? '#00ff88' : '';
        if (isActive && latestSandboxId) {
            const sb = getSandboxes()[latestSandboxId];
            if (sb) { bg.innerHTML = ''; const f = document.createElement('iframe'); f.sandbox = 'allow-scripts'; f.style.cssText = 'width:100%;height:100%;border:none;'; f.srcdoc = `<!DOCTYPE html><html><head><style>${sb.css||''}</style></head><body>${sb.html||''}<script>${sb.js||''}<\/script></body></html>`; bg.appendChild(f); }
        } else { bg.innerHTML = ''; }
    };

    function getSandboxes() { try { return JSON.parse(localStorage.getItem('agi_sandboxes') || '{}'); } catch { return {}; } }
    function saveSandboxes(s) { localStorage.setItem('agi_sandboxes', JSON.stringify(s)); }

    function renderSandboxIframe(sandbox) {
        const wrap = document.createElement('div');
        wrap.className = 'sandbox-wrap';
        wrap.innerHTML = `<div class="sandbox-header"><span>üîí ${sandbox.name || sandbox.id}</span><button onclick="this.closest('.sandbox-wrap').querySelector('iframe').style.height=this.closest('.sandbox-wrap').querySelector('iframe').style.height==='80vh'?'500px':'80vh'">‚Üï</button></div>`;
        const iframe = document.createElement('iframe');
        iframe.sandbox = 'allow-scripts';
        iframe.style.cssText = 'width:100%;height:500px;border:none;border-radius:0 0 8px 8px;background:#fff;';
        iframe.srcdoc = `<!DOCTYPE html><html><head><style>${sandbox.css||''}</style></head><body>${sandbox.html||''}<script>${sandbox.js||''}<\/script></body></html>`;
        wrap.appendChild(iframe);
        return wrap;
    }

    const sandboxCreateTool = tool({
        name: 'sandbox_create',
        description: 'Create a sandboxed HTML/CSS/JS app. Renders in an isolated iframe (allow-scripts only). Returns the sandbox ID. The sandbox is also rendered inline in chat.',
        inputSchema: z.object({ name: z.string(), html: z.string().optional(), css: z.string().optional(), js: z.string().optional() }),
        callback: async (input) => {
            const id = 'sb-' + Date.now().toString(36);
            const sandbox = { id, name: input.name, html: input.html || '', css: input.css || '', js: input.js || '', createdBy: state.activeAgentId, lastModified: Date.now() };
            const all = getSandboxes(); all[id] = sandbox; saveSandboxes(all);
            // Render inline
            const container = document.getElementById('messagesInner');
            if (container) container.appendChild(renderSandboxIframe(sandbox));
            scrollToBottom();
            latestSandboxId = id;
            return { created: id, name: input.name };
        }
    });

    const sandboxUpdateTool = tool({
        name: 'sandbox_update',
        description: 'Update an existing sandbox. Only provided fields are changed. Re-renders inline.',
        inputSchema: z.object({ id: z.string(), html: z.string().optional(), css: z.string().optional(), js: z.string().optional(), name: z.string().optional() }),
        callback: async (input) => {
            const all = getSandboxes(); const sb = all[input.id];
            if (!sb) return { error: 'Sandbox not found' };
            if (input.html !== undefined) sb.html = input.html;
            if (input.css !== undefined) sb.css = input.css;
            if (input.js !== undefined) sb.js = input.js;
            if (input.name !== undefined) sb.name = input.name;
            sb.lastModified = Date.now();
            saveSandboxes(all);
            const container = document.getElementById('messagesInner');
            if (container) container.appendChild(renderSandboxIframe(sb));
            scrollToBottom();
            latestSandboxId = input.id;
            return { updated: input.id };
        }
    });

    const sandboxReadTool = tool({
        name: 'sandbox_read',
        description: 'Read a sandbox\'s current HTML, CSS, and JS code.',
        inputSchema: z.object({ id: z.string() }),
        callback: async (input) => { const sb = getSandboxes()[input.id]; return sb || { error: 'Sandbox not found' }; }
    });

    const sandboxListTool = tool({
        name: 'sandbox_list',
        description: 'List all saved sandboxes with their IDs and names.',
        inputSchema: z.object({}),
        callback: async () => { const all = getSandboxes(); return Object.values(all).map(s => ({ id: s.id, name: s.name, lastModified: s.lastModified })); }
    });

    const sandboxDeleteTool = tool({
        name: 'sandbox_delete',
        description: 'Delete a sandbox by ID.',
        inputSchema: z.object({ id: z.string() }),
        callback: async (input) => { const all = getSandboxes(); if (!all[input.id]) return { error: 'Not found' }; delete all[input.id]; saveSandboxes(all); return { deleted: input.id }; }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HOOKS ‚Äî InterruptHook, SummarizingManager
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const interruptQueues = new Map(); // agentId -> [message strings]

    function queueInterrupt(agentId, message) {
        if (!interruptQueues.has(agentId)) interruptQueues.set(agentId, []);
        interruptQueues.get(agentId).push(message);
    }

    class InterruptHook {
        registerCallbacks(registry) {
            registry.addCallback(BeforeModelCallEvent, (event) => {
                const agentId = state.activeAgentId || 'main';
                const queue = interruptQueues.get(agentId);
                if (queue?.length) {
                    const msgs = queue.splice(0);
                    const injected = msgs.map(m => `[USER INTERRUPT]: ${m}`).join('\n');
                    event.agent.messages.push({ role: 'user', content: [{ type: 'textBlock', text: injected }] });
                    addMessageToUI('system', `üí¨ Interrupt injected: ${msgs.length} message(s)`, agentId);
                }
            });
        }
    }

    class SummarizingManager {
        constructor({ windowSize = 40, summarizeAfter = 30 } = {}) {
            this.inner = new SlidingWindowConversationManager({ windowSize });
            this.summarizeAfter = summarizeAfter;
            this.summaries = new Map(); // agentId -> summary string
        }
        registerCallbacks(registry) {
            this.inner.registerCallbacks(registry);
            registry.addCallback(AfterInvocationEvent, async (event) => {
                const msgs = event.agent.messages;
                if (msgs.length < this.summarizeAfter) return;
                const agentId = state.activeAgentId || 'main';
                // Build summary from first half of messages
                const half = Math.floor(msgs.length / 2);
                const toSummarize = msgs.slice(0, half);
                const texts = toSummarize.map(m => {
                    const c = m.content || m;
                    if (typeof c === 'string') return c;
                    if (Array.isArray(c)) return c.map(b => b.text || '').join(' ');
                    return '';
                }).filter(Boolean).join('\n');
                if (texts.length < 200) return;
                const summary = `[CONVERSATION SUMMARY]: ${texts.slice(0, 2000)}...`;
                this.summaries.set(agentId, summary);
                // Replace first half with summary message
                const kept = msgs.slice(half);
                event.agent.messages.length = 0;
                event.agent.messages.push({ role: 'user', content: [{ type: 'textBlock', text: summary }] });
                kept.forEach(m => event.agent.messages.push(m));
                console.log(`Summarized ${half} messages for ${agentId}, kept ${kept.length}`);
            });
        }
    }

    // Make interrupt queue accessible for UI
    window.queueInterrupt = queueInterrupt;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GITHUB ‚Äî auth, search, read, create PR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function ghToken() { return state.credentials.github?.token || ''; }
    async function ghApi(path, opts = {}) {
        const token = ghToken();
        if (!token) throw new Error('GitHub not authenticated. Add a token in Settings or use Device Flow.');
        const url = path.startsWith('http') ? path : `https://api.github.com${path}`;
        const res = await fetch(url, { ...opts, headers: { Authorization: `token ${token}`, Accept: 'application/vnd.github.v3+json', 'Content-Type': 'application/json', ...opts.headers } });
        if (!res.ok) throw new Error(`GitHub API ${res.status}: ${await res.text()}`);
        return res.status === 204 ? {} : res.json();
    }

    // Device flow OAuth (requires a GitHub OAuth App client_id)
    window.githubDeviceFlow = async function() {
        const clientId = prompt('Enter your GitHub OAuth App Client ID (create at github.com/settings/developers):');
        if (!clientId) return;
        try {
            const codeRes = await fetch('https://github.com/login/device/code', {
                method: 'POST', headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
                body: JSON.stringify({ client_id: clientId, scope: 'repo' })
            }).then(r => r.json());
            showToast(`Go to ${codeRes.verification_uri} and enter: ${codeRes.user_code}`, 30000);
            addMessageToUI('system', `üîë GitHub Device Flow: Go to **${codeRes.verification_uri}** and enter code: **${codeRes.user_code}**`);
            // Poll for token
            const interval = (codeRes.interval || 5) * 1000;
            const poll = setInterval(async () => {
                try {
                    const tokenRes = await fetch('https://github.com/login/oauth/access_token', {
                        method: 'POST', headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
                        body: JSON.stringify({ client_id: clientId, device_code: codeRes.device_code, grant_type: 'urn:ietf:params:oauth:grant-type:device_code' })
                    }).then(r => r.json());
                    if (tokenRes.access_token) {
                        clearInterval(poll);
                        state.credentials.github = { token: tokenRes.access_token };
                        document.getElementById('githubToken').value = tokenRes.access_token;
                        saveState();
                        showToast('GitHub authenticated!');
                        addMessageToUI('system', '‚úÖ GitHub authenticated successfully');
                    }
                } catch {}
            }, interval);
            setTimeout(() => clearInterval(poll), (codeRes.expires_in || 900) * 1000);
        } catch (e) { showToast('Device flow failed: ' + e.message); }
    };

    const githubSearchTool = tool({
        name: 'github_search',
        description: 'Search GitHub code, repos, issues, or PRs. Returns top results.',
        inputSchema: z.object({ query: z.string(), type: z.enum(['code', 'repositories', 'issues']).optional() }),
        callback: async (input) => {
            const type = input.type || 'repositories';
            const data = await ghApi(`/search/${type}?q=${encodeURIComponent(input.query)}&per_page=10`);
            return { total: data.total_count, items: data.items?.map(i => ({ name: i.full_name || i.name, url: i.html_url, description: i.description })) };
        }
    });

    const githubReadFileTool = tool({
        name: 'github_read_file',
        description: 'Read a file from a GitHub repo. Returns content decoded from base64.',
        inputSchema: z.object({ owner: z.string(), repo: z.string(), path: z.string(), ref: z.string().optional() }),
        callback: async (input) => {
            const ref = input.ref ? `?ref=${input.ref}` : '';
            const data = await ghApi(`/repos/${input.owner}/${input.repo}/contents/${input.path}${ref}`);
            return { path: data.path, content: atob(data.content), size: data.size };
        }
    });

    const githubListReposTool = tool({
        name: 'github_list_repos',
        description: 'List repos for authenticated user or a specified user/org.',
        inputSchema: z.object({ owner: z.string().optional(), type: z.enum(['all', 'owner', 'member']).optional() }),
        callback: async (input) => {
            const path = input.owner ? `/users/${input.owner}/repos` : '/user/repos';
            const data = await ghApi(`${path}?per_page=30&sort=updated&type=${input.type || 'all'}`);
            return data.map(r => ({ name: r.full_name, description: r.description, url: r.html_url, stars: r.stargazers_count }));
        }
    });

    const githubCreateIssueTool = tool({
        name: 'github_create_issue',
        description: 'Create a GitHub issue.',
        inputSchema: z.object({ owner: z.string(), repo: z.string(), title: z.string(), body: z.string().optional(), labels: z.array(z.string()).optional() }),
        callback: async (input) => {
            const data = await ghApi(`/repos/${input.owner}/${input.repo}/issues`, { method: 'POST', body: JSON.stringify({ title: input.title, body: input.body, labels: input.labels }) });
            return { number: data.number, url: data.html_url };
        }
    });

    const githubListIssuesTool = tool({
        name: 'github_list_issues',
        description: 'List issues for a repo.',
        inputSchema: z.object({ owner: z.string(), repo: z.string(), state: z.enum(['open', 'closed', 'all']).optional() }),
        callback: async (input) => {
            const data = await ghApi(`/repos/${input.owner}/${input.repo}/issues?state=${input.state || 'open'}&per_page=20`);
            return data.map(i => ({ number: i.number, title: i.title, state: i.state, url: i.html_url, labels: i.labels?.map(l => l.name) }));
        }
    });

    const githubCreatePrTool = tool({
        name: 'github_create_pr',
        description: 'Create a pull request. Also adds it as a pipeline completion card if a pipeline is active.',
        inputSchema: z.object({ owner: z.string(), repo: z.string(), title: z.string(), body: z.string().optional(), head: z.string(), base: z.string().optional() }),
        callback: async (input) => {
            const data = await ghApi(`/repos/${input.owner}/${input.repo}/pulls`, { method: 'POST', body: JSON.stringify({ title: input.title, body: input.body, head: input.head, base: input.base || 'main' }) });
            // Wire into pipeline completion cards
            const pipelines = getPipelines(); const active = getActivePipeline(pipelines);
            if (active) {
                if (!active.completionActions) active.completionActions = [];
                active.completionActions.push({ label: `PR #${data.number}`, description: input.title, url: data.html_url });
                savePipelines(pipelines); renderCompletionCards();
            }
            return { number: data.number, url: data.html_url };
        }
    });

    const githubReadPrTool = tool({
        name: 'github_read_pr',
        description: 'Read PR details including diff stats and review status.',
        inputSchema: z.object({ owner: z.string(), repo: z.string(), number: z.number() }),
        callback: async (input) => {
            const [pr, reviews] = await Promise.all([
                ghApi(`/repos/${input.owner}/${input.repo}/pulls/${input.number}`),
                ghApi(`/repos/${input.owner}/${input.repo}/pulls/${input.number}/reviews`)
            ]);
            return { title: pr.title, state: pr.state, mergeable: pr.mergeable, additions: pr.additions, deletions: pr.deletions, url: pr.html_url, reviews: reviews.map(r => ({ user: r.user?.login, state: r.state })) };
        }
    });

    // ‚ïê‚ïê‚ïê CROSS-TAB MESH TOOLS (AgentMesh P2P) ‚ïê‚ïê‚ïê
    const invokeMeshAgentTool = tool({ name: 'invoke_mesh_agent', description: 'Send a prompt to an agent in ANOTHER browser tab. Use list_mesh_peers to see targets.', inputSchema: z.object({ target: z.string().describe('Target page: "single", "multi", "mesh", or "all"'), prompt: z.string() }), callback: async (input) => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; try { const r = await window.AgentMesh.invoke(input.target, input.prompt); return { success: true, target: input.target, result: r.result || r }; } catch (e) { return { error: e.message }; } } });
    const listMeshPeersTool = tool({ name: 'list_mesh_peers', description: 'List all connected agi.diy browser tabs', inputSchema: z.object({}), callback: async () => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; const peers = window.AgentMesh.getPeers(); return { myPage: window.AgentMesh.currentPage.id, peerCount: peers.length, peers: peers.map(p => ({ id: p.id, label: p.label, tabId: p.tabId })), availableTargets: [...new Set(peers.map(p => p.id))] }; } });
    const broadcastMeshTool = tool({ name: 'broadcast_mesh', description: 'Send message to ALL connected agi.diy tabs', inputSchema: z.object({ message: z.string() }), callback: async (input) => { if (!window.AgentMesh) return { error: 'AgentMesh not loaded' }; try { const r = await window.AgentMesh.invoke('all', input.message); return { success: true, responses: r }; } catch (e) { return { error: e.message }; } } });
    const addToMeshRingTool = tool({ name: 'add_to_mesh_ring', description: 'Share context visible to ALL agents in ALL tabs', inputSchema: z.object({ text: z.string(), agentType: z.string().optional() }), callback: async (input) => { if (!window.AgentMesh?.addToRingContext) return { error: 'AgentMesh not available' }; window.AgentMesh.addToRingContext('multi-agent', input.agentType || 'multi', input.text); return { success: true, added: input.text.slice(0, 100) }; } });
    const getMeshRingTool = tool({ name: 'get_mesh_ring', description: 'See what agents in other tabs are working on', inputSchema: z.object({ maxEntries: z.number().optional() }), callback: async (input) => { if (!window.AgentMesh?.getRingContext) return { error: 'AgentMesh not available' }; const entries = window.AgentMesh.getRingContext(); return { totalEntries: entries.length, recent: entries.slice(-(input.maxEntries || 10)).map(e => ({ agentId: e.agentId, type: e.agentType, text: e.text.slice(0, 200) })) }; } });
    const MESH_TOOLS = [invokeMeshAgentTool, listMeshPeersTool, broadcastMeshTool, addToMeshRingTool, getMeshRingTool];

    const TOOLS = [
        // Core
        renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool,
        // Self-modification
        updateSelfTool, createToolTool, listToolsTool, deleteToolTool,
        // Agent management
        useAgentTool, schedulerTool,
        // Mesh communication (local + remote)
        invokeAgentTool, broadcastToAgentsTool, listAgentsTool, invokeRemoteAgentTool, subscribeTopicTool, publishTopicTool,
        // Cross-tab mesh
        ...MESH_TOOLS,
        // Pipeline
        createPipelineTool, readPipelineTool, addTaskTool, updateTaskStatusTool, updateTaskDepsTool, completePipelineTool, emitStatusTool,
        // Sandbox
        sandboxCreateTool, sandboxUpdateTool, sandboxReadTool, sandboxListTool, sandboxDeleteTool,
        // GitHub
        githubSearchTool, githubReadFileTool, githubListReposTool, githubCreateIssueTool, githubListIssuesTool, githubCreatePrTool, githubReadPrTool
    ];
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MANAGEMENT ‚Äî createAgent, updateAgentUI, selectAgent, killAgent, buildSystemPrompt
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.spawnAgent = async function(idOrEvent, config) {
        // Programmatic call: spawnAgent('name', { systemPrompt, provider, ... })
        if (typeof idOrEvent === 'string' && config) {
            const id = idOrEvent;
            if (state.agents.has(id)) { console.warn('Agent ID exists:', id); return; }
            const provider = config.provider || 'bedrock';
            const modelId = config.modelId || undefined;
            const systemPrompt = config.systemPrompt || 'You are a helpful AI assistant.';
            const maxTokens = config.maxTokens || DEFAULT_MAX_TOKENS;
            const additionalRequestFields = config.additionalRequestFields || null;
            const enabledTools = config.enabledTools || null;
            const toolChoice = config.toolChoice || null;
            
            const model = createModel(provider, { modelId, maxTokens, additionalRequestFields });
            const selectedTools = (!enabledTools) ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();
            const agent = new Agent({ model, tools: [...selectedTools, ...customTools], systemPrompt: buildSystemPrompt(id, systemPrompt), printer: false });
            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;
            state.agents.set(id, { agent, model, config: { provider, modelId, systemPrompt, maxTokens, additionalRequestFields, enabledTools, toolChoice }, messages: [], status: 'ready', color });
            updateAgentUI();
            selectAgent(id);
            showToast(`Agent ${id} spawned`);
            saveState();
            return;
        }
        
        // UI call: reads from DOM
        const id = document.getElementById('spawnId').value.trim();
        const provider = document.getElementById('spawnProvider').value;
        const modelId = document.getElementById('spawnModelId').value.trim();
        const systemPrompt = document.getElementById('spawnPrompt').value.trim() || 'You are a helpful AI assistant.';
        const maxTokens = parseInt(document.getElementById('spawnMaxTokens').value) || DEFAULT_MAX_TOKENS;
        const additionalFieldsStr = document.getElementById('spawnAdditionalFields').value.trim();
        
        if (!id) { showToast('Enter agent ID'); return; }
        if (state.agents.has(id)) { showToast('Agent ID exists'); return; }
        
        // Parse additional request fields
        let additionalRequestFields = null;
        if (additionalFieldsStr) {
            try {
                additionalRequestFields = JSON.parse(additionalFieldsStr);
            } catch (e) {
                showToast('Invalid JSON in additional fields');
                return;
            }
        }
        
        // Get enabled tools
        const toolCheckboxes = document.querySelectorAll('#spawnToolsList input[name="spawn-tool"]:checked');
        const enabledTools = Array.from(toolCheckboxes).map(cb => cb.value);
        const allToolsEnabled = enabledTools.length === TOOLS.length;
        
        try {
            const model = createModel(provider, { 
                modelId: modelId || undefined, 
                maxTokens,
                additionalRequestFields
            });
            
            // Get the tools based on selection + custom tools
            const selectedTools = allToolsEnabled ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();
            const allTools = [...selectedTools, ...customTools];
            
            // Connect MCP servers if configured
            const mcpServers = getMcpServersConfig('spawnMcpServers');
            const { clients: mcpClients, toolNames: mcpToolNames, tools: mcpTools } = await connectMcpServers(mcpServers);
            allTools.push(...mcpTools);
            
            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(id, systemPrompt),
                printer: false
            });
            
            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;
            
            state.agents.set(id, {
                agent,
                model,
                config: { 
                    provider, 
                    modelId: modelId || undefined, 
                    systemPrompt, 
                    maxTokens,
                    additionalRequestFields,
                    enabledTools: allToolsEnabled ? null : enabledTools,
                    mcpServers: mcpServers.length ? mcpServers : undefined
                },
                mcpClients,
                mcpToolNames,
                messages: [],
                status: 'ready',
                color
            });
            
            closeModal('spawnModal');
            
            updateAgentUI();
            selectAgent(id);
            showToast(`Agent ${id} spawned`);
            saveState();
        } catch (e) {
            showToast('Error: ' + e.message);
        }
    };
    
    function buildSystemPrompt(agentId, basePrompt) {
        return `${basePrompt}

## Multi-Agent Context
You are agent "${agentId}" in a multi-agent system. You have access to:
- use_agent: Create sub-agents for parallel tasks
- scheduler: Schedule tasks (once or recurring cron)
- invoke_agent: Call another agent and wait for response
- broadcast_to_agents: Send message to all agents
- list_agents: Discover all available agents and their capabilities

## Self-Modification
- update_self: Modify your own system prompt
- create_tool: Create new tools at runtime (persists across sessions)
- list_tools: See all available tools including custom ones
- delete_tool: Remove custom tools

Ring Attention: Other agents' recent messages are shared with you for context.

${getRingContext()}`;
    }
    
    function getRingContext() {
        if (state.ringBuffer.length === 0) return '';
        const recent = state.ringBuffer.slice(-10);
        return '## Recent Messages from Other Agents:\n' + recent.map(e => `[${e.agentId}]: ${e.content.slice(0, 200)}...`).join('\n');
    }
    
    window.selectAgent = function(agentId) {
        state.activeAgentId = agentId;
        updateAgentUI();
        renderMessages();
        
        const agentData = state.agents.get(agentId);
        if (agentData) {
            document.getElementById('currentAgentName').textContent = agentId;
            document.getElementById('currentAgentModel').textContent = `${agentData.config.provider} ‚Ä¢ ${agentData.config.modelId || 'default'}`;
        }
        const sel = document.getElementById('targetAgent');
        if (sel && sel.querySelector(`option[value="${agentId}"]`)) sel.value = agentId;
    };
    
    window.killAgent = function(agentId, event) {
        event.stopPropagation();
        if (!confirm(`Kill agent ${agentId}?`)) return;
        
        // Disconnect MCP clients
        const agentData = state.agents.get(agentId);
        if (agentData?.mcpClients) {
            for (const c of agentData.mcpClients) c.disconnect().catch(() => {});
        }
        
        state.agents.delete(agentId);
        if (state.activeAgentId === agentId) {
            state.activeAgentId = state.agents.keys().next().value || null;
        }
        updateAgentUI();
        renderMessages();
        showToast(`Agent ${agentId} killed`);
        saveState();
    };
    
    function updateAgentUI() {
        const agentListHtml = [];
        const targetOptions = ['<option value="all">All Agents</option>'];
        const pipeline = getActivePipeline();
        
        for (const [id, data] of state.agents) {
            const isActive = id === state.activeAgentId;
            let statusText = data.status;
            if (data.status === 'processing' && pipeline) {
                const task = pipeline.tasks.find(t => t.assignedTo === id && t.status === 'working');
                if (task) statusText = '‚ñ∂ ' + (task.id.length > 16 ? task.id.substring(0, 16) + '‚Ä¶' : task.id);
            }
            agentListHtml.push(`
                <div class="agent-card ${isActive ? 'active' : ''}" onclick="selectAgent('${id}')">
                    <div class="agent-card-header">
                        <span class="agent-dot" style="background:${data.color}"></span>
                        <span class="agent-name">${id}</span>
                        <span class="agent-status ${data.status}">${statusText}</span>
                    </div>
                    <div class="agent-meta">
                        <span>${data.config.provider}${data.mcpToolNames?.length ? ` ¬∑ ${data.mcpToolNames.length} mcp` : ''}</span>
                        <span>
                            <span class="agent-edit" onclick="openEditAgentModal('${id}', event)" title="Edit agent">‚úé</span>
                            <span class="agent-kill" onclick="killAgent('${id}', event)" title="Kill agent">‚úï</span>
                        </span>
                    </div>
                </div>
            `);
            targetOptions.push(`<option value="${id}">${id}</option>`);
        }
        
        document.getElementById('agentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('mobileAgentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('targetAgent').innerHTML = targetOptions.join('');
        updateActivityFilterOptions();
        
        // Update schedule agent dropdown
        const scheduleAgentSelect = document.getElementById('scheduleAgent');
        if (scheduleAgentSelect) {
            scheduleAgentSelect.innerHTML = [...state.agents.keys()].map(id => `<option value="${id}">${id}</option>`).join('');
        }
    }
    
    function updateScheduleUI() {
        const container = document.getElementById('scheduleList');
        if (state.schedules.size === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>';
            return;
        }
        
        let html = '';
        for (const [id, s] of state.schedules) {
            html += `
                <div class="schedule-item">
                    <div class="schedule-item-header">
                        <strong>${s.name}</strong>
                        <span class="schedule-delete" onclick="deleteSchedule('${id}')">‚úï</span>
                    </div>
                    <div>Agent: ${s.agentId}</div>
                    <div class="schedule-cron">${s.type === 'cron' ? s.cron : `once in ${s.delay}s`}</div>
                </div>
            `;
        }
        container.innerHTML = html;
    }
    
    window.deleteSchedule = function(id) {
        const s = state.schedules.get(id);
        if (s) {
            if (s.timer) clearTimeout(s.timer);
            if (s.interval) clearInterval(s.interval);
            state.schedules.delete(id);
            updateScheduleUI();
            saveState();
            showToast('Schedule deleted');
        }
    };
    
    // Auto-create default agent if none exist and credentials are available
    async function autoCreateDefaultAgent() {
        if (state.agents.size > 0) return; // Already have agents
        
        // Check for any configured credentials
        const hasAnthropic = state.credentials.anthropic.apiKey;
        const hasOpenAI = state.credentials.openai.apiKey;
        const hasBedrock = state.credentials.bedrock.apiKey;
        
        if (!hasAnthropic && !hasOpenAI && !hasBedrock) {
            console.log('No API keys configured - please add credentials in settings');
            return;
        }
        
        // Determine which provider to use (priority: bedrock > anthropic > openai)
        let provider = 'bedrock';
        if (hasBedrock) provider = 'bedrock';
        else if (hasAnthropic) provider = 'anthropic';
        else if (hasOpenAI) provider = 'openai';
        
        try {
            // Use bedrock defaults with extended thinking
            const modelConfig = {
                maxTokens: DEFAULT_MAX_TOKENS,
                additionalRequestFields: provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
            };
            const model = createModel(provider, modelConfig);
            
            // Include custom tools
            const customTools = buildCustomTools();
            const allTools = [...TOOLS, ...customTools];
            
            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt('assistant', 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, create custom tools, and coordinate with other agents.'),
                printer: false
            });
            
            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;
            
            state.agents.set('assistant', {
                agent,
                model,
                config: { 
                    provider, 
                    systemPrompt: 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, create custom tools, and coordinate with other agents.', 
                    maxTokens: DEFAULT_MAX_TOKENS,
                    additionalRequestFields: provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
                },
                messages: [],
                status: 'ready',
                color
            });
            
            state.activeAgentId = 'assistant';
            updateAgentUI();
            renderMessages();
            saveState();
            
            console.log('‚úÖ Default agent "assistant" created automatically');
            showToast('Default agent ready');
        } catch (e) {
            console.warn('Could not auto-create default agent:', e);
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESSAGING ‚Äî runAgentMessage, sendMessage, clearChat, broadcastMessage
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let streamingEls = new Map(); // agentId -> streaming element
    let broadcastMode = false; // true when sending to all agents
    let abortControllers = new Map(); // agentId -> AbortController
    
    async function runAgentMessage(agentId, message) {
        const agentData = state.agents.get(agentId);
        if (!agentData) return;
        
        // Validate API key before attempting model call
        const creds = state.credentials[agentData.config.provider];
        if (!creds?.apiKey) {
            addMessageToUI('error', `No API key configured for ${agentData.config.provider}. Open Settings to add one.`, agentId, agentData.color);
            return;
        }
        
        // Cancel any existing run for this agent
        if (abortControllers.has(agentId)) abortControllers.get(agentId).abort();
        const ac = new AbortController();
        abortControllers.set(agentId, ac);
        
        // Add to ring buffer FIRST so it's included in system prompt
        state.ringBuffer.push({ agentId, role: 'user', content: message, timestamp: Date.now() });
        if (state.ringBuffer.length > 100) state.ringBuffer.shift();
        updateRingUI();
        
        // Create a FRESH agent instance for each message (allows parallelism)
        // The stored agentData.agent is just a reference/template
        let activeAgent;
        try {
            const model = createModel(agentData.config.provider, { 
                modelId: agentData.config.modelId,
                maxTokens: agentData.config.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: agentData.config.additionalRequestFields || null
            });
            
            // Get the tools based on agent's enabled tools config + custom tools
            const enabledTools = agentData.config.enabledTools;
            const selectedTools = (!enabledTools || enabledTools === null) ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();  // Include dynamically created tools!
            const allTools = [...selectedTools, ...customTools];
            
            activeAgent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(agentId, agentData.config.systemPrompt),
                printer: false,
                conversationManager: new SummarizingManager(),
                hooks: [new InterruptHook()]
            });
            
            // Inject toolChoice if configured (forces tool use)
            if (agentData.config.toolChoice) {
                const origStream = model.stream.bind(model);
                model.stream = function(msgs, opts) {
                    return origStream(msgs, { ...opts, toolChoice: agentData.config.toolChoice });
                };
            }
            
            // Inject conversation history from this agent's messages
            if (agentData.messages.length > 0) {
                // Load recent conversation history (last 20 messages)
                const recentHistory = agentData.messages.slice(-20);
                for (const msg of recentHistory) {
                    const text = msg.content || (msg.transcript ? transcriptFullText(msg.transcript) : '');
                    activeAgent.messages.push({
                        role: msg.role,
                        content: [{ type: 'textBlock', text }]
                    });
                }
                console.log(`Injected ${recentHistory.length} messages of history for ${agentId}`);
            }
        } catch (e) {
            console.error(`Failed to create agent instance for ${agentId}:`, e);
            addMessageToUI('error', `Failed to create agent: ${e.message}`, agentId, agentData.color);
            return;
        }
        
        agentData.status = 'processing';
        updateAgentUI();
        
        // Add user message to stored history
        agentData.messages.push({ role: 'user', content: message, timestamp: Date.now() });
        const shouldShow = broadcastMode || agentId === state.activeAgentId;
        
        if (shouldShow) {
            addMessageToUI('user', message, agentId, agentData.color);
            addThinking();
        }
        
        try {
            let currentText = '';
            const transcript = [];
            var watchdog = setTimeout(() => {
                console.error(`‚è∞ Agent ${agentId} timeout`);
                ac.abort();
                agentData.status = 'error';
                abortControllers.delete(agentId);
                document.getElementById('interruptBtn').style.display = 'none';
                if (shouldShow) { removeThinking(); addMessageToUI('error', 'Agent timed out (5 min)', agentId, agentData.color); }
                appendActivityFeed(agentId, '‚ùå Timed out after 5 minutes', 'msg');
                updateAgentUI(); saveState();
            }, 300000);
            
            for await (const event of activeAgent.stream(message)) {
                if (ac.signal.aborted) break;
                if (!event?.type) continue;
                
                if (event.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                    currentText += event.delta.text;
                    transcriptPushText(transcript, event.delta.text);
                    if (shouldShow) updateStreaming(currentText, agentId, agentData.color);
                }
                else if (event.type === 'beforeToolCallEvent') {
                    const toolId = event.toolUse?.toolUseId || `tool-${event.toolUse?.name}-${Date.now()}`;
                    transcript.push({ type: 'tool_use', name: event.toolUse?.name, toolId, input: event.toolUse?.input });
                    if (shouldShow) {
                        addToolCall(event.toolUse?.name, event.toolUse?.input, 'running', toolId);
                        // Move streaming element after tool block so text stays in one place
                        const se = streamingEls.get(agentId);
                        if (se) document.getElementById('messagesInner').appendChild(se);
                    }
                    const toolName = event.toolUse?.name;
                    const toolInput = event.toolUse?.input;
                    const feedLabel = toolName === 'invoke_agent' && toolInput?.targetAgentId
                        ? `üîß invoke_agent ‚Üí ${toolInput.targetAgentId}`
                        : `üîß ${toolName}`;
                    appendActivityFeed(agentId, feedLabel, 'tool', { input: toolInput });
                    // Store toolId for afterToolCallEvent
                    event._toolId = toolId;
                }
                else if (event.type === 'afterToolCallEvent') {
                    transcript.push({ type: 'tool_result', name: event.toolUse?.name, toolId: event.toolUse?.toolUseId, status: event.result?.status || 'success', output: event.result });
                    if (shouldShow) updateToolStatus(event.toolUse?.toolUseId, event.toolUse?.name, event.result?.status || 'success', event.result);
                    // Update last tool entry in activity log + DOM with output
                    const last = activityLog.findLast(e => e.type === 'tool' && e.agentId === agentId);
                    if (last && event.result) {
                        last.extra = { ...last.extra, output: event.result };
                        const feed = document.getElementById('activityFeed');
                        if (feed) renderActivityEntry(feed, last);
                    }
                }
            }
            
            
            if (shouldShow) {
                removeThinking();
                if (currentText) finalizeStreaming(currentText, agentId, agentData.color);
            }
            if (currentText) appendActivityFeed(agentId, currentText.replace(/[#*`]/g, '').substring(0, 1000));
            
            agentData.messages.push({ role: 'assistant', transcript, content: currentText, timestamp: Date.now() });
            
            // Add to ring buffer
            state.ringBuffer.push({ agentId, role: 'assistant', content: currentText, timestamp: Date.now() });
            if (window.AgentMesh?.addToRingContext) window.AgentMesh.addToRingContext(agentId, 'multi', currentText.slice(0, 500));
            if (state.ringBuffer.length > 100) state.ringBuffer.shift();
            updateRingUI();
            
            agentData.status = 'ready';
            abortControllers.delete(agentId);
            clearTimeout(watchdog);
            document.getElementById('interruptBtn').style.display = 'none';
            return currentText;
        } catch (e) {
            console.error(`Agent ${agentId} error:`, e);
            agentData.status = 'error';
            abortControllers.delete(agentId);
            clearTimeout(watchdog);
            document.getElementById('interruptBtn').style.display = 'none';
            
            if (shouldShow) {
                removeThinking();
                addMessageToUI('error', e.message, agentId, agentData.color);
            }
            appendActivityFeed(agentId, `‚ùå Error: ${e.message}`, 'msg');
        }
        
        updateAgentUI();
        saveState();
    }
    
    window.sendMessage = async function() {
        const input = document.getElementById('inputField');
        const text = input.value.trim();
        if (!text) return;
        document.getElementById('interruptBtn').style.display = 'inline-flex';
        
        const target = document.getElementById('targetAgent').value;
        
        // If no agents exist, try to create default agent first
        if (state.agents.size === 0) {
            const hasAnyKey = state.credentials.anthropic.apiKey || 
                              state.credentials.openai.apiKey || 
                              state.credentials.bedrock.apiKey;
            
            if (!hasAnyKey) {
                showToast('Add API key in Settings first');
                openSettingsModal();
                return;
            }
            
            // Create default agent on the fly
            showToast('Creating agent...');
            await autoCreateDefaultAgent();
            
            if (state.agents.size === 0) {
                showToast('Failed to create agent');
                return;
            }
        }
        
        input.value = '';
        
        broadcastMode = (target === 'all');
        if (target === 'all') {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text);
            }
        } else {
            runAgentMessage(target, text);
        }
    };
    
    window.broadcastMessage = function() {
        broadcastMode = true;
        const text = prompt('Broadcast message to all agents:');
        if (text?.trim()) {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text.trim());
            }
        }
    };
    
    window.clearChat = function() {
        // Abort all running agents
        for (const [id, ac] of abortControllers) ac.abort();
        abortControllers.clear();
        for (const [id, data] of state.agents) { data.status = 'ready'; }
        updateAgentUI();
        
        // Clear pipeline
        localStorage.removeItem('agi_pipelines');
        updatePipelineUI();
        
        if (!state.activeAgentId) {
            showToast('Cleared');
            return;
        }
        
        const agentData = state.agents.get(state.activeAgentId);
        if (agentData) {
            agentData.messages = [];
            renderMessages();
            showToast('Cleared');
            saveState();
            // Reset activity feed
            activityLog.length = 0;
            const feed = document.getElementById('activityFeed');
            if (feed) { feed.innerHTML = ''; feed._lastAgent = null; }
            const sel = document.getElementById('activityFilter');
            if (sel) { sel.value = 'all'; updateActivityFilterOptions(); }
        }
    };
    
    window.clearAllChats = function() {
        for (const [id, ac] of abortControllers) ac.abort();
        abortControllers.clear();
        for (const [id, data] of state.agents) { data.status = 'ready'; data.messages = []; }
        localStorage.removeItem('agi_pipelines');
        updatePipelineUI();
        updateAgentUI();
        renderMessages();
        activityLog.length = 0;
        const feed = document.getElementById('activityFeed');
        if (feed) { feed.innerHTML = ''; feed._lastAgent = null; }
        const sel = document.getElementById('activityFilter');
        if (sel) { sel.value = 'all'; updateActivityFilterOptions(); }
        saveState();
        showToast('All cleared');
    };

    window.sendInterrupt = function() {
        const input = document.getElementById('inputField');
        const text = input.value.trim();
        if (!text) return;
        const agentId = state.activeAgentId || 'main';
        queueInterrupt(agentId, text);
        addMessageToUI('user', `‚ö° [Interrupt]: ${text}`, agentId);
        input.value = '';
    };

    window.handleKeyDown = function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI RENDERING ‚Äî addMessageToUI, streaming, tool calls, ring buffer
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function renderMessages() {
        const inner = document.getElementById('messagesInner');
        inner.innerHTML = '';
        
        if (!state.activeAgentId) {
            inner.innerHTML = `<div class="message system"><div class="message-content">
                <strong>Getting Started</strong><br><br>
                ${Object.values(state.credentials).some(c => c.apiKey) 
                    ? 'Creating default agent... If this takes too long, try clicking "+ New Agent".'
                    : 'Add your API key in ‚öôÔ∏è Settings to start chatting, or click "+ New Agent" to configure a new agent.'}
            </div></div>`;
            document.getElementById('currentAgentName').textContent = 'No Agent Selected';
            document.getElementById('currentAgentModel').textContent = '‚Äî';
            return;
        }
        
        const agentData = state.agents.get(state.activeAgentId);
        if (!agentData) return;
        
        for (const msg of agentData.messages) {
            addMessageToUI(msg.role, msg.content, state.activeAgentId, agentData.color, false);
        }
        scrollToBottom();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TRANSCRIPT ‚Äî structured turn data, helpers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function transcriptPushText(transcript, text) {
        const last = transcript[transcript.length - 1];
        if (last?.type === 'text') last.content += text;
        else transcript.push({ type: 'text', content: text });
    }
    function transcriptFullText(t) { return t.filter(e => e.type === 'text').map(e => e.content).join(''); }
    function transcriptLastText(t) { return t.findLast(e => e.type === 'text')?.content || ''; }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ACTIVITY FEED ‚Äî appendActivityFeed, filterActivityFeed, activityLog[]
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const activityLog = []; // { agentId, text, type, ts }

    function appendActivityFeed(agentId, text, type = 'msg', extra = null) {
        const agentData = state.agents.get(agentId);
        activityLog.push({ agentId, text, type, ts: Date.now(), color: agentData?.color || '#888', extra });
        const feed = document.getElementById('activityFeed');
        if (!feed) return;
        const filter = document.getElementById('activityFilter')?.value;
        if (filter && filter !== 'all' && filter !== agentId && !filter.startsWith('task:')) return;
        renderActivityEntry(feed, activityLog[activityLog.length - 1]);
        feed.scrollTop = feed.scrollHeight;
    }

    function renderActivityEntry(feed, entry) {
        if (!feed._lastAgent || feed._lastAgent !== entry.agentId) {
            const h = document.createElement('div');
            h.className = 'af-agent';
            h.innerHTML = `<span class="message-role">agi</span><span class="message-agent" style="background:${entry.color}20;color:${entry.color}">${entry.agentId}</span>`;
            feed.appendChild(h);
            feed._lastAgent = entry.agentId;
        }
        const idx = activityLog.indexOf(entry);
        const line = document.createElement('div');
        line.className = entry.type === 'tool' ? 'af-tool tool-block' : 'af-msg';
        if (idx >= 0) line.id = 'af-' + idx;
        line.style.setProperty('--agent-color', entry.color);
        if (entry.type === 'tool' && entry.extra) {
            const hdr = document.createElement('div');
            hdr.className = 'tool-header';
            hdr.innerHTML = `<div class="tool-status"></div><span class="tool-name">${escapeHtml(entry.text)}</span>`;
            line.appendChild(hdr);
            if (entry.extra.input) {
                const d = document.createElement('details');
                d.innerHTML = `<summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:4px">input</summary><div class="tool-input">${escapeHtml(JSON.stringify(entry.extra.input, null, 2).substring(0, 2000))}</div>`;
                line.appendChild(d);
            }
            if (entry.extra.output) {
                const d = document.createElement('details');
                const out = typeof entry.extra.output === 'string' ? entry.extra.output : JSON.stringify(entry.extra.output, null, 2);
                d.innerHTML = `<summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:4px">output</summary><div class="tool-input">${escapeHtml(out.substring(0, 2000))}</div>`;
                line.appendChild(d);
            }
        } else {
            line.textContent = entry.text.length > 500 ? entry.text.substring(0, 500) + '‚Ä¶' : entry.text;
        }
        // Replace existing or append
        const existing = idx >= 0 ? document.getElementById('af-' + idx) : null;
        if (existing) existing.replaceWith(line);
        else feed.appendChild(line);
    }

    function filterActivityFeed() {
        const filter = document.getElementById('activityFilter').value;
        const feed = document.getElementById('activityFeed');
        feed.innerHTML = '';
        feed._lastAgent = null;
        if (filter.startsWith('task:')) {
            const p = getActivePipeline();
            const task = p?.tasks.find(t => t.id === filter.substring(5));
            if (!task) return;
            const h = document.createElement('div');
            h.className = 'af-agent';
            h.style.color = task.color || '#ccc';
            h.textContent = `${task.name} [${task.status}]${task.assignedTo ? ' ‚Üí ' + task.assignedTo : ''}`;
            feed.appendChild(h);
            // Show task activities from pipeline
            (task.activities || []).forEach(a => {
                const line = document.createElement('div');
                line.className = a.done ? 'af-msg' : 'af-tool';
                line.style.setProperty('--agent-color', task.color || '#555');
                line.textContent = (a.done ? '‚úì ' : '') + a.text;
                feed.appendChild(line);
            });
            // Also show matching entries from activity log
            activityLog.filter(e => e.text.includes(task.name.split(' ‚Äî ')[0])).forEach(e => renderActivityEntry(feed, e));
            return;
        }
        // Re-render from backing store
        const entries = filter === 'all' ? activityLog : activityLog.filter(e => e.agentId === filter);
        entries.forEach(e => renderActivityEntry(feed, e));
        feed.scrollTop = feed.scrollHeight;
    }

    function updateActivityFilterOptions() {
        const sel = document.getElementById('activityFilter');
        if (!sel) return;
        const val = sel.value;
        const opts = ['<option value="all">All Agents</option>'];
        for (const [id, data] of state.agents) {
            opts.push(`<option value="${id}" style="color:${data.color}">${id}</option>`);
        }
        // Keep task option if selected
        if (val.startsWith('task:')) {
            const p = getActivePipeline();
            const task = p?.tasks.find(t => t.id === val.substring(5));
            if (task) opts.push(`<option value="${val}">${task.name.split(' ‚Äî ')[0]}</option>`);
        }
        sel.innerHTML = opts.join('');
        sel.value = val;
    }

    function addMessageToUI(role, content, agentId, color, scroll = true) {
        const inner = document.getElementById('messagesInner');
        const msg = document.createElement('div');
        msg.className = `message ${role}`;
        
        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const userColor = '#3b82f6';
        const arr = '<span class="message-arrow">‚Ä∫</span>';
        const header = role === 'user' 
            ? `<span class="message-agent" style="background:${userColor}20;color:${userColor}">you</span>${arr}<span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>`
            : `<span class="message-role">agi</span><span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>${arr}<span class="message-agent" style="background:${userColor}20;color:${userColor}">you</span>`;
        
        msg.innerHTML = `
            <div class="message-header">
                ${header}
                <span class="message-time">${time}</span>
            </div>
            <div class="message-content">${role === 'user' ? escapeHtml(content) : `<div class="markdown-content">${marked.parse(content)}</div>`}</div>
        `;
        
        inner.appendChild(msg);
        if (scroll) scrollToBottom();
    }
    
    function updateStreaming(text, agentId, color) {
        const inner = document.getElementById('messagesInner');
        removeThinking();
        
        let streamingEl = streamingEls.get(agentId);
        if (!streamingEl) {
            streamingEl = document.createElement('div');
            streamingEl.className = 'message assistant';
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            streamingEl.innerHTML = `
                <div class="message-header">
                    <span class="message-role">agi</span>
                    <span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content"><div class="markdown-content"></div></div>
            `;
            inner.appendChild(streamingEl);
            streamingEls.set(agentId, streamingEl);
        }
        
        streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
        scrollToBottom();
    }
    
    function finalizeStreaming(text, agentId, color) {
        const streamingEl = streamingEls.get(agentId);
        if (streamingEl) {
            streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
            streamingEls.delete(agentId);
        }
    }
    
    function addToolCall(name, input, status, toolId) {
        const inner = document.getElementById('messagesInner');
        const tool = document.createElement('div');
        tool.className = 'tool-block';
        tool.id = toolId || `tool-${name}-${Date.now()}`;
        tool.innerHTML = `
            <div class="tool-header">
                <div class="tool-status ${status}"></div>
                <span class="tool-name">${name}</span>
            </div>
            <details><summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:8px;">input</summary>
            <div class="tool-input">${JSON.stringify(input, null, 2)}</div></details>
        `;
        inner.appendChild(tool);
        scrollToBottom();
    }
    
    function updateToolStatus(toolId, name, status, result) {
        const block = toolId ? document.getElementById(toolId) : null
            || [...document.querySelectorAll('.tool-block')].reverse().find(b => b.querySelector('.tool-name')?.textContent === name);
        if (!block) return;
        block.querySelector('.tool-status').className = `tool-status ${status === 'error' ? 'error' : ''}`;
        if (result) {
            const out = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
            if (out && out.length > 2) {
                const d = document.createElement('details');
                d.innerHTML = `<summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:4px;">output</summary><div class="tool-input">${escapeHtml(out.substring(0, 2000))}</div>`;
                block.appendChild(d);
            }
        }
    }
    
    function addThinking() {
        const inner = document.getElementById('messagesInner');
        if (inner.querySelector('.thinking-indicator')) return;
        const el = document.createElement('div');
        el.className = 'message assistant thinking-indicator';
        el.innerHTML = '<div class="message-content"><div class="thinking"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div></div>';
        inner.appendChild(el);
        scrollToBottom();
    }
    
    function removeThinking() {
        document.querySelector('.thinking-indicator')?.remove();
    }
    
    function updateRingUI() {
        const container = document.getElementById('ringContent');
        if (!container) return;
        let allEntries = state.ringBuffer.map((e, idx) => ({ ...e, localIndex: idx }));
        // Merge AgentMesh ring entries from other tabs
        if (window.AgentMesh?.getRingContext) {
            for (const entry of window.AgentMesh.getRingContext()) {
                const isDup = allEntries.some(e => e.agentId === entry.agentId && Math.abs(e.timestamp - entry.timestamp) < 5000 && e.content?.slice(0, 50) === entry.text?.slice(0, 50));
                if (!isDup) allEntries.push({ agentId: entry.agentId, role: 'assistant', content: entry.text, timestamp: entry.timestamp, isMesh: true });
            }
        }
        allEntries.sort((a, b) => a.timestamp - b.timestamp);
        const recent = allEntries.slice(-20).reverse();
        
        if (recent.length === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);text-align:center;padding:20px;">Shared context will appear here</div>';
            return;
        }
        
        container.innerHTML = recent.map((e, displayIndex) => {
            const agentData = state.agents.get(e.agentId);
            const color = agentData?.color || (e.isMesh ? '#6cf' : '#888');
            const time = new Date(e.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const meshBadge = e.isMesh ? ' <span style="font-size:9px;opacity:0.6">üåê</span>' : '';
            const deleteBtn = e.localIndex != null ? `<span class="ring-entry-delete" onclick="deleteRingEntry(${e.localIndex})" title="Delete this entry">‚úï</span>` : '';
            return `
                <div class="ring-entry">
                    <div class="ring-entry-header">
                        <span class="ring-entry-agent" style="color:${color}">${e.agentId}${meshBadge}</span>
                        <div class="ring-entry-meta">
                            <span class="ring-entry-time">${time}</span>
                            ${deleteBtn}
                        </div>
                    </div>
                    <div class="ring-entry-content">${escapeHtml(e.content.slice(0, 150))}${e.content.length > 150 ? '...' : ''}</div>
                </div>
            `;
        }).join('');
    }
    
    window.clearRingContext = function() {
        if (state.ringBuffer.length === 0) {
            showToast('Ring context is already empty');
            return;
        }
        if (!confirm('Clear all ring context? This cannot be undone.')) return;
        state.ringBuffer = [];
        updateRingUI();
        saveState();
        showToast('Ring context cleared');
    };
    
    window.deleteRingEntry = function(index) {
        if (index >= 0 && index < state.ringBuffer.length) {
            state.ringBuffer.splice(index, 1);
            updateRingUI();
            saveState();
            showToast('Entry deleted');
        }
    };
    
    function scrollToBottom() {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODALS ‚Äî spawn, edit, settings, tool groups
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // ‚îÄ‚îÄ‚îÄ MCP SERVER HELPERS ‚îÄ‚îÄ‚îÄ
    window.addMcpServerEntry = (containerId, cfg = {}) => {
        const div = document.createElement('div');
        div.className = 'mcp-server-entry';
        div.style.cssText = 'border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px;display:grid;gap:4px;';
        div.innerHTML = `
            <input class="form-input mcp-url" placeholder="https://mcp-server.example.com/mcp" value="${cfg.url || ''}" style="font-size:12px;">
            <input class="form-input mcp-token" placeholder="Bearer token (optional)" value="${cfg.bearerToken || ''}" style="font-size:12px;">
            <div style="display:flex;gap:6px;align-items:center;">
                <input class="form-input mcp-filter" placeholder="Tool filter regexps (comma-sep) or empty=all" value="${cfg.toolFilter && cfg.toolFilter !== 'all' ? cfg.toolFilter.join(', ') : ''}" style="font-size:12px;flex:1;">
                <label style="font-size:11px;white-space:nowrap;display:flex;align-items:center;gap:3px;">
                    <input type="checkbox" class="mcp-agentcore" ${cfg.isAgentCore ? 'checked' : ''}> AgentCore
                </label>
                <button class="btn" type="button" onclick="this.closest('.mcp-server-entry').remove()" style="font-size:11px;padding:1px 6px;">‚úï</button>
            </div>`;
        document.getElementById(containerId).appendChild(div);
    };

    function getMcpServersConfig(containerId) {
        return [...document.getElementById(containerId).querySelectorAll('.mcp-server-entry')].map(el => {
            const url = el.querySelector('.mcp-url').value.trim();
            if (!url) return null;
            const filterVal = el.querySelector('.mcp-filter').value.trim();
            return {
                url,
                bearerToken: el.querySelector('.mcp-token').value.trim() || undefined,
                toolFilter: filterVal ? filterVal.split(',').map(s => s.trim()).filter(Boolean) : 'all',
                isAgentCore: el.querySelector('.mcp-agentcore').checked
            };
        }).filter(Boolean);
    }

    // Import MCP servers from kiro-cli agent JSON format
    // Accepts full agent JSON or just the mcpServers object
    // Only imports http-type servers (stdio not supported in browser)
    window.importMcpFromJson = (containerId) => {
        const json = prompt('Paste kiro-cli agent JSON (or just the mcpServers block):');
        if (!json) return;
        try {
            const parsed = JSON.parse(json);
            const servers = parsed.mcpServers || parsed; // full agent or just mcpServers
            if (typeof servers !== 'object' || Array.isArray(servers)) throw new Error('Expected mcpServers object map');
            let count = 0;
            for (const [name, srv] of Object.entries(servers)) {
                if (srv.disabled) continue;
                // Only http type or servers with a url (skip stdio-only)
                if (!srv.url && srv.type !== 'http') continue;
                const url = srv.url || '';
                if (!url) continue;
                const bearer = srv.headers?.Authorization?.replace(/^Bearer\s+/i, '') || '';
                addMcpServerEntry(containerId, { url, bearerToken: bearer, toolFilter: 'all', isAgentCore: url.includes('gateway.bedrock-agentcore') });
                count++;
            }
            showToast(count ? `Imported ${count} HTTP MCP server${count > 1 ? 's' : ''} (stdio servers skipped)` : 'No HTTP MCP servers found in JSON', count ? 'success' : 'warning');
        } catch (e) { showToast(`Import failed: ${e.message}`, 'error'); }
    };

    async function connectMcpServers(mcpServers) {
        const clients = [], toolNames = [], tools = [];
        for (const srv of mcpServers) {
            try {
                const opts = srv.bearerToken ? { requestInit: { headers: { 'Authorization': `Bearer ${srv.bearerToken}` } } } : {};
                const transport = new StreamableHTTPClientTransport(srv.url, opts);
                const client = new McpClient({ transport });
                await client.connect();
                if (!srv.isAgentCore) {
                    let mcpTools = await client.listTools();
                    if (srv.toolFilter !== 'all') mcpTools = mcpTools.filter(t => srv.toolFilter.some(p => new RegExp(p).test(t.name)));
                    toolNames.push(...mcpTools.map(t => t.name));
                    tools.push(...mcpTools);
                }
                clients.push(client);
                showToast(`MCP: ${srv.isAgentCore ? 'gateway' : tools.length + ' tools'} from ${new URL(srv.url).hostname}`);
            } catch (e) {
                console.warn('MCP connect failed:', srv.url, e);
                showToast(`MCP failed: ${e.message}`, 'error');
            }
        }
        return { clients, toolNames, tools };
    }

    window.openSpawnModal = () => {
        // Reset form with bedrock defaults
        document.getElementById('spawnId').value = '';
        document.getElementById('spawnProvider').value = 'bedrock';
        document.getElementById('spawnModelId').value = '';
        document.getElementById('spawnPrompt').value = '';
        document.getElementById('spawnMaxTokens').value = String(DEFAULT_MAX_TOKENS);
        document.getElementById('spawnAdditionalFields').value = JSON.stringify(DEFAULT_BEDROCK_ADDITIONAL_FIELDS, null, 2);
        document.getElementById('spawnMcpServers').innerHTML = '';
        
        // Update model hint
        updateSpawnModelDefaults();
        
        // Render tools list (all enabled by default)
        renderSpawnToolsList();
        
        document.getElementById('spawnModal').classList.add('active');
    };
    
    window.updateSpawnModelDefaults = function() {
        const provider = document.getElementById('spawnProvider').value;
        const hintEl = document.getElementById('spawnModelHint');
        hintEl.textContent = `Default: ${DEFAULT_MODELS[provider] || 'unknown'}`;
        updateModelDatalist(provider, 'spawnModelList');
        
        // Show/hide additional fields based on provider
        const additionalFieldsGroup = document.getElementById('spawnAdditionalFieldsGroup');
        const additionalFieldsInput = document.getElementById('spawnAdditionalFields');
        
        if (provider === 'bedrock') {
            additionalFieldsGroup.style.display = 'block';
            if (!additionalFieldsInput.value.trim()) {
                additionalFieldsInput.value = JSON.stringify(DEFAULT_BEDROCK_ADDITIONAL_FIELDS, null, 2);
            }
        } else if (provider === 'anthropic') {
            additionalFieldsGroup.style.display = 'block';
        } else {
            additionalFieldsGroup.style.display = 'none';
        }
    };

    window.onModelSelected = function(prefix) {
        const provider = document.getElementById(prefix + 'Provider').value;
        const modelId = document.getElementById(prefix + 'ModelId').value;
        const flags = getModelFlags(provider, modelId);
        if (flags) {
            document.getElementById(prefix + 'AdditionalFields').value = JSON.stringify(flags, null, 2);
        }
    };
    
    function renderSpawnToolsList() {
        const container = document.getElementById('spawnToolsList');
        const allTools = [
            { name: 'render_ui', desc: 'Render HTML/CSS/JS' },
            { name: 'javascript_eval', desc: 'Execute JavaScript' },
            { name: 'storage_get', desc: 'Get localStorage' },
            { name: 'storage_set', desc: 'Set localStorage' },
            { name: 'fetch_url', desc: 'HTTP requests' },
            { name: 'notify', desc: 'Browser notifications' },
            { name: 'update_self', desc: 'Modify system prompt' },
            { name: 'create_tool', desc: 'Create new tools' },
            { name: 'list_tools', desc: 'List all tools' },
            { name: 'delete_tool', desc: 'Delete custom tools' },
            { name: 'use_agent', desc: 'Create sub-agents' },
            { name: 'scheduler', desc: 'Schedule tasks' },
            { name: 'invoke_agent', desc: 'Call another agent' },
            { name: 'broadcast_to_agents', desc: 'Broadcast to all' },
            { name: 'list_agents', desc: 'List all agents' },
            { name: 'invoke_remote_agent', desc: 'Call remote agent' },
            { name: 'subscribe_topic', desc: 'Subscribe to topic' },
            { name: 'publish_topic', desc: 'Publish to topic' },
            { name: 'create_pipeline', desc: 'Create pipeline' },
            { name: 'read_pipeline', desc: 'Read pipeline' },
            { name: 'add_task', desc: 'Add pipeline task' },
            { name: 'update_task_status', desc: 'Update task status' },
            { name: 'update_task_deps', desc: 'Update task deps' },
            { name: 'complete_pipeline', desc: 'Complete pipeline' },
            { name: 'emit_status', desc: 'Emit status update' },
            { name: 'sandbox_create', desc: 'Create sandbox' },
            { name: 'sandbox_update', desc: 'Update sandbox' },
            { name: 'sandbox_read', desc: 'Read sandbox' },
            { name: 'sandbox_list', desc: 'List sandboxes' },
            { name: 'sandbox_delete', desc: 'Delete sandbox' },
            { name: 'github_search', desc: 'Search GitHub' },
            { name: 'github_read_file', desc: 'Read repo file' },
            { name: 'github_list_repos', desc: 'List repos' },
            { name: 'github_create_issue', desc: 'Create issue' },
            { name: 'github_list_issues', desc: 'List issues' },
            { name: 'github_create_pr', desc: 'Create PR' },
            { name: 'github_read_pr', desc: 'Read PR details' }
        ];
        
        container.innerHTML = allTools.map(t => `
            <label class="tool-item enabled" onclick="toggleToolItem(this)">
                <input type="checkbox" name="spawn-tool" value="${t.name}" checked>
                <div>
                    <div class="tool-item-name">${t.name}</div>
                    <div class="tool-item-desc">${t.desc}</div>
                </div>
            </label>
        `).join('');
    }

    const TOOL_GROUPS = {
        core: ['render_ui','javascript_eval','storage_get','storage_set','fetch_url','notify','update_self','create_tool','list_tools','delete_tool'],
        sandbox: ['sandbox_create','sandbox_update','sandbox_read','sandbox_list','sandbox_delete'],
        pipeline: ['create_pipeline','read_pipeline','add_task','update_task_status','update_task_deps','complete_pipeline','emit_status'],
        agents: ['use_agent','scheduler','invoke_agent','broadcast_to_agents','list_agents','invoke_remote_agent','subscribe_topic','publish_topic'],
        github: ['github_search','github_read_file','github_list_repos','github_create_issue','github_list_issues','github_create_pr','github_read_pr']
    };

    window.selectToolGroup = function(group) {
        const boxes = document.querySelectorAll('#spawnToolsList input[name="spawn-tool"]');
        if (group === 'all') { boxes.forEach(b => { b.checked = true; b.closest('.tool-item').classList.add('enabled'); }); return; }
        if (group === 'none') { boxes.forEach(b => { b.checked = false; b.closest('.tool-item').classList.remove('enabled'); }); return; }
        const names = TOOL_GROUPS[group] || [];
        boxes.forEach(b => { b.checked = false; b.closest('.tool-item').classList.remove('enabled'); });
        boxes.forEach(b => { if (names.includes(b.value)) { b.checked = true; b.closest('.tool-item').classList.add('enabled'); } });
    };
    
    window.openEditAgentModal = function(agentId, event) {
        event.stopPropagation();
        const agentData = state.agents.get(agentId);
        if (!agentData) return;
        
        document.getElementById('editAgentId').value = agentId;
        document.getElementById('editAgentTitle').textContent = agentId;
        document.getElementById('editProvider').value = agentData.config.provider;
        document.getElementById('editModelId').value = agentData.config.modelId || '';
        document.getElementById('editPrompt').value = agentData.config.systemPrompt || '';
        document.getElementById('editMaxTokens').value = agentData.config.maxTokens || 16000;
        document.getElementById('editAdditionalFields').value = agentData.config.additionalRequestFields 
            ? JSON.stringify(agentData.config.additionalRequestFields, null, 2) 
            : '';
        const editMcpContainer = document.getElementById('editMcpServers');
        editMcpContainer.innerHTML = '';
        for (const srv of agentData.config.mcpServers || []) addMcpServerEntry('editMcpServers', srv);
        
        // Update model hint
        updateEditModelDefaults();
        
        // Show/hide additional fields based on provider
        const provider = agentData.config.provider;
        document.getElementById('editAdditionalFieldsGroup').style.display = 
            (provider === 'anthropic' || provider === 'bedrock') ? 'block' : 'none';
        
        // Render tools list
        renderEditToolsList(agentData.config.enabledTools || null);
        
        document.getElementById('editAgentModal').classList.add('active');
    };
    
    window.updateEditModelDefaults = function() {
        const provider = document.getElementById('editProvider').value;
        const hintEl = document.getElementById('editModelHint');
        hintEl.textContent = `Default: ${DEFAULT_MODELS[provider] || 'unknown'}`;
        updateModelDatalist(provider, 'editModelList');
        
        // Show/hide additional fields based on provider
        document.getElementById('editAdditionalFieldsGroup').style.display = 
            (provider === 'anthropic' || provider === 'bedrock') ? 'block' : 'none';
    };
    
    function renderEditToolsList(enabledTools) {
        const container = document.getElementById('editToolsList');
        // All available tools with descriptions
        const allTools = [
            { name: 'render_ui', desc: 'Render HTML/CSS/JS' },
            { name: 'javascript_eval', desc: 'Execute JavaScript' },
            { name: 'storage_get', desc: 'Get localStorage' },
            { name: 'storage_set', desc: 'Set localStorage' },
            { name: 'fetch_url', desc: 'HTTP requests' },
            { name: 'notify', desc: 'Browser notifications' },
            { name: 'update_self', desc: 'Modify system prompt' },
            { name: 'create_tool', desc: 'Create new tools' },
            { name: 'list_tools', desc: 'List all tools' },
            { name: 'delete_tool', desc: 'Delete custom tools' },
            { name: 'use_agent', desc: 'Create sub-agents' },
            { name: 'scheduler', desc: 'Schedule tasks' },
            { name: 'invoke_agent', desc: 'Call another agent' },
            { name: 'broadcast_to_agents', desc: 'Broadcast to all' },
            { name: 'list_agents', desc: 'List all agents' },
            { name: 'invoke_remote_agent', desc: 'Call remote agent' },
            { name: 'subscribe_topic', desc: 'Subscribe to topic' },
            { name: 'publish_topic', desc: 'Publish to topic' }
        ];
        
        // If enabledTools is null, all tools are enabled
        const isAllEnabled = enabledTools === null;
        
        container.innerHTML = allTools.map(t => {
            const enabled = isAllEnabled || (enabledTools && enabledTools.includes(t.name));
            return `
                <label class="tool-item ${enabled ? 'enabled' : ''}" onclick="toggleToolItem(this)">
                    <input type="checkbox" name="tool" value="${t.name}" ${enabled ? 'checked' : ''}>
                    <div>
                        <div class="tool-item-name">${t.name}</div>
                        <div class="tool-item-desc">${t.desc}</div>
                    </div>
                </label>
            `;
        }).join('');
    }
    
    window.toggleToolItem = function(el) {
        el.classList.toggle('enabled');
    };
    
    window.saveAgentEdit = async function() {
        const agentId = document.getElementById('editAgentId').value;
        const agentData = state.agents.get(agentId);
        if (!agentData) return;
        
        const provider = document.getElementById('editProvider').value;
        const modelId = document.getElementById('editModelId').value.trim();
        const systemPrompt = document.getElementById('editPrompt').value.trim() || 'You are a helpful AI assistant.';
        const maxTokens = parseInt(document.getElementById('editMaxTokens').value) || DEFAULT_MAX_TOKENS;
        const additionalFieldsStr = document.getElementById('editAdditionalFields').value.trim();
        
        // Parse additional request fields
        let additionalRequestFields = null;
        if (additionalFieldsStr) {
            try {
                additionalRequestFields = JSON.parse(additionalFieldsStr);
            } catch (e) {
                showToast('Invalid JSON in additional fields');
                return;
            }
        }
        
        // Get enabled tools
        const toolCheckboxes = document.querySelectorAll('#editToolsList input[name="tool"]:checked');
        const enabledTools = Array.from(toolCheckboxes).map(cb => cb.value);
        
        // Check if all tools are enabled
        const allToolsEnabled = enabledTools.length === TOOLS.length;
        
        try {
            // Create new model with updated config
            const model = createModel(provider, { 
                modelId: modelId || undefined, 
                maxTokens,
                additionalRequestFields
            });
            
            // Get the tools based on selection + custom tools
            const selectedTools = allToolsEnabled ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();
            const allTools = [...selectedTools, ...customTools];
            
            // Handle MCP server changes
            const mcpServers = getMcpServersConfig('editMcpServers');
            const oldServers = JSON.stringify(agentData.config.mcpServers || []);
            const newServers = JSON.stringify(mcpServers);
            var mcpClients = agentData.mcpClients || [];
            var mcpToolNames = agentData.mcpToolNames || [];
            
            if (newServers !== oldServers) {
                for (const c of mcpClients) c.disconnect().catch(() => {});
                const result = await connectMcpServers(mcpServers);
                mcpClients = result.clients;
                mcpToolNames = result.toolNames;
                allTools.push(...result.tools);
            } else if (mcpClients.length) {
                // Same config ‚Äî re-list tools to merge
                for (const c of mcpClients) {
                    try { const t = await c.listTools(); mcpToolNames.push(...t.map(x => x.name)); allTools.push(...t); } catch (e) {}
                }
            }
            
            // Create new agent instance
            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(agentId, systemPrompt),
                printer: false
            });
            
            // Update agent data
            agentData.agent = agent;
            agentData.model = model;
            agentData.mcpClients = mcpClients;
            agentData.mcpToolNames = mcpToolNames;
            agentData.config = {
                provider,
                modelId: modelId || undefined,
                systemPrompt,
                maxTokens,
                additionalRequestFields,
                enabledTools: allToolsEnabled ? null : enabledTools,
                mcpServers: mcpServers.length ? mcpServers : undefined
            };
            
            closeModal('editAgentModal');
            updateAgentUI();
            saveState();
            showToast(`Agent ${agentId} updated`);
            
            // Update header if this is the active agent
            
            if (agentId === state.activeAgentId) {
                document.getElementById('currentAgentName').textContent = agentId;
                document.getElementById('currentAgentModel').textContent = `${provider} ‚Ä¢ ${modelId || DEFAULT_MODELS[provider]}`;
            }
        } catch (e) {
            showToast('Error: ' + e.message);
        }
    };
    
    window.openSettingsModal = () => {
        document.getElementById('anthropicKey').value = state.credentials.anthropic.apiKey;
        document.getElementById('openaiKey').value = state.credentials.openai.apiKey;
        document.getElementById('bedrockKey').value = state.credentials.bedrock.apiKey;
        document.getElementById('bedrockRegion').value = state.credentials.bedrock.region;
        document.getElementById('githubToken').value = state.credentials.github?.token || '';
        // Load network settings
        document.getElementById('relayUrl').value = localStorage.getItem('mesh_relay_url') || '';
        document.getElementById('instanceId').value = agentMesh.instanceId || '';
        agentMesh.updateWsStatus(agentMesh.wsConnected);
        agentMesh.updateRemotePeersUI();
        document.getElementById('settingsModal').classList.add('active');
    };
    window.closeModal = (id) => document.getElementById(id).classList.remove('active');
    
    window.showTab = function(e, tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
    };
    
    window.toggleScheduleFields = function() {
        const type = document.getElementById('scheduleType').value;
        document.getElementById('delayField').style.display = type === 'once' ? 'block' : 'none';
        document.getElementById('cronField').style.display = type === 'cron' ? 'block' : 'none';
    };
    
    window.toggleMobileSidebar = () => document.getElementById('mobileSidebar').classList.toggle('active');
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SYNC ‚Äî encrypted export/import via URL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async function deriveKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
        return crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
    }
    
    async function encryptData(data, password) {
        const plaintext = JSON.stringify(data);
        const enc = new TextEncoder();
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await deriveKey(password, salt);
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(plaintext));
        const combined = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
        combined.set(salt, 0);
        combined.set(iv, salt.length);
        combined.set(new Uint8Array(ciphertext), salt.length + iv.length);
        return btoa(String.fromCharCode(...combined));
    }
    
    async function decryptData(encryptedBase64, password) {
        const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const ciphertext = combined.slice(28);
        const key = await deriveKey(password, salt);
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
        return JSON.parse(new TextDecoder().decode(plaintext));
    }
    
    window.exportSyncUrl = async function() {
        const password = document.getElementById('syncExportPassword')?.value;
        if (!password || password.length < 4) {
            showToast('Password must be 4+ chars');
            return;
        }
        
        try {
            const data = {
                anthropic: state.credentials.anthropic,
                openai: state.credentials.openai,
                bedrock: state.credentials.bedrock
            };
            const encrypted = await encryptData(data, password);
            const url = `${window.location.origin}${window.location.pathname}?import=${encrypted}`;
            
            document.getElementById('syncExportedUrl').value = url;
            document.getElementById('syncExportResult').style.display = 'block';
            showToast('Settings encrypted!');
        } catch (e) {
            showToast('Export failed: ' + e.message);
        }
    };
    
    window.importSyncUrl = async function() {
        const urlOrData = document.getElementById('syncImportUrl')?.value?.trim();
        const password = document.getElementById('syncImportPassword')?.value;
        
        if (!urlOrData || !password) {
            showToast('Enter URL and password');
            return;
        }
        
        try {
            let encryptedData = urlOrData;
            if (urlOrData.includes('?import=')) {
                encryptedData = new URL(urlOrData).searchParams.get('import');
            }
            
            const data = await decryptData(encryptedData, password);
            
            // Apply credentials
            if (data.anthropic) state.credentials.anthropic = { ...state.credentials.anthropic, ...data.anthropic };
            if (data.openai) state.credentials.openai = { ...state.credentials.openai, ...data.openai };
            if (data.bedrock) state.credentials.bedrock = { ...state.credentials.bedrock, ...data.bedrock };
            
            // Update UI
            document.getElementById('anthropicKey').value = state.credentials.anthropic.apiKey || '';
            document.getElementById('openaiKey').value = state.credentials.openai.apiKey || '';
            document.getElementById('bedrockKey').value = state.credentials.bedrock.apiKey || '';
            document.getElementById('bedrockRegion').value = state.credentials.bedrock.region || 'us-east-1';
            document.getElementById('githubToken').value = state.credentials.github?.token || '';
            
            saveState();
            showToast('Settings imported!');
            
            // Clear fields
            document.getElementById('syncImportUrl').value = '';
            document.getElementById('syncImportPassword').value = '';
        } catch (e) {
            showToast('Import failed - wrong password?');
        }
    };
    
    // Check for ?import= URL param on load
    function checkForImportParam() {
        const url = new URL(window.location.href);
        const importData = url.searchParams.get('import');
        if (importData) {
            window.history.replaceState({}, '', window.location.pathname);
            openSettingsModal();
            setTimeout(() => {
                document.querySelector('.tab[onclick*="sync"]')?.click();
                document.getElementById('syncImportUrl').value = window.location.origin + window.location.pathname + '?import=' + importData;
                showToast('Import URL detected - enter password');
            }, 100);
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PERSISTENCE ‚Äî saveState, loadState, saveCredentials, export/import agents
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.saveCredentials = function() {
        state.credentials.anthropic.apiKey = document.getElementById('anthropicKey').value.trim();
        state.credentials.openai.apiKey = document.getElementById('openaiKey').value.trim();
        state.credentials.bedrock.apiKey = document.getElementById('bedrockKey').value.trim();
        state.credentials.bedrock.region = document.getElementById('bedrockRegion').value;
        state.credentials.github = state.credentials.github || {};
        state.credentials.github.token = document.getElementById('githubToken').value.trim();
        saveState();
        if (window.AgentMesh?.setCredentials) window.AgentMesh.setCredentials({ anthropic: { apiKey: state.credentials.anthropic.apiKey }, openai: { apiKey: state.credentials.openai.apiKey }, bedrock: { apiKey: state.credentials.bedrock.apiKey, region: state.credentials.bedrock.region } });
        showToast('Credentials saved');
        closeModal('settingsModal');
    };
    
    // Network relay functions
    window.connectRelay = function() {
        const url = document.getElementById('relayUrl').value.trim();
        const instanceId = document.getElementById('instanceId').value.trim();
        
        if (!url) {
            showToast('Enter relay URL');
            return;
        }
        
        if (instanceId) {
            agentMesh.instanceId = instanceId;
            localStorage.setItem('mesh_instance_id', instanceId);
        }
        
        agentMesh.connectRelay(url);
    };
    
    window.disconnectRelay = function() {
        agentMesh.disconnectRelay();
        localStorage.removeItem('mesh_relay_url');
    };
    
    function saveState() {
        const data = {
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer.slice(-50)
        };
        
        for (const [id, agentData] of state.agents) {
            data.agents.push({
                id,
                config: agentData.config,
                messages: agentData.messages.slice(-50),
                color: agentData.color
            });
        }
        
        localStorage.setItem('agi_multi_state', JSON.stringify(data));
    }
    
    async function loadState() {
        try {
            const stored = localStorage.getItem('agi_multi_state');
            if (!stored) return;
            
            const data = JSON.parse(stored);
            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];
            
            for (const agentData of data.agents || []) {
                try {
                    const model = createModel(agentData.config.provider, agentData.config);
                    const allTools = [...TOOLS, ...buildCustomTools()];
                    var mcpClients = [];
                    var mcpToolNames = [];
                    
                    // Reconnect MCP servers if configured
                    if (agentData.config.mcpServers?.length) {
                        const result = await connectMcpServers(agentData.config.mcpServers);
                        mcpClients = result.clients;
                        mcpToolNames = result.toolNames;
                        allTools.push(...result.tools);
                    }
                    
                    const agent = new Agent({
                        model,
                        tools: allTools,
                        systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                        printer: false
                    });
                    
                    state.agents.set(agentData.id, {
                        agent,
                        model,
                        config: agentData.config,
                        mcpClients,
                        mcpToolNames,
                        messages: agentData.messages || [],
                        status: 'ready',
                        color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                    });
                } catch (e) {
                    console.warn(`Failed to restore agent ${agentData.id}:`, e);
                }
            }
            
            if (state.agents.size > 0) {
                state.activeAgentId = state.agents.keys().next().value;
            }
        } catch (e) {
            console.warn('Failed to load state:', e);
        }
    }
    
    window.exportAllAgents = function() {
        const data = {
            version: 1,
            exported: new Date().toISOString(),
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer
        };
        
        for (const [id, agentData] of state.agents) {
            data.agents.push({ id, config: agentData.config, messages: agentData.messages, color: agentData.color });
        }
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `agi-multi-export-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('State exported');
    };
    
    window.importAgents = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const data = JSON.parse(text);
            
            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];
            
            for (const agentData of data.agents || []) {
                if (state.agents.has(agentData.id)) continue;
                
                const model = createModel(agentData.config.provider, agentData.config);
                const agent = new Agent({
                    model,
                    tools: TOOLS,
                    systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                    printer: false
                });
                
                state.agents.set(agentData.id, {
                    agent,
                    model,
                    config: agentData.config,
                    messages: agentData.messages || [],
                    status: 'ready',
                    color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                });
            }
            
            updateAgentUI();
            updateRingUI();
            saveState();
            showToast('State imported');
        } catch (e) {
            showToast('Import failed: ' + e.message);
        }
        
        event.target.value = '';
    };
    
    window.clearAllData = function() {
        if (!confirm('Clear all agents and data?')) return;
        localStorage.removeItem('agi_multi_state');
        location.reload();
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CUSTOM TOOLS UI ‚Äî updateCustomToolsUI, deleteCustomTool
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function updateCustomToolsUI() {
        const container = document.getElementById('customToolsList');
        if (!container) return;
        
        const customTools = loadCustomTools();
        const toolNames = Object.keys(customTools);
        
        if (toolNames.length === 0) {
            container.innerHTML = `
                <div style="color:var(--text-tertiary);">
                    No custom tools yet. Agents can create tools with <code>create_tool</code>.
                </div>
            `;
        } else {
            container.innerHTML = `
                <div style="margin-bottom:8px;color:var(--text-secondary);">
                    ${toolNames.length} custom tool(s) saved:
                </div>
                ${toolNames.map(name => {
                    const tool = customTools[name];
                    return `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:6px;margin-bottom:4px;">
                            <div>
                                <code style="color:var(--text)">${name}</code>
                                <span style="color:var(--text-tertiary);font-size:11px;margin-left:8px;">${tool.description?.slice(0,40) || ''}...</span>
                            </div>
                            <button onclick="deleteCustomTool('${name}')" style="background:transparent;border:none;color:rgba(255,100,100,0.6);cursor:pointer;font-size:12px;" title="Delete tool">‚úï</button>
                        </div>
                    `;
                }).join('')}
                <div style="margin-top:12px;font-size:11px;color:var(--text-tertiary);">
                    ‚ö†Ô∏è Custom tools are available to newly spawned agents. Refresh page to apply to all.
                </div>
            `;
        }
    }
    
    window.deleteCustomTool = function(name) {
        if (!confirm(`Delete custom tool "${name}"?`)) return;
        const customTools = loadCustomTools();
        delete customTools[name];
        saveCustomTools(customTools);
        updateCustomToolsUI();
        showToast(`Tool "${name}" deleted`);
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT ‚Äî DOMContentLoaded, autoCreateDefaultAgent, checkForQueryParam
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Panel resizer
    (() => {
        const r = document.getElementById('panelResizer'), panels = document.querySelector('.content-panels');
        if (!r || !panels) return;
        let dragging = false;
        r.addEventListener('mousedown', () => { dragging = true; r.classList.add('dragging'); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; });
        document.addEventListener('mousemove', e => { if (!dragging) return; const rect = panels.getBoundingClientRect(); const pct = ((e.clientX - rect.left) / rect.width * 100); const chat = panels.querySelector('.chat-panel'), act = panels.querySelector('.activity-panel'); chat.style.flex = 'none'; chat.style.width = Math.max(20, Math.min(80, pct)) + '%'; act.style.flex = '1'; });
        document.addEventListener('mouseup', () => { if (dragging) { dragging = false; r.classList.remove('dragging'); document.body.style.cursor = ''; document.body.style.userSelect = ''; } });
    })();

    await loadState();
    updateAgentUI();
    updateRingUI();
    
    // Periodic pipeline refresh while agents are processing
    setInterval(() => {
        const anyProcessing = [...state.agents.values()].some(a => a.status === 'processing');
        if (anyProcessing) updatePipelineUI();
    }, 2000);
    updateScheduleUI();
    renderMessages();
    updatePipelineUI();
    
    // Check for ?q= query parameter (iPhone shortcut support)
    function checkForQueryParam() {
        const url = new URL(window.location.href);
        const query = url.searchParams.get('q');
        
        if (query) {
            // Clear URL params without reload
            window.history.replaceState({}, '', window.location.pathname);
            
            // Wait for agents to initialize, then send query
            setTimeout(async () => {
                if (state.agents.size === 0) {
                    // Try to create default agent first
                    await autoCreateDefaultAgent();
                }
                
                if (state.agents.size > 0) {
                    console.log('üì± Running query from URL param:', query);
                    const targetAgent = state.activeAgentId || state.agents.keys().next().value;
                    if (targetAgent) {
                        runAgentMessage(targetAgent, query);
                    }
                } else {
                    showToast('Add API key in Settings first');
                }
            }, 1500);
        }
    }
    checkForQueryParam();
    
    // Check for ?import= param (encrypted settings sync)
    checkForImportParam();
    
    // Update custom tools UI when tools tab is shown
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            if (e.target.textContent.trim() === 'Tools') {
                updateCustomToolsUI();
            }
        });
    });
    
    // Run auto-create after a short delay to ensure UI is ready
    setTimeout(autoCreateDefaultAgent, 100);
    
    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
    
    const pageName = location.pathname.split('/').pop().replace(/\.html?$/,'') || 'agi.diy';
    document.getElementById('brandTitle').childNodes[0].textContent = pageName + ' ';
    document.title = pageName + ' ‚Äî multi-agent';

    // ‚ïê‚ïê‚ïê EXPOSE FOR AGENT MESH (cross-page communication) ‚ïê‚ïê‚ïê
    window.state = state;
    window.runAgentMessage = runAgentMessage;

    // Listen for credential changes from other tabs
    window.addEventListener('agimesh:credentials', (e) => {
        const c = e.detail;
        if (c.anthropic?.apiKey) state.credentials.anthropic.apiKey = c.anthropic.apiKey;
        if (c.openai?.apiKey) state.credentials.openai.apiKey = c.openai.apiKey;
        if (c.bedrock?.apiKey) state.credentials.bedrock.apiKey = c.bedrock.apiKey;
        showToast('Credentials synced from another tab');
    });
    // Listen for ring context changes from other tabs
    window.addEventListener('storage', (e) => { if (e.key === 'agi-mesh-ring-context') updateRingUI(); });

    // Delayed AgentMesh init (agent-mesh.js loads after this module)
    setTimeout(() => {
        if (!window.AgentMesh?.subscribe) return;
        window.AgentMesh.subscribe('ring-update', () => updateRingUI());
        window.AgentMesh.subscribe('ring-clear', () => updateRingUI());
        // Pull credentials from mesh if we don't have them
        const mc = window.AgentMesh.getCredentials?.();
        if (mc) {
            let u = false;
            if (mc.anthropic?.apiKey && !state.credentials.anthropic.apiKey) { state.credentials.anthropic.apiKey = mc.anthropic.apiKey; u = true; }
            if (mc.openai?.apiKey && !state.credentials.openai.apiKey) { state.credentials.openai.apiKey = mc.openai.apiKey; u = true; }
            if (mc.bedrock?.apiKey && !state.credentials.bedrock.apiKey) { state.credentials.bedrock.apiKey = mc.bedrock.apiKey; u = true; }
            if (u) { saveState(); showToast('üîë Loaded credentials from AgentMesh'); }
        }
    }, 600);

    console.log('%cü¶Ü ' + pageName + ' Multi-Agent v1.0', 'font-size:16px;font-weight:bold;');
    console.log('%cSpawn agents, schedule tasks, let them coordinate via ring attention.', 'color:#888');
    </script>
<script src="agent-mesh.js"></script>
</body>
</html>
