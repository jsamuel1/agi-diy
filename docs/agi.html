<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>agi.diy ‚Äî multi-agent</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü¶Ü</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #0a0a0a;
            --bg-elevated: #111111;
            --glass: rgba(255,255,255,0.03);
            --glass-border: rgba(255,255,255,0.06);
            --glass-hover: rgba(255,255,255,0.08);
            --text: rgba(255,255,255,0.92);
            --text-secondary: rgba(255,255,255,0.55);
            --text-tertiary: rgba(255,255,255,0.35);
            --accent: rgba(255,255,255,0.9);
            --divider: rgba(255,255,255,0.08);
            --agent-colors: #00ff88, #00aaff, #ff88ff, #ffaa00, #ff6666, #88ffff, #ff8888, #88ff88;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            touch-action: pan-x pan-y;
        }
        ::selection { background: rgba(255,255,255,0.15); }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

        /* Layout */
        .app { display: flex; height: 100vh; }
        
        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--bg-elevated);
            border-right: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
        }
        .brand {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .brand-sub {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 400;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .sidebar-section {
            margin-bottom: 24px;
        }
        .sidebar-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        /* Agent Cards */
        .agent-list { display: flex; flex-direction: column; gap: 8px; }
        .agent-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .agent-card:hover { border-color: rgba(255,255,255,0.15); }
        .agent-card.active { border-color: rgba(255,255,255,0.3); background: var(--glass-hover); }
        .agent-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .agent-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .agent-name {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .agent-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(100,255,100,0.2);
            color: rgba(100,255,100,0.9);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .agent-status.processing { background: rgba(255,200,100,0.2); color: rgba(255,200,100,0.9); animation: pulse 1.5s infinite; }
        .agent-status.error { background: rgba(255,100,100,0.2); color: rgba(255,100,100,0.9); }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
        .agent-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            justify-content: space-between;
        }
        .agent-kill {
            opacity: 0;
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            transition: opacity 0.2s;
        }
        .agent-card:hover .agent-kill { opacity: 1; }
        .agent-kill:hover { color: rgba(255,100,100,1); }
        
        /* Spawn Button */
        .spawn-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 2px dashed var(--glass-border);
            border-radius: 12px;
            color: var(--text-tertiary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .spawn-btn:hover {
            border-color: rgba(255,255,255,0.2);
            color: var(--text-secondary);
        }
        
        /* Scheduled Tasks */
        .schedule-item {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .schedule-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .schedule-cron {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .schedule-delete {
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            font-size: 14px;
        }
        .schedule-delete:hover { color: rgba(255,100,100,1); }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        /* Header */
        .header {
            padding: 16px 24px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .current-agent {
            font-size: 14px;
            font-weight: 500;
        }
        .current-agent-model {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        .header-right {
            display: flex;
            gap: 8px;
        }
        .header-btn {
            padding: 8px 14px;
            border-radius: 8px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .header-btn:hover { background: var(--glass-hover); color: var(--text); }
        
        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .messages-inner {
            max-width: 800px;
            margin: 0 auto;
        }
        .message {
            margin-bottom: 32px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .message-role {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
        }
        .message-agent {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--glass);
        }
        .message-time {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .message-content {
            font-size: 14px;
            line-height: 1.8;
        }
        .message.user .message-content { color: var(--text-secondary); }
        .message.system {
            padding: 20px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
        }
        .message.system .message-content {
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        /* Tool Block */
        .tool-block {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 12px 16px;
            margin: 16px 0;
        }
        .tool-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }
        .tool-status.running { background: var(--text); animation: pulse 1.5s infinite; }
        .tool-status.error { background: rgba(255,100,100,0.8); }
        .tool-name {
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .tool-input {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            overflow-x: auto;
            white-space: pre-wrap;
            color: var(--text-tertiary);
        }
        
        /* Dynamic UI */
        .dynamic-ui {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        /* Markdown */
        .markdown-content h1,.markdown-content h2,.markdown-content h3 { margin:20px 0 10px; font-weight:600; }
        .markdown-content h1 { font-size:18px; }
        .markdown-content h2 { font-size:16px; }
        .markdown-content h3 { font-size:14px; }
        .markdown-content code { background:rgba(255,255,255,0.06); padding:2px 6px; border-radius:4px; font-family:'SF Mono',monospace; font-size:12px; }
        .markdown-content pre { background:rgba(0,0,0,0.4); padding:14px; border-radius:8px; overflow-x:auto; margin:14px 0; }
        .markdown-content pre code { background:none; padding:0; }
        .markdown-content a { color:var(--text); text-decoration:underline; text-underline-offset:3px; }
        
        /* Input */
        .input-container {
            padding: 16px 24px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            border-top: 1px solid var(--divider);
        }
        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
        }
        .target-select {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0 12px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            min-width: 100px;
        }
        .target-select:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--text);
            font-size: 14px;
            resize: none;
            min-height: 50px;
            max-height: 150px;
        }
        .input-field:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field::placeholder { color: var(--text-tertiary); }
        .send-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .send-btn:hover { background: var(--glass-hover); color: var(--text); }
        .send-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* Thinking */
        .thinking { display:flex; gap:6px; padding:8px 0; }
        .thinking-dot { width:6px; height:6px; border-radius:50%; background:var(--text-tertiary); animation:bounce 1.4s infinite ease-in-out both; }
        .thinking-dot:nth-child(1) { animation-delay:-0.32s; }
        .thinking-dot:nth-child(2) { animation-delay:-0.16s; }
        @keyframes bounce { 0%,80%,100%{transform:scale(0);opacity:0.3} 40%{transform:scale(1);opacity:1} }
        
        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-title { font-size: 15px; font-weight: 600; }
        .modal-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid var(--glass-border);
            color: var(--text-tertiary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover { background: var(--glass); color: var(--text); }
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .form-group { margin-bottom: 20px; }
        .form-label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            font-weight: 600;
        }
        .form-input {
            width: 100%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px 14px;
            color: var(--text);
            font-size: 13px;
        }
        .form-input:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        textarea.form-input { min-height: 80px; resize: vertical; font-family: inherit; }
        .form-hint { font-size: 11px; color: var(--text-tertiary); margin-top: 6px; }
        .btn {
            padding: 10px 18px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { background: var(--glass-hover); color: var(--text); }
        .btn-primary { background: var(--text); color: var(--bg); border-color: var(--text); }
        .btn-primary:hover { background: rgba(255,255,255,0.85); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--glass);
            border-radius: 8px;
            overflow-x: auto;
        }
        .tab {
            padding: 8px 14px;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        .tab:hover { color: var(--text-secondary); }
        .tab.active { background: var(--bg); color: var(--text); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 10px 18px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0;
            transition: all 0.3s;
            z-index: 300;
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        
        /* Ring Context Panel */
        .ring-panel {
            width: 240px;
            background: var(--bg-elevated);
            border-left: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .ring-header {
            padding: 16px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
        }
        .ring-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ring-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(100,255,100,0.6);
            animation: pulse 2s infinite;
        }
        .ring-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .ring-entry {
            background: var(--glass);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .ring-entry-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        .ring-entry-agent {
            font-weight: 500;
        }
        .ring-entry-time {
            color: var(--text-tertiary);
            font-size: 10px;
        }
        .ring-entry-content {
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Mobile */
        @media (max-width: 900px) {
            .sidebar { display: none; }
            .ring-panel { display: none; }
            .header { padding: 12px 16px; }
            .messages-container { padding: 16px; }
            .input-container { padding: 12px 16px; }
            .target-select { min-width: 80px; font-size: 11px; }
        }
        
        /* Mobile menu */
        .mobile-menu-btn {
            display: none;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        @media (max-width: 900px) {
            .mobile-menu-btn { display: block; }
        }
        .mobile-sidebar {
            position: fixed;
            inset: 0;
            background: var(--bg-elevated);
            z-index: 150;
            transform: translateX(-100%);
            transition: transform 0.3s;
            overflow-y: auto;
        }
        .mobile-sidebar.active { transform: translateX(0); }
        .mobile-sidebar-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="brand">
                    agi.diy
                    <span class="brand-sub">multi-agent</span>
                </div>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <div class="sidebar-title">Agents</div>
                    <div class="agent-list" id="agentList">
                        <!-- Populated by JS -->
                    </div>
                    <button class="spawn-btn" onclick="openSpawnModal()">+ New Agent</button>
                </div>
                <div class="sidebar-section">
                    <div class="sidebar-title">Scheduled Tasks</div>
                    <div id="scheduleList">
                        <div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Main -->
        <main class="main">
            <header class="header">
                <div class="header-left">
                    <button class="mobile-menu-btn" onclick="toggleMobileSidebar()">‚ò∞</button>
                    <div>
                        <div class="current-agent" id="currentAgentName">No Agent Selected</div>
                        <div class="current-agent-model" id="currentAgentModel">‚Äî</div>
                    </div>
                </div>
                <div class="header-right">
                    <button class="header-btn" onclick="broadcastMessage()">üì¢ Broadcast</button>
                    <button class="header-btn" onclick="clearChat()">üóëÔ∏è Clear</button>
                    <button class="header-btn" onclick="openSettingsModal()">‚öôÔ∏è Settings</button>
                </div>
            </header>
            
            <div class="messages-container" id="messagesContainer">
                <div class="messages-inner" id="messagesInner">
                    <div class="message system">
                        <div class="message-content">
                            <strong>Multi-Agent AGI</strong><br><br>
                            Start chatting immediately ‚Äî a default agent is created with your saved credentials.<br><br>
                            ‚Ä¢ <strong>use_agent</strong>: Create sub-agents for parallel tasks<br>
                            ‚Ä¢ <strong>scheduler</strong>: Schedule recurring tasks with cron<br>
                            ‚Ä¢ <strong>Ring Attention</strong>: Agents share context automatically<br><br>
                            Click "+ New Agent" to spawn additional agents, or ‚öôÔ∏è Settings to configure API keys.
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="input-container">
                <div class="input-wrapper">
                    <select class="target-select" id="targetAgent">
                        <option value="all">All Agents</option>
                    </select>
                    <textarea class="input-field" id="inputField" placeholder="Send a message..." rows="1" onkeydown="handleKeyDown(event)"></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
        </main>
        
        <!-- Ring Context Panel -->
        <aside class="ring-panel">
            <div class="ring-header">
                <div class="ring-title">
                    <span class="ring-dot"></span>
                    Ring Context
                </div>
            </div>
            <div class="ring-content" id="ringContent">
                <div style="font-size:11px;color:var(--text-tertiary);text-align:center;padding:20px;">
                    Shared context will appear here
                </div>
            </div>
        </aside>
    </div>
    
    <!-- Mobile Sidebar -->
    <div class="mobile-sidebar" id="mobileSidebar">
        <button class="mobile-sidebar-close" onclick="toggleMobileSidebar()">√ó</button>
        <div style="padding:60px 20px 20px;">
            <div class="sidebar-section">
                <div class="sidebar-title">Agents</div>
                <div class="agent-list" id="mobileAgentList"></div>
                <button class="spawn-btn" onclick="openSpawnModal();toggleMobileSidebar();">+ New Agent</button>
            </div>
        </div>
    </div>
    
    <!-- Spawn Modal -->
    <div class="modal" id="spawnModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Spawn New Agent</span>
                <button class="modal-close" onclick="closeModal('spawnModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Agent ID</label>
                    <input type="text" class="form-input" id="spawnId" placeholder="e.g., researcher, coder">
                </div>
                <div class="form-group">
                    <label class="form-label">Model Provider</label>
                    <select class="form-input" id="spawnProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="bedrock">Amazon Bedrock</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Model ID (optional)</label>
                    <input type="text" class="form-input" id="spawnModelId" placeholder="Leave empty for default">
                    <div class="form-hint">Anthropic: claude-sonnet-4-20250514 | OpenAI: gpt-4o | Bedrock: anthropic.claude-3-sonnet</div>
                </div>
                <div class="form-group">
                    <label class="form-label">System Prompt</label>
                    <textarea class="form-input" id="spawnPrompt" rows="4" placeholder="You are a helpful assistant..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" class="form-input" id="spawnMaxTokens" value="4096">
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('spawnModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="spawnAgent()">Spawn Agent</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Settings</span>
                <button class="modal-close" onclick="closeModal('settingsModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="tabs">
                    <button class="tab active" onclick="showTab(event,'credentials')">API Keys</button>
                    <button class="tab" onclick="showTab(event,'network')">Network</button>
                    <button class="tab" onclick="showTab(event,'tools')">Tools</button>
                    <button class="tab" onclick="showTab(event,'export')">Export</button>
                </div>
                
                <div class="tab-content active" id="tab-credentials">
                    <div class="form-group">
                        <label class="form-label">Anthropic API Key</label>
                        <input type="password" class="form-input" id="anthropicKey" placeholder="sk-ant-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">OpenAI API Key</label>
                        <input type="password" class="form-input" id="openaiKey" placeholder="sk-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock API Key</label>
                        <input type="password" class="form-input" id="bedrockKey" placeholder="bedrock-api-key">
                        <div class="form-hint">Generate at AWS Bedrock Console ‚Üí API Keys</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock Region</label>
                        <select class="form-input" id="bedrockRegion">
                            <option value="us-east-1">us-east-1</option>
                            <option value="us-west-2">us-west-2</option>
                            <option value="eu-west-1">eu-west-1</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="saveCredentials()">Save Credentials</button>
                </div>
                
                <div class="tab-content" id="tab-network">
                    <div class="form-group">
                        <label class="form-label">üåê P2P Network Mode</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Connect to remote agents via WebSocket relay. Local agents use BroadcastChannel automatically.
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Relay Server URL</label>
                        <input type="text" class="form-input" id="relayUrl" placeholder="wss://your-relay.example.com">
                        <div class="form-hint">WebSocket URL for cross-browser/device P2P</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Instance ID</label>
                        <input type="text" class="form-input" id="instanceId" placeholder="Leave blank for auto-generated">
                        <div class="form-hint">Unique identifier for this browser instance</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Connection Status</label>
                        <div id="networkStatus" style="font-family:'SF Mono',monospace;font-size:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;">
                            <div>Local: <span style="color:#0f0">‚óè BroadcastChannel active</span></div>
                            <div>Remote: <span id="wsStatus" style="color:#f66">‚óè Disconnected</span></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Remote Peers</label>
                        <div id="remotePeersList" style="font-size:12px;color:var(--text-tertiary);padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;min-height:40px;">
                            No remote peers connected
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="connectRelay()">Connect</button>
                        <button class="btn" onclick="disconnectRelay()">Disconnect</button>
                    </div>
                </div>
                
                <div class="tab-content" id="tab-tools">
                    <div class="form-group">
                        <label class="form-label">Built-in Tools</label>
                        <div style="font-size:12px;color:var(--text-secondary);line-height:2;">
                            <strong>Core:</strong> <code>render_ui</code> <code>javascript_eval</code> <code>storage_get</code> <code>storage_set</code> <code>fetch_url</code> <code>notify</code><br>
                            <strong>Agents:</strong> <code>use_agent</code> <code>scheduler</code><br>
                            <strong>Mesh:</strong> <code>invoke_agent</code> <code>broadcast_to_agents</code> <code>list_agents</code> <code>invoke_remote_agent</code><br>
                            <strong>PubSub:</strong> <code>subscribe_topic</code> <code>publish_topic</code>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Custom Tools</label>
                        <div id="customToolsList" style="font-size:12px;color:var(--text-tertiary);">
                            Agents can create tools with create_tool
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="tab-export">
                    <div class="form-group">
                        <label class="form-label">Export All Agents</label>
                        <button class="btn" onclick="exportAllAgents()">üì¶ Export State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Import Agents</label>
                        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importAgents(event)">
                        <button class="btn" onclick="document.getElementById('importFile').click()">üì• Import State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Clear All Data</label>
                        <button class="btn" style="color:rgba(255,100,100,0.8)" onclick="clearAllData()">üóëÔ∏è Clear Everything</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Schedule Modal -->
    <div class="modal" id="scheduleModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Schedule Task</span>
                <button class="modal-close" onclick="closeModal('scheduleModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" class="form-input" id="scheduleName" placeholder="daily-summary">
                </div>
                <div class="form-group">
                    <label class="form-label">Agent</label>
                    <select class="form-input" id="scheduleAgent"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Prompt</label>
                    <textarea class="form-input" id="schedulePrompt" rows="3" placeholder="What should the agent do?"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Schedule Type</label>
                    <select class="form-input" id="scheduleType" onchange="toggleScheduleFields()">
                        <option value="once">Once (delayed)</option>
                        <option value="cron">Recurring (cron)</option>
                    </select>
                </div>
                <div class="form-group" id="delayField">
                    <label class="form-label">Delay (seconds)</label>
                    <input type="number" class="form-input" id="scheduleDelay" value="60">
                </div>
                <div class="form-group" id="cronField" style="display:none;">
                    <label class="form-label">Cron Expression</label>
                    <input type="text" class="form-input" id="scheduleCron" placeholder="*/5 * * * *">
                    <div class="form-hint">e.g., */5 * * * * = every 5 minutes</div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('scheduleModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createSchedule()">Schedule</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <!-- Polyfills -->
    <script>
    if (typeof Symbol.dispose === 'undefined') Symbol.dispose = Symbol('Symbol.dispose');
    if (typeof Symbol.asyncDispose === 'undefined') Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
    </script>

    <script type="module">
    import { Agent, tool, Model, z } from './strands.js';
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const state = {
        agents: new Map(),          // agentId -> { agent, model, config, messages, status }
        activeAgentId: null,
        ringBuffer: [],             // Shared context
        schedules: new Map(),       // scheduleId -> { name, agentId, prompt, type, cron/delay, timer }
        credentials: {
            anthropic: { apiKey: '', model: 'claude-sonnet-4-20250514' },
            openai: { apiKey: '', model: 'gpt-4o' },
            bedrock: { apiKey: '', region: 'us-east-1', model: 'anthropic.claude-3-sonnet-20240229-v1:0' }
        },
        agentColors: ['#00ff88', '#00aaff', '#ff88ff', '#ffaa00', '#ff6666', '#88ffff'],
        colorIndex: 0
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODEL PROVIDERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    class AnthropicModel extends Model {
        constructor(config) {
            super();
            this.config = config;
        }
        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens } = this.config;
            if (!apiKey) throw new Error('Anthropic API key not set');
            
            const anthropicMessages = messages.map(msg => ({
                role: msg.role,
                content: msg.content.map(b => {
                    if (b.type === 'textBlock') return { type: 'text', text: b.text };
                    if (b.type === 'toolUseBlock') return { type: 'tool_use', id: b.toolUseId, name: b.name, input: b.input };
                    if (b.type === 'toolResultBlock') {
                        const content = b.content.map(c => c.type === 'textBlock' ? { type: 'text', text: c.text } : { type: 'text', text: JSON.stringify(c.json || c) });
                        return { type: 'tool_result', tool_use_id: b.toolUseId, content };
                    }
                    return { type: 'text', text: String(b) };
                })
            }));
            
            const body = { model: modelId, max_tokens: maxTokens, messages: anthropicMessages, stream: true };
            if (options?.systemPrompt) body.system = typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.filter(b => b.type === 'textBlock').map(b => b.text).join('\n');
            if (options?.toolSpecs?.length) body.tools = options.toolSpecs.map(s => ({ name: s.name, description: s.description, input_schema: s.inputSchema }));
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey, 'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
                body: JSON.stringify(body)
            });
            if (!response.ok) throw new Error(`Anthropic error: ${await response.text()}`);
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                    if (!line.startsWith('data: ')) continue;
                    try {
                        const event = JSON.parse(line.slice(6));
                        if (event.type === 'message_start') yield { type: 'modelMessageStartEvent', role: 'assistant' };
                        else if (event.type === 'content_block_start') {
                            if (event.content_block?.type === 'tool_use') yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', name: event.content_block.name, toolUseId: event.content_block.id } };
                            else yield { type: 'modelContentBlockStartEvent' };
                        }
                        else if (event.type === 'content_block_delta') {
                            if (event.delta?.type === 'text_delta') yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: event.delta.text } };
                            else if (event.delta?.type === 'input_json_delta') yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: event.delta.partial_json } };
                        }
                        else if (event.type === 'content_block_stop') yield { type: 'modelContentBlockStopEvent' };
                        else if (event.type === 'message_delta') {
                            if (event.delta?.stop_reason) {
                                const map = { 'tool_use': 'toolUse', 'max_tokens': 'maxTokens', 'stop_sequence': 'stopSequence' };
                                yield { type: 'modelMessageStopEvent', stopReason: map[event.delta.stop_reason] || 'endTurn' };
                            }
                        }
                    } catch {}
                }
            }
        }
    }
    
    class OpenAIModel extends Model {
        constructor(config) {
            super();
            this.config = config;
        }
        async *stream(messages, options) {
            const { apiKey, modelId, maxTokens } = this.config;
            if (!apiKey) throw new Error('OpenAI API key not set');
            
            const openaiMessages = [];
            if (options?.systemPrompt) {
                const text = typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.filter(b => b.type === 'textBlock').map(b => b.text).join('\n');
                if (text) openaiMessages.push({ role: 'system', content: text });
            }
            
            for (const msg of messages) {
                if (msg.role === 'user') {
                    const toolResults = msg.content.filter(b => b.type === 'toolResultBlock');
                    const other = msg.content.filter(b => b.type !== 'toolResultBlock');
                    if (other.length) openaiMessages.push({ role: 'user', content: other.map(b => b.type === 'textBlock' ? { type: 'text', text: b.text } : { type: 'text', text: String(b) }) });
                    for (const tr of toolResults) openaiMessages.push({ role: 'tool', tool_call_id: tr.toolUseId, content: tr.content.map(c => c.type === 'textBlock' ? c.text : JSON.stringify(c.json || c)).join('') });
                } else {
                    const toolCalls = [];
                    const texts = [];
                    for (const b of msg.content) {
                        if (b.type === 'textBlock') texts.push(b.text);
                        else if (b.type === 'toolUseBlock') toolCalls.push({ id: b.toolUseId, type: 'function', function: { name: b.name, arguments: JSON.stringify(b.input) } });
                    }
                    const m = { role: 'assistant', content: texts.join('') };
                    if (toolCalls.length) m.tool_calls = toolCalls;
                    openaiMessages.push(m);
                }
            }
            
            const body = { model: modelId, max_completion_tokens: maxTokens, messages: openaiMessages, stream: true, stream_options: { include_usage: true } };
            if (options?.toolSpecs?.length) body.tools = options.toolSpecs.map(s => ({ type: 'function', function: { name: s.name, description: s.description, parameters: s.inputSchema } }));
            
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(body)
            });
            if (!response.ok) throw new Error(`OpenAI error: ${await response.text()}`);
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let started = false;
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';
                
                for (const line of lines) {
                    if (!line.startsWith('data: ') || line === 'data: [DONE]') continue;
                    try {
                        const chunk = JSON.parse(line.slice(6));
                        if (!chunk.choices?.length) continue;
                        const choice = chunk.choices[0];
                        const delta = choice.delta;
                        
                        if (delta?.role && !started) { started = true; yield { type: 'modelMessageStartEvent', role: delta.role }; }
                        if (delta?.content) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: delta.content } };
                        if (delta?.tool_calls) {
                            for (const tc of delta.tool_calls) {
                                if (tc.id && tc.function?.name) yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', name: tc.function.name, toolUseId: tc.id } };
                                if (tc.function?.arguments) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: tc.function.arguments } };
                            }
                        }
                        if (choice.finish_reason) {
                            yield { type: 'modelContentBlockStopEvent' };
                            const map = { 'stop': 'endTurn', 'tool_calls': 'toolUse', 'length': 'maxTokens' };
                            yield { type: 'modelMessageStopEvent', stopReason: map[choice.finish_reason] || 'endTurn' };
                        }
                    } catch {}
                }
            }
        }
    }
    
    class BedrockModel extends Model {
        constructor(config) {
            super();
            this.config = config;
        }
        async *stream(messages, options) {
            const { apiKey, region, modelId, maxTokens } = this.config;
            if (!apiKey) throw new Error('Bedrock API key not set');
            
            const formatBlock = b => {
                if (b.type === 'textBlock') return { text: b.text };
                if (b.type === 'toolUseBlock') return { toolUse: { toolUseId: b.toolUseId, name: b.name, input: b.input } };
                if (b.type === 'toolResultBlock') return { toolResult: { toolUseId: b.toolUseId, content: b.content.map(c => c.type === 'textBlock' ? { text: c.text } : { json: c.json || c }) } };
                return { text: String(b) };
            };
            
            const body = {
                messages: messages.map(m => ({ role: m.role, content: m.content.map(formatBlock) })),
                inferenceConfig: { maxTokens }
            };
            if (options?.systemPrompt) body.system = [{ text: typeof options.systemPrompt === 'string' ? options.systemPrompt : options.systemPrompt.map(b => b.text).join('\n') }];
            if (options?.toolSpecs?.length) body.toolConfig = { tools: options.toolSpecs.map(s => ({ toolSpec: { name: s.name, description: s.description, inputSchema: { json: s.inputSchema } } })) };
            
            const response = await fetch(`https://bedrock-runtime.${region}.amazonaws.com/model/${encodeURIComponent(modelId)}/converse-stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(body)
            });
            if (!response.ok) throw new Error(`Bedrock error: ${await response.text()}`);
            
            const reader = response.body.getReader();
            let buffer = new Uint8Array(0);
            const decoder = new TextDecoder();
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const newBuffer = new Uint8Array(buffer.length + value.length);
                newBuffer.set(buffer);
                newBuffer.set(value, buffer.length);
                buffer = newBuffer;
                
                while (buffer.length >= 12) {
                    const totalLength = (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
                    const headersLength = (buffer[4] << 24) | (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];
                    if (totalLength < 16 || totalLength > 1024 * 1024) { buffer = buffer.slice(1); continue; }
                    if (buffer.length < totalLength) break;
                    
                    const payloadStart = 12 + headersLength;
                    const payloadEnd = totalLength - 4;
                    if (payloadEnd > payloadStart) {
                        try {
                            const event = JSON.parse(decoder.decode(buffer.slice(payloadStart, payloadEnd)));
                            if (event.role) yield { type: 'modelMessageStartEvent', role: event.role };
                            else if (event.start?.toolUse) yield { type: 'modelContentBlockStartEvent', start: { type: 'toolUseStart', name: event.start.toolUse.name, toolUseId: event.start.toolUse.toolUseId } };
                            else if (event.start !== undefined) yield { type: 'modelContentBlockStartEvent' };
                            else if (event.delta?.text !== undefined) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'textDelta', text: event.delta.text } };
                            else if (event.delta?.toolUse?.input) yield { type: 'modelContentBlockDeltaEvent', delta: { type: 'toolUseInputDelta', input: event.delta.toolUse.input } };
                            else if (event.contentBlockIndex !== undefined && !event.delta && !event.stopReason) yield { type: 'modelContentBlockStopEvent' };
                            else if (event.stopReason) {
                                const map = { 'end_turn': 'endTurn', 'tool_use': 'toolUse', 'max_tokens': 'maxTokens' };
                                yield { type: 'modelMessageStopEvent', stopReason: map[event.stopReason] || 'endTurn' };
                            }
                        } catch {}
                    }
                    buffer = buffer.slice(totalLength);
                }
            }
        }
    }
    
    function createModel(provider, customConfig = {}) {
        const creds = state.credentials[provider];
        if (provider === 'anthropic') {
            return new AnthropicModel({
                apiKey: creds.apiKey,
                modelId: customConfig.modelId || creds.model || 'claude-sonnet-4-20250514',
                maxTokens: customConfig.maxTokens || 4096
            });
        } else if (provider === 'openai') {
            return new OpenAIModel({
                apiKey: creds.apiKey,
                modelId: customConfig.modelId || creds.model || 'gpt-4o',
                maxTokens: customConfig.maxTokens || 4096
            });
        } else if (provider === 'bedrock') {
            return new BedrockModel({
                apiKey: creds.apiKey,
                region: creds.region || 'us-east-1',
                modelId: customConfig.modelId || creds.model || 'anthropic.claude-3-sonnet-20240229-v1:0',
                maxTokens: customConfig.maxTokens || 4096
            });
        }
        throw new Error(`Unknown provider: ${provider}`);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const renderUiTool = tool({
        name: 'render_ui',
        description: 'Render HTML/CSS/JS in the chat',
        inputSchema: z.object({ html: z.string(), css: z.string().optional(), script: z.string().optional(), title: z.string().optional() }),
        callback: async (input) => {
            const container = document.createElement('div');
            container.className = 'dynamic-ui';
            if (input.title) container.innerHTML = `<div style="font-size:11px;color:var(--text-tertiary);margin-bottom:12px;text-transform:uppercase;letter-spacing:0.05em;">${input.title}</div>`;
            if (input.css) container.innerHTML += `<style>${input.css}</style>`;
            container.innerHTML += input.html;
            document.getElementById('messagesInner').appendChild(container);
            scrollToBottom();
            if (input.script) { try { new Function(input.script).call(container); } catch (e) { return { error: e.message }; } }
            return { rendered: true };
        }
    });
    
    const javascriptEvalTool = tool({
        name: 'javascript_eval',
        description: 'Execute JavaScript',
        inputSchema: z.object({ code: z.string() }),
        callback: async (input) => { try { return { result: String(eval(input.code)) }; } catch (e) { return { error: e.message }; } }
    });
    
    const storageGetTool = tool({
        name: 'storage_get',
        description: 'Get localStorage value',
        inputSchema: z.object({ key: z.string() }),
        callback: async (input) => ({ key: input.key, value: localStorage.getItem(input.key) })
    });
    
    const storageSetTool = tool({
        name: 'storage_set',
        description: 'Set localStorage value',
        inputSchema: z.object({ key: z.string(), value: z.string() }),
        callback: async (input) => { localStorage.setItem(input.key, input.value); return { success: true }; }
    });
    
    const fetchUrlTool = tool({
        name: 'fetch_url',
        description: 'HTTP request',
        inputSchema: z.object({ url: z.string(), method: z.string().optional(), headers: z.record(z.string(), z.string()).optional(), body: z.string().optional() }),
        callback: async (input) => {
            try {
                const r = await fetch(input.url, { method: input.method || 'GET', headers: input.headers, body: input.body });
                const ct = r.headers.get('content-type');
                const data = ct?.includes('json') ? await r.json() : await r.text();
                return { status: r.status, data };
            } catch (e) { return { error: e.message }; }
        }
    });
    
    const notifyTool = tool({
        name: 'notify',
        description: 'Send browser notification',
        inputSchema: z.object({ title: z.string(), body: z.string() }),
        callback: async (input) => {
            if (Notification.permission === 'granted') {
                new Notification(input.title, { body: input.body });
                return { success: true };
            }
            return { error: 'Notifications not permitted' };
        }
    });
    
    // use_agent - spawn sub-agent
    const useAgentTool = tool({
        name: 'use_agent',
        description: 'Create a sub-agent to handle a specific task. The sub-agent runs asynchronously.',
        inputSchema: z.object({
            agentId: z.string().describe('Unique ID for the sub-agent'),
            provider: z.enum(['anthropic', 'openai', 'bedrock']).describe('Model provider'),
            systemPrompt: z.string().describe('System prompt for sub-agent'),
            prompt: z.string().describe('Initial prompt to send'),
            maxTokens: z.number().optional()
        }),
        callback: async (input) => {
            try {
                // Check if agent already exists
                if (state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} already exists` };
                }
                
                // Create sub-agent
                const model = createModel(input.provider, { maxTokens: input.maxTokens || 4096 });
                const subAgent = new Agent({
                    model,
                    tools: [renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool],
                    systemPrompt: input.systemPrompt,
                    printer: false
                });
                
                const color = state.agentColors[state.colorIndex % state.agentColors.length];
                state.colorIndex++;
                
                state.agents.set(input.agentId, {
                    agent: subAgent,
                    model,
                    config: { provider: input.provider, systemPrompt: input.systemPrompt, maxTokens: input.maxTokens || 4096 },
                    messages: [],
                    status: 'ready',
                    color
                });
                
                updateAgentUI();
                
                // Run prompt asynchronously
                setTimeout(() => runAgentMessage(input.agentId, input.prompt), 0);
                
                return { success: true, agentId: input.agentId, message: 'Sub-agent spawned and processing prompt' };
            } catch (e) {
                return { error: e.message };
            }
        }
    });
    
    // scheduler - schedule tasks
    const schedulerTool = tool({
        name: 'scheduler',
        description: 'Schedule a task to run once or on a recurring basis (cron pattern)',
        inputSchema: z.object({
            action: z.enum(['create', 'list', 'delete']),
            name: z.string().optional().describe('Task name'),
            agentId: z.string().optional().describe('Agent to run the task'),
            prompt: z.string().optional().describe('Prompt for the agent'),
            type: z.enum(['once', 'cron']).optional(),
            delay: z.number().optional().describe('Delay in seconds for once'),
            cron: z.string().optional().describe('Cron expression for recurring')
        }),
        callback: async (input) => {
            if (input.action === 'list') {
                const schedules = [];
                for (const [id, s] of state.schedules) {
                    schedules.push({ id, name: s.name, agentId: s.agentId, type: s.type, cron: s.cron, delay: s.delay });
                }
                return { schedules };
            }
            
            if (input.action === 'delete') {
                if (!input.name) return { error: 'Name required for delete' };
                for (const [id, s] of state.schedules) {
                    if (s.name === input.name) {
                        if (s.timer) clearTimeout(s.timer);
                        if (s.interval) clearInterval(s.interval);
                        state.schedules.delete(id);
                        updateScheduleUI();
                        return { success: true, deleted: input.name };
                    }
                }
                return { error: 'Schedule not found' };
            }
            
            if (input.action === 'create') {
                if (!input.name || !input.agentId || !input.prompt || !input.type) {
                    return { error: 'name, agentId, prompt, and type required' };
                }
                if (!state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} not found` };
                }
                
                const id = `schedule-${Date.now()}`;
                const schedule = {
                    name: input.name,
                    agentId: input.agentId,
                    prompt: input.prompt,
                    type: input.type,
                    delay: input.delay,
                    cron: input.cron
                };
                
                if (input.type === 'once') {
                    const delayMs = (input.delay || 60) * 1000;
                    schedule.timer = setTimeout(() => {
                        runAgentMessage(input.agentId, input.prompt);
                        state.schedules.delete(id);
                        updateScheduleUI();
                    }, delayMs);
                    schedule.runAt = new Date(Date.now() + delayMs).toISOString();
                } else if (input.type === 'cron') {
                    // Simple cron parser for common patterns
                    const cronParts = (input.cron || '* * * * *').split(' ');
                    const minute = cronParts[0];
                    
                    // Parse interval from cron (simplified)
                    let intervalMs = 60000; // default 1 minute
                    if (minute.startsWith('*/')) {
                        intervalMs = parseInt(minute.slice(2)) * 60000;
                    }
                    
                    schedule.interval = setInterval(() => {
                        runAgentMessage(input.agentId, input.prompt);
                    }, intervalMs);
                    schedule.nextRun = new Date(Date.now() + intervalMs).toISOString();
                }
                
                state.schedules.set(id, schedule);
                updateScheduleUI();
                saveState();
                
                return { success: true, scheduleId: id, name: input.name, type: input.type };
            }
            
            return { error: 'Invalid action' };
        }
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MESH - Hybrid P2P: BroadcastChannel (local) + WebSocket (remote)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const agentMesh = {
        // Local mesh (same-origin tabs)
        bus: new BroadcastChannel('agi-mesh'),
        
        // Remote mesh (WebSocket relay)
        ws: null,
        wsConnected: false,
        instanceId: localStorage.getItem('mesh_instance_id') || `agi-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,6)}`,
        remotePeers: new Map(), // instanceId -> { agents: [], lastSeen, hostname }
        heartbeatInterval: null,
        
        // Shared state
        pendingRequests: new Map(),
        messageLog: [],
        
        init() {
            // Save instance ID
            localStorage.setItem('mesh_instance_id', this.instanceId);
            
            // Local mesh
            this.bus.onmessage = (e) => this.handleMessage(e.data, 'local');
            
            // Auto-connect if relay URL saved
            const savedRelay = localStorage.getItem('mesh_relay_url');
            if (savedRelay) {
                setTimeout(() => this.connectRelay(savedRelay), 1000);
            }
            
            console.log(`üîó Agent mesh initialized (instance: ${this.instanceId})`);
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // WebSocket Relay Connection
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        connectRelay(url) {
            if (this.ws) this.disconnectRelay();
            
            try {
                this.ws = new WebSocket(url);
                
                this.ws.onopen = () => {
                    this.wsConnected = true;
                    console.log('üåê WebSocket relay connected');
                    this.updateWsStatus(true);
                    
                    // Send presence announcement
                    this.sendRemote({
                        type: 'presence',
                        from: this.instanceId,
                        data: {
                            agents: [...state.agents.keys()],
                            hostname: location.hostname,
                            timestamp: Date.now()
                        }
                    });
                    
                    // Start heartbeat
                    this.heartbeatInterval = setInterval(() => {
                        if (this.wsConnected) {
                            this.sendRemote({
                                type: 'heartbeat',
                                from: this.instanceId,
                                data: { agents: [...state.agents.keys()], timestamp: Date.now() }
                            });
                            // Clean stale peers (no heartbeat in 30s)
                            const now = Date.now();
                            for (const [id, peer] of this.remotePeers) {
                                if (now - peer.lastSeen > 30000) {
                                    this.remotePeers.delete(id);
                                }
                            }
                            this.updateRemotePeersUI();
                        }
                    }, 10000);
                    
                    localStorage.setItem('mesh_relay_url', url);
                    showToast('Relay connected');
                };
                
                this.ws.onmessage = (e) => {
                    try {
                        const msg = JSON.parse(e.data);
                        if (msg.from !== this.instanceId) {
                            this.handleMessage(msg, 'remote');
                        }
                    } catch (err) {
                        console.warn('Invalid relay message:', err);
                    }
                };
                
                this.ws.onclose = () => {
                    this.wsConnected = false;
                    this.updateWsStatus(false);
                    if (this.heartbeatInterval) {
                        clearInterval(this.heartbeatInterval);
                        this.heartbeatInterval = null;
                    }
                    console.log('üåê WebSocket relay disconnected');
                };
                
                this.ws.onerror = (err) => {
                    console.error('WebSocket error:', err);
                    showToast('Relay connection failed');
                };
                
            } catch (err) {
                console.error('Failed to connect relay:', err);
                showToast('Invalid relay URL');
            }
        },
        
        disconnectRelay() {
            if (this.ws) {
                this.ws.close();
                this.ws = null;
            }
            this.wsConnected = false;
            this.remotePeers.clear();
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
                this.heartbeatInterval = null;
            }
            this.updateWsStatus(false);
            this.updateRemotePeersUI();
            showToast('Relay disconnected');
        },
        
        sendRemote(msg) {
            if (this.ws && this.wsConnected) {
                this.ws.send(JSON.stringify(msg));
            }
        },
        
        updateWsStatus(connected) {
            const el = document.getElementById('wsStatus');
            if (el) {
                el.innerHTML = connected 
                    ? '<span style="color:#0f0">‚óè Connected</span>'
                    : '<span style="color:#f66">‚óè Disconnected</span>';
            }
        },
        
        updateRemotePeersUI() {
            const el = document.getElementById('remotePeersList');
            if (!el) return;
            
            if (this.remotePeers.size === 0) {
                el.innerHTML = 'No remote peers connected';
                return;
            }
            
            const peerHtml = [...this.remotePeers.entries()].map(([id, peer]) => {
                const agentCount = peer.agents?.length || 0;
                const age = Math.round((Date.now() - peer.lastSeen) / 1000);
                return `<div style="margin-bottom:4px;">
                    <span style="color:#0f0">‚óè</span> ${id.slice(0,12)}... 
                    <span style="color:var(--text-tertiary)">(${agentCount} agents, ${age}s ago)</span>
                </div>`;
            }).join('');
            
            el.innerHTML = peerHtml;
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Message Handling (both local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        handleMessage(msg, source) {
            const { type, from, to, turnId, data, timestamp } = msg;
            
            // Log for watching
            this.messageLog.push({ type, from, to, turnId, source, data: typeof data === 'string' ? data.slice(0, 100) : data, timestamp });
            if (this.messageLog.length > 200) this.messageLog.shift();
            updateMeshLog();
            
            // Handle presence/heartbeat from remote peers
            if ((type === 'presence' || type === 'heartbeat') && source === 'remote') {
                this.remotePeers.set(from, {
                    agents: data.agents || [],
                    hostname: data.hostname || 'unknown',
                    lastSeen: Date.now()
                });
                this.updateRemotePeersUI();
                return;
            }
            
            // Handle broadcast command
            if (type === 'broadcast' || type === 'direct') {
                // Skip if from ourselves (same instance)
                if (from === this.instanceId) return;
                
                // For local messages, check active agent
                if (source === 'local') {
                    if (type === 'direct' && to !== state.activeAgentId) return;
                    if (from === state.activeAgentId) return;
                }
                
                // Process with local agents
                for (const [agentId, agentData] of state.agents) {
                    if (type === 'direct' && agentId !== to) continue;
                    if (from === agentId) continue;
                    
                    this.processIncomingCommand(agentId, from, turnId, data.command, source);
                }
                return;
            }
            
            // Handle response streams
            if (type === 'stream' || type === 'ack' || type === 'turn_end' || type === 'error') {
                const pending = this.pendingRequests.get(turnId);
                if (!pending) return;
                
                if (type === 'stream') {
                    if (!pending.streamed[from]) pending.streamed[from] = '';
                    pending.streamed[from] += data.chunk;
                    updateStreamingResponse(turnId, from, pending.streamed[from]);
                }
                else if (type === 'ack') {
                    addMeshEvent(from, 'Processing...', 'ack');
                }
                else if (type === 'turn_end') {
                    pending.responses.push({ from, result: data.result, chunks: data.chunks });
                    pending.completed++;
                    if (pending.completed >= pending.expected || pending.timeout) {
                        pending.resolve(pending);
                    }
                }
                else if (type === 'error') {
                    pending.responses.push({ from, error: data.error });
                    pending.completed++;
                }
            }
        },
        
        async processIncomingCommand(agentId, fromId, turnId, command, source) {
            const agentData = state.agents.get(agentId);
            if (!agentData) return;
            
            // Send ACK
            this.publish({ type: 'ack', from: agentId, to: fromId, turnId, timestamp: Date.now() });
            
            agentData.status = 'processing';
            updateAgentUI();
            
            try {
                let fullText = '';
                let chunkCount = 0;
                
                const sourceLabel = source === 'remote' ? `[Remote: ${fromId}]` : `[From agent ${fromId}]`;
                
                for await (const event of agentData.agent.stream(`${sourceLabel}: ${command}`)) {
                    if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                        fullText += event.delta.text;
                        chunkCount++;
                        this.publish({
                            type: 'stream',
                            from: agentId,
                            to: fromId,
                            turnId,
                            data: { chunk: event.delta.text, chunkNum: chunkCount },
                            timestamp: Date.now()
                        });
                    }
                }
                
                this.publish({
                    type: 'turn_end',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { result: fullText, chunks: chunkCount },
                    timestamp: Date.now()
                });
                
                agentData.messages.push({ role: 'user', content: `${sourceLabel}: ${command}`, timestamp: Date.now() });
                agentData.messages.push({ role: 'assistant', content: fullText, timestamp: Date.now() });
                
                state.ringBuffer.push({ agentId, role: 'assistant', content: fullText, timestamp: Date.now() });
                updateRingUI();
                
            } catch (e) {
                this.publish({
                    type: 'error',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { error: e.message },
                    timestamp: Date.now()
                });
            }
            
            agentData.status = 'ready';
            updateAgentUI();
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Publishing (bridges local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        publish(msg) {
            // Always publish to local BroadcastChannel
            this.bus.postMessage(msg);
            
            // Also publish to WebSocket relay if connected
            if (this.wsConnected) {
                this.sendRemote({ ...msg, instanceId: this.instanceId });
            }
            
            // Handle locally for same-tab agents
            setTimeout(() => this.handleMessage(msg, 'local'), 0);
        },
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // High-level API
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        
        async broadcast(fromAgentId, command, waitTime = 30) {
            const turnId = crypto.randomUUID().slice(0, 8);
            
            // Count local + remote agents
            let peerCount = state.agents.size - 1;
            for (const [, peer] of this.remotePeers) {
                peerCount += peer.agents?.length || 0;
            }
            
            if (peerCount === 0) {
                return { error: 'No other agents to broadcast to' };
            }
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: peerCount,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Publish broadcast
                this.publish({
                    type: 'broadcast',
                    from: fromAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },
        
        async sendTo(fromAgentId, toAgentId, command, waitTime = 60) {
            const turnId = crypto.randomUUID().slice(0, 8);
            
            if (!state.agents.has(toAgentId)) {
                return { error: `Agent ${toAgentId} not found` };
            }
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Publish direct message
                this.publish({
                    type: 'direct',
                    from: fromAgentId,
                    to: toAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },
        
        listAgents(includeRemote = true) {
            const agents = [];
            
            // Local agents
            for (const [id, data] of state.agents) {
                agents.push({
                    id,
                    location: 'local',
                    instanceId: this.instanceId,
                    status: data.status,
                    provider: data.config.provider,
                    model: data.config.modelId || 'default',
                    messageCount: data.messages.length
                });
            }
            
            // Remote agents
            if (includeRemote) {
                for (const [instanceId, peer] of this.remotePeers) {
                    for (const agentId of peer.agents || []) {
                        agents.push({
                            id: agentId,
                            location: 'remote',
                            instanceId: instanceId,
                            hostname: peer.hostname,
                            lastSeen: peer.lastSeen
                        });
                    }
                }
            }
            
            return agents;
        },
        
        // Send to remote instance
        async sendToRemoteAgent(fromAgentId, targetInstanceId, targetAgentId, command, waitTime = 60) {
            if (!this.wsConnected) {
                return { error: 'Not connected to relay' };
            }
            
            const peer = this.remotePeers.get(targetInstanceId);
            if (!peer || !peer.agents.includes(targetAgentId)) {
                return { error: `Remote agent ${targetAgentId}@${targetInstanceId} not found` };
            }
            
            const turnId = crypto.randomUUID().slice(0, 8);
            
            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);
                
                // Send direct to remote
                this.sendRemote({
                    type: 'direct',
                    from: fromAgentId,
                    to: targetAgentId,
                    instanceId: this.instanceId,
                    targetInstanceId: targetInstanceId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });
                
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        }
    };
    
    // Initialize mesh
    agentMesh.init();
    
    // Mesh UI helpers
    function updateMeshLog() {
        // Update ring panel with recent mesh activity
        const recent = agentMesh.messageLog.slice(-10).reverse();
        const meshHtml = recent.map(m => {
            const icon = m.type === 'broadcast' ? 'üì¢' : m.type === 'direct' ? 'üì®' : m.type === 'stream' ? 'üì°' : m.type === 'turn_end' ? '‚úÖ' : '‚Ä¢';
            return `<div style="font-size:10px;color:var(--text-tertiary);margin-bottom:4px;">${icon} ${m.from}${m.to ? '‚Üí' + m.to : ''}: ${m.type}</div>`;
        }).join('');
        
        const meshSection = document.getElementById('meshActivity');
        if (meshSection) meshSection.innerHTML = meshHtml || '<div style="font-size:10px;color:var(--text-tertiary);">No mesh activity</div>';
    }
    
    function updateStreamingResponse(turnId, from, text) {
        // Show streaming in a special area or update existing message
        const el = document.getElementById(`mesh-stream-${turnId}-${from}`);
        if (el) {
            el.querySelector('.markdown-content').innerHTML = marked.parse(text);
        }
    }
    
    function addMeshEvent(agentId, message, type) {
        const color = state.agents.get(agentId)?.color || '#888';
        showToast(`üîó ${agentId}: ${message}`);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESH TOOLS - Agent-to-Agent Communication
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // invoke_agent - Call another agent and get response
    const invokeAgentTool = tool({
        name: 'invoke_agent',
        description: 'Send a message to another agent and wait for their response. Use this to delegate tasks or collaborate with other agents.',
        inputSchema: z.object({
            targetAgentId: z.string().describe('ID of the agent to invoke'),
            message: z.string().describe('Message/command to send'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find which agent is calling this
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            if (!state.agents.has(input.targetAgentId)) {
                return { error: `Agent '${input.targetAgentId}' not found`, available: [...state.agents.keys()] };
            }
            
            if (input.targetAgentId === callerAgentId) {
                return { error: 'Cannot invoke yourself' };
            }
            
            const result = await agentMesh.sendTo(callerAgentId, input.targetAgentId, input.message, input.waitTime || 60);
            
            if (result.error) return { error: result.error };
            
            const response = result.responses[0];
            if (response?.error) return { error: response.error };
            
            return {
                success: true,
                from: input.targetAgentId,
                response: result.streamed[input.targetAgentId] || response?.result || 'No response',
                chunks: response?.chunks || 0
            };
        }
    });
    
    // broadcast_to_agents - Send to all agents
    const broadcastToAgentsTool = tool({
        name: 'broadcast_to_agents',
        description: 'Broadcast a message to ALL other agents. Each will process and respond.',
        inputSchema: z.object({
            message: z.string().describe('Message to broadcast'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 30)')
        }),
        callback: async (input, { agent }) => {
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            const result = await agentMesh.broadcast(callerAgentId, input.message, input.waitTime || 30);
            
            if (result.error) return { error: result.error };
            
            const responses = [];
            for (const [agentId, text] of Object.entries(result.streamed)) {
                responses.push({ agentId, response: text });
            }
            for (const r of result.responses) {
                if (r.result && !result.streamed[r.from]) {
                    responses.push({ agentId: r.from, response: r.result });
                }
            }
            
            return {
                success: true,
                broadcastedTo: state.agents.size - 1,
                responses
            };
        }
    });
    
    // list_agents - See available agents (local + remote)
    const listAgentsTool = tool({
        name: 'list_agents',
        description: 'List all available agents (local and remote). Shows agent ID, location (local/remote), instance, and status.',
        inputSchema: z.object({
            includeRemote: z.boolean().optional().describe('Include remote agents from relay (default: true)')
        }),
        callback: async (input) => {
            const includeRemote = input?.includeRemote !== false;
            const agents = agentMesh.listAgents(includeRemote);
            const localCount = agents.filter(a => a.location === 'local').length;
            const remoteCount = agents.filter(a => a.location === 'remote').length;
            return { 
                agents,
                summary: {
                    local: localCount,
                    remote: remoteCount,
                    total: agents.length,
                    relayConnected: agentMesh.wsConnected
                }
            };
        }
    });
    
    // invoke_remote_agent - Call an agent on a remote instance
    const invokeRemoteAgentTool = tool({
        name: 'invoke_remote_agent',
        description: 'Send a message to an agent running on a different browser/device via the relay server. Use list_agents to see remote agents first.',
        inputSchema: z.object({
            instanceId: z.string().describe('Remote instance ID (from list_agents)'),
            agentId: z.string().describe('Agent ID on the remote instance'),
            message: z.string().describe('Message to send'),
            waitTime: z.number().optional().describe('Seconds to wait for response (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find caller agent
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }
            
            const result = await agentMesh.sendToRemoteAgent(
                callerAgentId,
                input.instanceId,
                input.agentId,
                input.message,
                input.waitTime || 60
            );
            
            if (result.error) return { error: result.error };
            
            const response = result.responses[0];
            if (response?.error) return { error: response.error };
            
            return {
                success: true,
                from: `${input.agentId}@${input.instanceId}`,
                response: result.streamed[input.agentId] || response?.result || 'No response'
            };
        }
    });
    
    // subscribe_topic - Watch for messages on a topic
    const subscribeTopicTool = tool({
        name: 'subscribe_topic',
        description: 'Subscribe to a topic to receive messages. Creates a listener that triggers on new messages.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name to subscribe to'),
            handler: z.string().describe('JavaScript code to run when message received (receives msg parameter)')
        }),
        callback: async (input) => {
            // Store subscription
            if (!state.subscriptions) state.subscriptions = new Map();
            
            const subId = `sub-${Date.now()}`;
            state.subscriptions.set(subId, {
                topic: input.topic,
                handler: new Function('msg', input.handler)
            });
            
            return { success: true, subscriptionId: subId, topic: input.topic };
        }
    });
    
    // publish_topic - Publish to a topic
    const publishTopicTool = tool({
        name: 'publish_topic',
        description: 'Publish a message to a topic. All subscribers will receive it.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name'),
            message: z.any().describe('Message to publish (string or object)')
        }),
        callback: async (input) => {
            agentMesh.publish({
                type: 'topic',
                topic: input.topic,
                data: input.message,
                timestamp: Date.now()
            });
            
            // Notify local subscribers
            if (state.subscriptions) {
                for (const [id, sub] of state.subscriptions) {
                    if (sub.topic === input.topic) {
                        try {
                            sub.handler(input.message);
                        } catch (e) {
                            console.error(`Subscription ${id} error:`, e);
                        }
                    }
                }
            }
            
            return { success: true, topic: input.topic };
        }
    });
    
    const TOOLS = [
        // Core
        renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool,
        // Agent management
        useAgentTool, schedulerTool,
        // Mesh communication (local + remote)
        invokeAgentTool, broadcastToAgentsTool, listAgentsTool, invokeRemoteAgentTool, subscribeTopicTool, publishTopicTool
    ];
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MANAGEMENT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.spawnAgent = async function() {
        const id = document.getElementById('spawnId').value.trim();
        const provider = document.getElementById('spawnProvider').value;
        const modelId = document.getElementById('spawnModelId').value.trim();
        const systemPrompt = document.getElementById('spawnPrompt').value.trim() || 'You are a helpful AI assistant.';
        const maxTokens = parseInt(document.getElementById('spawnMaxTokens').value) || 4096;
        
        if (!id) { showToast('Enter agent ID'); return; }
        if (state.agents.has(id)) { showToast('Agent ID exists'); return; }
        
        try {
            const model = createModel(provider, { modelId: modelId || undefined, maxTokens });
            const agent = new Agent({
                model,
                tools: TOOLS,
                systemPrompt: buildSystemPrompt(id, systemPrompt),
                printer: false
            });
            
            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;
            
            state.agents.set(id, {
                agent,
                model,
                config: { provider, modelId, systemPrompt, maxTokens },
                messages: [],
                status: 'ready',
                color
            });
            
            closeModal('spawnModal');
            document.getElementById('spawnId').value = '';
            document.getElementById('spawnModelId').value = '';
            document.getElementById('spawnPrompt').value = '';
            
            updateAgentUI();
            selectAgent(id);
            showToast(`Agent ${id} spawned`);
            saveState();
        } catch (e) {
            showToast('Error: ' + e.message);
        }
    };
    
    function buildSystemPrompt(agentId, basePrompt) {
        return `${basePrompt}

## Multi-Agent Context
You are agent "${agentId}" in a multi-agent system. You have access to:
- use_agent: Create sub-agents for parallel tasks
- scheduler: Schedule tasks (once or recurring cron)

Ring Attention: Other agents' recent messages are shared with you for context.

${getRingContext()}`;
    }
    
    function getRingContext() {
        if (state.ringBuffer.length === 0) return '';
        const recent = state.ringBuffer.slice(-10);
        return '## Recent Messages from Other Agents:\n' + recent.map(e => `[${e.agentId}]: ${e.content.slice(0, 200)}...`).join('\n');
    }
    
    window.selectAgent = function(agentId) {
        state.activeAgentId = agentId;
        updateAgentUI();
        renderMessages();
        
        const agentData = state.agents.get(agentId);
        if (agentData) {
            document.getElementById('currentAgentName').textContent = agentId;
            document.getElementById('currentAgentModel').textContent = `${agentData.config.provider} ‚Ä¢ ${agentData.config.modelId || 'default'}`;
        }
    };
    
    window.killAgent = function(agentId, event) {
        event.stopPropagation();
        if (!confirm(`Kill agent ${agentId}?`)) return;
        
        state.agents.delete(agentId);
        if (state.activeAgentId === agentId) {
            state.activeAgentId = state.agents.keys().next().value || null;
        }
        updateAgentUI();
        renderMessages();
        showToast(`Agent ${agentId} killed`);
        saveState();
    };
    
    function updateAgentUI() {
        const agentListHtml = [];
        const targetOptions = ['<option value="all">All Agents</option>'];
        
        for (const [id, data] of state.agents) {
            const isActive = id === state.activeAgentId;
            agentListHtml.push(`
                <div class="agent-card ${isActive ? 'active' : ''}" onclick="selectAgent('${id}')">
                    <div class="agent-card-header">
                        <span class="agent-dot" style="background:${data.color}"></span>
                        <span class="agent-name">${id}</span>
                        <span class="agent-status ${data.status}">${data.status}</span>
                    </div>
                    <div class="agent-meta">
                        <span>${data.config.provider}</span>
                        <span class="agent-kill" onclick="killAgent('${id}', event)">‚úï</span>
                    </div>
                </div>
            `);
            targetOptions.push(`<option value="${id}">${id}</option>`);
        }
        
        document.getElementById('agentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('mobileAgentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('targetAgent').innerHTML = targetOptions.join('');
        
        // Update schedule agent dropdown
        const scheduleAgentSelect = document.getElementById('scheduleAgent');
        if (scheduleAgentSelect) {
            scheduleAgentSelect.innerHTML = [...state.agents.keys()].map(id => `<option value="${id}">${id}</option>`).join('');
        }
    }
    
    function updateScheduleUI() {
        const container = document.getElementById('scheduleList');
        if (state.schedules.size === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>';
            return;
        }
        
        let html = '';
        for (const [id, s] of state.schedules) {
            html += `
                <div class="schedule-item">
                    <div class="schedule-item-header">
                        <strong>${s.name}</strong>
                        <span class="schedule-delete" onclick="deleteSchedule('${id}')">‚úï</span>
                    </div>
                    <div>Agent: ${s.agentId}</div>
                    <div class="schedule-cron">${s.type === 'cron' ? s.cron : `once in ${s.delay}s`}</div>
                </div>
            `;
        }
        container.innerHTML = html;
    }
    
    window.deleteSchedule = function(id) {
        const s = state.schedules.get(id);
        if (s) {
            if (s.timer) clearTimeout(s.timer);
            if (s.interval) clearInterval(s.interval);
            state.schedules.delete(id);
            updateScheduleUI();
            saveState();
            showToast('Schedule deleted');
        }
    };
    
    // Auto-create default agent if none exist and credentials are available
    async function autoCreateDefaultAgent() {
        if (state.agents.size > 0) return; // Already have agents
        
        // Check for any configured credentials
        const hasAnthropic = state.credentials.anthropic.apiKey;
        const hasOpenAI = state.credentials.openai.apiKey;
        const hasBedrock = state.credentials.bedrock.apiKey;
        
        if (!hasAnthropic && !hasOpenAI && !hasBedrock) {
            console.log('No API keys configured - please add credentials in settings');
            return;
        }
        
        // Determine which provider to use (priority: anthropic > openai > bedrock)
        let provider = 'anthropic';
        if (hasAnthropic) provider = 'anthropic';
        else if (hasOpenAI) provider = 'openai';
        else if (hasBedrock) provider = 'bedrock';
        
        try {
            const model = createModel(provider);
            const agent = new Agent({
                model,
                tools: TOOLS,
                systemPrompt: buildSystemPrompt('assistant', 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, and coordinate with other agents.'),
                printer: false
            });
            
            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;
            
            state.agents.set('assistant', {
                agent,
                model,
                config: { 
                    provider, 
                    systemPrompt: 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, and coordinate with other agents.', 
                    maxTokens: 4096 
                },
                messages: [],
                status: 'ready',
                color
            });
            
            state.activeAgentId = 'assistant';
            updateAgentUI();
            renderMessages();
            saveState();
            
            console.log('‚úÖ Default agent "assistant" created automatically');
            showToast('Default agent ready');
        } catch (e) {
            console.warn('Could not auto-create default agent:', e);
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESSAGING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let streamingEl = null;
    
    // Message queue per agent to handle concurrent requests
    const messageQueues = new Map();
    
    async function runAgentMessage(agentId, message) {
        const agentData = state.agents.get(agentId);
        if (!agentData) return;
        
        // Initialize queue for this agent if needed
        if (!messageQueues.has(agentId)) {
            messageQueues.set(agentId, { processing: false, queue: [] });
        }
        const queueData = messageQueues.get(agentId);
        
        // If already processing, queue the message
        if (queueData.processing) {
            queueData.queue.push(message);
            showToast(`Message queued (${queueData.queue.length} pending)`);
            console.log(`Agent ${agentId} busy, queued message. Queue size: ${queueData.queue.length}`);
            return;
        }
        
        queueData.processing = true;
        agentData.status = 'processing';
        updateAgentUI();
        
        // Add to ring buffer
        state.ringBuffer.push({ agentId, role: 'user', content: message, timestamp: Date.now() });
        if (state.ringBuffer.length > 100) state.ringBuffer.shift();
        updateRingUI();
        
        // Add user message
        agentData.messages.push({ role: 'user', content: message, timestamp: Date.now() });
        if (agentId === state.activeAgentId) {
            addMessageToUI('user', message, agentId, agentData.color);
            addThinking();
        }
        
        try {
            let currentText = '';
            
            for await (const event of agentData.agent.stream(message)) {
                if (!event?.type) continue;
                
                if (event.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                    currentText += event.delta.text;
                    if (agentId === state.activeAgentId) updateStreaming(currentText, agentId, agentData.color);
                }
                else if (event.type === 'beforeToolCallEvent' && agentId === state.activeAgentId) {
                    addToolCall(event.toolUse?.name, event.toolUse?.input, 'running');
                }
                else if (event.type === 'afterToolCallEvent' && agentId === state.activeAgentId) {
                    updateToolStatus(event.toolUse?.name, event.result?.status || 'success');
                }
            }
            
            if (agentId === state.activeAgentId) {
                removeThinking();
                if (currentText) finalizeStreaming(currentText, agentId, agentData.color);
            }
            
            agentData.messages.push({ role: 'assistant', content: currentText, timestamp: Date.now() });
            
            // Add to ring buffer
            state.ringBuffer.push({ agentId, role: 'assistant', content: currentText, timestamp: Date.now() });
            if (state.ringBuffer.length > 100) state.ringBuffer.shift();
            updateRingUI();
            
            agentData.status = 'ready';
        } catch (e) {
            console.error(`Agent ${agentId} error:`, e);
            agentData.status = 'error';
            if (agentId === state.activeAgentId) {
                removeThinking();
                addMessageToUI('error', e.message, agentId, agentData.color);
            }
        }
        
        updateAgentUI();
        saveState();
        
        // Process next queued message if any
        const queueData = messageQueues.get(agentId);
        if (queueData) {
            queueData.processing = false;
            if (queueData.queue.length > 0) {
                const nextMessage = queueData.queue.shift();
                console.log(`Processing queued message for ${agentId}. Remaining: ${queueData.queue.length}`);
                // Use setTimeout to prevent stack overflow on long queues
                setTimeout(() => runAgentMessage(agentId, nextMessage), 100);
            }
        }
    }
    
    window.sendMessage = async function() {
        const input = document.getElementById('inputField');
        const text = input.value.trim();
        if (!text) return;
        
        const target = document.getElementById('targetAgent').value;
        
        // If no agents exist, try to create default agent first
        if (state.agents.size === 0) {
            const hasAnyKey = state.credentials.anthropic.apiKey || 
                              state.credentials.openai.apiKey || 
                              state.credentials.bedrock.apiKey;
            
            if (!hasAnyKey) {
                showToast('Add API key in Settings first');
                openSettingsModal();
                return;
            }
            
            // Create default agent on the fly
            showToast('Creating agent...');
            await autoCreateDefaultAgent();
            
            if (state.agents.size === 0) {
                showToast('Failed to create agent');
                return;
            }
        }
        
        input.value = '';
        
        if (target === 'all') {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text);
            }
        } else {
            runAgentMessage(target, text);
        }
    };
    
    window.broadcastMessage = function() {
        const text = prompt('Broadcast message to all agents:');
        if (text?.trim()) {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text.trim());
            }
        }
    };
    
    window.clearChat = function() {
        if (!state.activeAgentId) {
            showToast('No active agent to clear');
            return;
        }
        
        const agentData = state.agents.get(state.activeAgentId);
        if (agentData) {
            agentData.messages = [];
            renderMessages();
            showToast('Chat cleared');
            saveState();
        }
    };
    
    window.handleKeyDown = function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function renderMessages() {
        const inner = document.getElementById('messagesInner');
        inner.innerHTML = '';
        
        if (!state.activeAgentId) {
            inner.innerHTML = `<div class="message system"><div class="message-content">
                <strong>Getting Started</strong><br><br>
                ${Object.values(state.credentials).some(c => c.apiKey) 
                    ? 'Creating default agent... If this takes too long, try clicking "+ New Agent".'
                    : 'Add your API key in ‚öôÔ∏è Settings to start chatting, or click "+ New Agent" to configure a new agent.'}
            </div></div>`;
            document.getElementById('currentAgentName').textContent = 'No Agent Selected';
            document.getElementById('currentAgentModel').textContent = '‚Äî';
            return;
        }
        
        const agentData = state.agents.get(state.activeAgentId);
        if (!agentData) return;
        
        for (const msg of agentData.messages) {
            addMessageToUI(msg.role, msg.content, state.activeAgentId, agentData.color, false);
        }
        scrollToBottom();
    }
    
    function addMessageToUI(role, content, agentId, color, scroll = true) {
        const inner = document.getElementById('messagesInner');
        const msg = document.createElement('div');
        msg.className = `message ${role}`;
        
        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        msg.innerHTML = `
            <div class="message-header">
                <span class="message-role">${role === 'user' ? 'you' : role === 'assistant' ? 'agi' : role}</span>
                <span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>
                <span class="message-time">${time}</span>
            </div>
            <div class="message-content">${role === 'user' ? escapeHtml(content) : `<div class="markdown-content">${marked.parse(content)}</div>`}</div>
        `;
        
        inner.appendChild(msg);
        if (scroll) scrollToBottom();
    }
    
    function updateStreaming(text, agentId, color) {
        const inner = document.getElementById('messagesInner');
        removeThinking();
        
        if (!streamingEl) {
            streamingEl = document.createElement('div');
            streamingEl.className = 'message assistant';
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            streamingEl.innerHTML = `
                <div class="message-header">
                    <span class="message-role">agi</span>
                    <span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content"><div class="markdown-content"></div></div>
            `;
            inner.appendChild(streamingEl);
        }
        
        streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
        scrollToBottom();
    }
    
    function finalizeStreaming(text, agentId, color) {
        if (streamingEl) {
            streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
            streamingEl = null;
        }
    }
    
    function addToolCall(name, input, status) {
        const inner = document.getElementById('messagesInner');
        const tool = document.createElement('div');
        tool.className = 'tool-block';
        tool.id = `tool-${name}-${Date.now()}`;
        tool.innerHTML = `
            <div class="tool-header">
                <div class="tool-status ${status}"></div>
                <span class="tool-name">${name}</span>
            </div>
            <details><summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:8px;">input</summary>
            <div class="tool-input">${JSON.stringify(input, null, 2)}</div></details>
        `;
        inner.appendChild(tool);
        scrollToBottom();
    }
    
    function updateToolStatus(name, status) {
        const blocks = document.querySelectorAll('.tool-block');
        for (let i = blocks.length - 1; i >= 0; i--) {
            if (blocks[i].querySelector('.tool-name')?.textContent === name) {
                blocks[i].querySelector('.tool-status').className = `tool-status ${status === 'error' ? 'error' : ''}`;
                break;
            }
        }
    }
    
    function addThinking() {
        const inner = document.getElementById('messagesInner');
        if (inner.querySelector('.thinking-indicator')) return;
        const el = document.createElement('div');
        el.className = 'message assistant thinking-indicator';
        el.innerHTML = '<div class="message-content"><div class="thinking"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div></div>';
        inner.appendChild(el);
        scrollToBottom();
    }
    
    function removeThinking() {
        document.querySelector('.thinking-indicator')?.remove();
    }
    
    function updateRingUI() {
        const container = document.getElementById('ringContent');
        const recent = state.ringBuffer.slice(-20).reverse();
        
        if (recent.length === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);text-align:center;padding:20px;">Shared context will appear here</div>';
            return;
        }
        
        container.innerHTML = recent.map(e => {
            const agentData = state.agents.get(e.agentId);
            const color = agentData?.color || '#888';
            const time = new Date(e.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `
                <div class="ring-entry">
                    <div class="ring-entry-header">
                        <span class="ring-entry-agent" style="color:${color}">${e.agentId}</span>
                        <span class="ring-entry-time">${time}</span>
                    </div>
                    <div class="ring-entry-content">${escapeHtml(e.content.slice(0, 150))}${e.content.length > 150 ? '...' : ''}</div>
                </div>
            `;
        }).join('');
    }
    
    function scrollToBottom() {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODALS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.openSpawnModal = () => document.getElementById('spawnModal').classList.add('active');
    window.openSettingsModal = () => {
        document.getElementById('anthropicKey').value = state.credentials.anthropic.apiKey;
        document.getElementById('openaiKey').value = state.credentials.openai.apiKey;
        document.getElementById('bedrockKey').value = state.credentials.bedrock.apiKey;
        document.getElementById('bedrockRegion').value = state.credentials.bedrock.region;
        // Load network settings
        document.getElementById('relayUrl').value = localStorage.getItem('mesh_relay_url') || '';
        document.getElementById('instanceId').value = agentMesh.instanceId || '';
        agentMesh.updateWsStatus(agentMesh.wsConnected);
        agentMesh.updateRemotePeersUI();
        document.getElementById('settingsModal').classList.add('active');
    };
    window.closeModal = (id) => document.getElementById(id).classList.remove('active');
    
    window.showTab = function(e, tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
    };
    
    window.toggleScheduleFields = function() {
        const type = document.getElementById('scheduleType').value;
        document.getElementById('delayField').style.display = type === 'once' ? 'block' : 'none';
        document.getElementById('cronField').style.display = type === 'cron' ? 'block' : 'none';
    };
    
    window.toggleMobileSidebar = () => document.getElementById('mobileSidebar').classList.toggle('active');
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CREDENTIALS & PERSISTENCE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.saveCredentials = function() {
        state.credentials.anthropic.apiKey = document.getElementById('anthropicKey').value.trim();
        state.credentials.openai.apiKey = document.getElementById('openaiKey').value.trim();
        state.credentials.bedrock.apiKey = document.getElementById('bedrockKey').value.trim();
        state.credentials.bedrock.region = document.getElementById('bedrockRegion').value;
        saveState();
        showToast('Credentials saved');
        closeModal('settingsModal');
    };
    
    // Network relay functions
    window.connectRelay = function() {
        const url = document.getElementById('relayUrl').value.trim();
        const instanceId = document.getElementById('instanceId').value.trim();
        
        if (!url) {
            showToast('Enter relay URL');
            return;
        }
        
        if (instanceId) {
            agentMesh.instanceId = instanceId;
            localStorage.setItem('mesh_instance_id', instanceId);
        }
        
        agentMesh.connectRelay(url);
    };
    
    window.disconnectRelay = function() {
        agentMesh.disconnectRelay();
        localStorage.removeItem('mesh_relay_url');
    };
    
    function saveState() {
        const data = {
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer.slice(-50)
        };
        
        for (const [id, agentData] of state.agents) {
            data.agents.push({
                id,
                config: agentData.config,
                messages: agentData.messages.slice(-50),
                color: agentData.color
            });
        }
        
        localStorage.setItem('agi_multi_state', JSON.stringify(data));
    }
    
    function loadState() {
        try {
            const stored = localStorage.getItem('agi_multi_state');
            if (!stored) return;
            
            const data = JSON.parse(stored);
            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];
            
            for (const agentData of data.agents || []) {
                try {
                    const model = createModel(agentData.config.provider, agentData.config);
                    const agent = new Agent({
                        model,
                        tools: TOOLS,
                        systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                        printer: false
                    });
                    
                    state.agents.set(agentData.id, {
                        agent,
                        model,
                        config: agentData.config,
                        messages: agentData.messages || [],
                        status: 'ready',
                        color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                    });
                } catch (e) {
                    console.warn(`Failed to restore agent ${agentData.id}:`, e);
                }
            }
            
            if (state.agents.size > 0) {
                state.activeAgentId = state.agents.keys().next().value;
            }
        } catch (e) {
            console.warn('Failed to load state:', e);
        }
    }
    
    window.exportAllAgents = function() {
        const data = {
            version: 1,
            exported: new Date().toISOString(),
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer
        };
        
        for (const [id, agentData] of state.agents) {
            data.agents.push({ id, config: agentData.config, messages: agentData.messages, color: agentData.color });
        }
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `agi-multi-export-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('State exported');
    };
    
    window.importAgents = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const data = JSON.parse(text);
            
            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];
            
            for (const agentData of data.agents || []) {
                if (state.agents.has(agentData.id)) continue;
                
                const model = createModel(agentData.config.provider, agentData.config);
                const agent = new Agent({
                    model,
                    tools: TOOLS,
                    systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                    printer: false
                });
                
                state.agents.set(agentData.id, {
                    agent,
                    model,
                    config: agentData.config,
                    messages: agentData.messages || [],
                    status: 'ready',
                    color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                });
            }
            
            updateAgentUI();
            updateRingUI();
            saveState();
            showToast('State imported');
        } catch (e) {
            showToast('Import failed: ' + e.message);
        }
        
        event.target.value = '';
    };
    
    window.clearAllData = function() {
        if (!confirm('Clear all agents and data?')) return;
        localStorage.removeItem('agi_multi_state');
        location.reload();
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    loadState();
    updateAgentUI();
    updateRingUI();
    updateScheduleUI();
    renderMessages();
    
    // Run auto-create after a short delay to ensure UI is ready
    setTimeout(autoCreateDefaultAgent, 100);
    
    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
    
    console.log('%cü¶Ü agi.diy Multi-Agent v1.0', 'font-size:16px;font-weight:bold;');
    console.log('%cSpawn agents, schedule tasks, let them coordinate via ring attention.', 'color:#888');
    </script>
</body>
</html>
