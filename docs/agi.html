<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>agi.diy ‚Äî multi-agent</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óà</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #0a0a0a;
            --bg-elevated: #111111;
            --glass: rgba(255,255,255,0.03);
            --glass-border: rgba(255,255,255,0.06);
            --glass-hover: rgba(255,255,255,0.08);
            --text: rgba(255,255,255,0.92);
            --text-secondary: rgba(255,255,255,0.55);
            --text-tertiary: rgba(255,255,255,0.35);
            --accent: rgba(255,255,255,0.9);
            --divider: rgba(255,255,255,0.08);
            --agent-colors: #00ff88, #00aaff, #ff88ff, #ffaa00, #ff6666, #88ffff, #ff8888, #88ff88;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            touch-action: pan-x pan-y;
            -webkit-text-size-adjust: 100%; /* Prevent text size adjustment on iOS */
        }
        ::selection { background: rgba(255,255,255,0.15); }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

        /* Layout */
        .app { display: flex; height: 100vh; }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: var(--bg-elevated);
            border-right: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .sidebar-header {
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
        }
        .brand {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .brand-sub {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 400;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .sidebar-section {
            margin-bottom: 24px;
        }
        .sidebar-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-tertiary);
            margin-bottom: 12px;
            font-weight: 600;
        }

        /* Agent Cards */
        .agent-list { display: flex; flex-direction: column; gap: 8px; }
        .agent-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover { border-color: rgba(255,255,255,0.15); }
        .agent-card:active { transform: scale(0.98); }
        .agent-card.active { border-color: rgba(255,255,255,0.3); background: var(--glass-hover); }
        .agent-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .agent-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .agent-name {
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .agent-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(100,255,100,0.2);
            color: rgba(100,255,100,0.9);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .agent-status.processing { background: rgba(255,200,100,0.2); color: rgba(255,200,100,0.9); animation: pulse 1.5s infinite; }
        .agent-status.error { background: rgba(255,100,100,0.2); color: rgba(255,100,100,0.9); }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
        .agent-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            justify-content: space-between;
        }
        .agent-kill {
            opacity: 0;
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            transition: opacity 0.2s;
            padding: 4px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover .agent-kill { opacity: 1; }
        .agent-card.active .agent-kill { opacity: 1; } /* Show on active/selected */
        .agent-kill:hover { color: rgba(255,100,100,1); }
        .agent-edit {
            opacity: 0;
            cursor: pointer;
            color: var(--text-tertiary);
            transition: opacity 0.2s;
            margin-right: 8px;
            padding: 4px;
            -webkit-tap-highlight-color: transparent;
        }
        .agent-card:hover .agent-edit { opacity: 1; }
        .agent-card.active .agent-edit { opacity: 1; } /* Show on active/selected */
        .agent-edit:hover { color: var(--text); }

        /* Mobile: always show edit/kill buttons */
        @media (max-width: 900px) {
            .agent-kill, .agent-edit { opacity: 0.7; }
            .agent-card.active .agent-kill,
            .agent-card.active .agent-edit { opacity: 1; }
        }

        /* Tools Grid */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        .tool-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }
        .tool-item:hover { border-color: rgba(255,255,255,0.2); }
        .tool-item.enabled { border-color: rgba(100,255,100,0.4); background: rgba(100,255,100,0.1); }
        .tool-item input[type="checkbox"] {
            accent-color: #0f0;
        }
        .tool-item-name { font-weight: 500; }
        .tool-item-desc {
            font-size: 9px;
            color: var(--text-tertiary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Spawn Button */
        .spawn-btn {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 2px dashed var(--glass-border);
            border-radius: 12px;
            color: var(--text-tertiary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px; /* Touch target minimum */
            margin-top: 12px;
            -webkit-tap-highlight-color: transparent;
        }
        .spawn-btn:hover {
            border-color: rgba(255,255,255,0.2);
            color: var(--text-secondary);
        }

        /* Scheduled Tasks */
        .schedule-item {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .schedule-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .schedule-cron {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .schedule-delete {
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            font-size: 14px;
        }
        .schedule-delete:hover { color: rgba(255,100,100,1); }

        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        /* Header */
        .header {
            padding: 16px 24px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .current-agent {
            font-size: 14px;
            font-weight: 500;
        }
        .current-agent-model {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        .header-right {
            display: flex;
            gap: 8px;
        }
        .header-btn {
            padding: 8px 14px;
            border-radius: 8px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            min-height: 36px;
            -webkit-tap-highlight-color: transparent;
        }
        .header-btn:hover { background: var(--glass-hover); color: var(--text); }
        .header-btn:active { transform: scale(0.95); }

        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .messages-inner {
            max-width: 800px;
            margin: 0 auto;
        }
        .message {
            margin-bottom: 32px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .message-role {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
        }
        .message-agent {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--glass);
        }
        .message-time {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        .message-content {
            font-size: 14px;
            line-height: 1.8;
        }
        .message.user .message-content { color: var(--text-secondary); }
        .message.system {
            padding: 20px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
        }
        .message.system .message-content {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Tool Block */
        .tool-block {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 12px 16px;
            margin: 16px 0;
        }
        .tool-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-tertiary);
        }
        .tool-status.running { background: var(--text); animation: pulse 1.5s infinite; }
        .tool-status.error { background: rgba(255,100,100,0.8); }
        .tool-name {
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .tool-input {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            overflow-x: auto;
            white-space: pre-wrap;
            color: var(--text-tertiary);
        }

        /* Dynamic UI */
        .dynamic-ui {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        /* Markdown */
        .markdown-content { padding: 4px 8px; }
        .markdown-content h1,.markdown-content h2,.markdown-content h3 { margin:20px 0 10px; font-weight:600; }
        .markdown-content h1 { font-size:18px; }
        .markdown-content h2 { font-size:16px; }
        .markdown-content h3 { font-size:14px; }
        .markdown-content code { background:rgba(255,255,255,0.06); padding:2px 6px; border-radius:4px; font-family:'SF Mono',monospace; font-size:12px; }
        .markdown-content pre { background:rgba(0,0,0,0.4); padding:14px; border-radius:8px; overflow-x:auto; margin:14px 0; }
        .markdown-content pre code { background:none; padding:0; }
        .markdown-content a { color:var(--text); text-decoration:underline; text-underline-offset:3px; }

        /* Input */
        .input-container {
            padding: 16px 24px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom));
            border-top: 1px solid var(--divider);
        }
        .input-wrapper {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            gap: 12px;
        }
        .target-select {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0 12px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            min-width: 100px;
            height: 50px;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.5)' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 28px;
        }
        .target-select:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            resize: none;
            min-height: 50px;
            max-height: 150px;
            -webkit-appearance: none;
            appearance: none;
        }
        .input-field:focus { outline: none; border-color: rgba(255,255,255,0.2); }
        .input-field::placeholder { color: var(--text-tertiary); }
        .send-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        .send-btn:hover { background: var(--glass-hover); color: var(--text); }
        .send-btn:active { transform: scale(0.92); }
        .send-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Thinking */
        .thinking { display:flex; gap:6px; padding:8px 0; }
        .thinking-dot { width:6px; height:6px; border-radius:50%; background:var(--text-tertiary); animation:bounce 1.4s infinite ease-in-out both; }
        .thinking-dot:nth-child(1) { animation-delay:-0.32s; }
        .thinking-dot:nth-child(2) { animation-delay:-0.16s; }
        @keyframes bounce { 0%,80%,100%{transform:scale(0);opacity:0.3} 40%{transform:scale(1);opacity:1} }

        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-title { font-size: 15px; font-weight: 600; }
        .modal-close {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            color: var(--text-tertiary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }
        .modal-close:hover { background: var(--glass); color: var(--text); }
        .modal-close:active { transform: scale(0.9); }
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .form-group { margin-bottom: 20px; }
        .form-label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            font-weight: 600;
        }
        .form-input {
            width: 100%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px 14px;
            color: var(--text);
            font-size: 16px; /* 16px minimum prevents iOS zoom */
            font-family: inherit;
            -webkit-appearance: none;
            appearance: none;
        }
        .form-input:focus {
            outline: none;
            border-color: rgba(255,255,255,0.2);
        }
        textarea.form-input {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }
        .form-hint { font-size: 11px; color: var(--text-tertiary); margin-top: 6px; }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px; /* Touch target minimum */
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { background: var(--glass-hover); color: var(--text); }
        .btn-primary { background: var(--text); color: var(--bg); border-color: var(--text); }
        .btn-primary:hover { background: rgba(255,255,255,0.85); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--glass);
            border-radius: 8px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .tabs::-webkit-scrollbar { display: none; }
        .tab {
            flex: 0 0 auto;
            padding: 10px 16px;
            border-radius: 6px;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            min-height: 40px;
            -webkit-tap-highlight-color: transparent;
        }
        .tab:hover { color: var(--text-secondary); }
        .tab:active { transform: scale(0.95); }
        .tab.active { background: var(--bg); color: var(--text); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 10px 18px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            opacity: 0;
            transition: all 0.3s;
            z-index: 300;
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Ring Context Panel */
        .ring-panel {
            width: 240px;
            background: var(--bg-elevated);
            border-left: 1px solid var(--divider);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        .ring-header {
            padding: 16px;
            padding-top: calc(16px + env(safe-area-inset-top));
            border-bottom: 1px solid var(--divider);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .ring-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ring-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(100,255,100,0.6);
            animation: pulse 2s infinite;
        }
        .ring-clear-btn {
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-tertiary);
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ring-clear-btn:hover {
            background: var(--glass);
            color: rgba(255,100,100,0.8);
            border-color: rgba(255,100,100,0.3);
        }
        .ring-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .ring-entry {
            background: var(--glass);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 11px;
            position: relative;
        }
        .ring-entry:hover .ring-entry-delete {
            opacity: 1;
        }
        .ring-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .ring-entry-agent {
            font-weight: 500;
        }
        .ring-entry-meta {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ring-entry-time {
            color: var(--text-tertiary);
            font-size: 10px;
        }
        .ring-entry-delete {
            opacity: 0;
            cursor: pointer;
            color: rgba(255,100,100,0.6);
            font-size: 12px;
            transition: opacity 0.2s, color 0.2s;
            padding: 2px 4px;
        }
        .ring-entry-delete:hover {
            color: rgba(255,100,100,1);
        }
        .ring-entry-content {
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Mobile */
        @media (max-width: 900px) {
            .sidebar { display: none; }
            .ring-panel { display: none; }
            .header {
                padding: 10px 16px;
                padding-top: calc(10px + env(safe-area-inset-top));
                flex-wrap: wrap;
                gap: 8px;
            }
            .header-left {
                gap: 8px;
                flex: 1;
                min-width: 0;
            }
            .header-right {
                gap: 6px;
            }
            .header-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            .current-agent {
                font-size: 13px;
            }
            .current-agent-model {
                font-size: 10px;
            }
            .messages-container {
                padding: 12px;
            }
            .messages-inner {
                max-width: 100%;
            }
            .message {
                margin-bottom: 24px;
            }
            .message-content {
                font-size: 14px;
            }
            .input-container {
                padding: 10px 12px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom));
            }
            .input-wrapper {
                gap: 8px;
            }
            .target-select {
                min-width: 70px;
                font-size: 12px;
                padding: 0 8px;
            }
            .input-field {
                padding: 12px 14px;
                min-height: 44px;
            }
            .send-btn {
                width: 44px;
                height: 44px;
            }
            .modal-content {
                max-height: 90vh;
                border-radius: 16px;
            }
            .modal-body {
                padding: 20px;
            }
            .modal-header {
                padding: 16px 20px;
            }
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .tabs::-webkit-scrollbar {
                display: none;
            }
            .tab {
                padding: 8px 12px;
                font-size: 12px;
                white-space: nowrap;
            }
            .tools-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Extra small mobile */
        @media (max-width: 480px) {
            .header-right {
                gap: 4px;
            }
            .header-btn {
                padding: 5px 8px;
                font-size: 10px;
            }
            .header-btn:not(:first-child):not(:last-child) {
                /* Hide middle buttons on very small screens */
            }
        }

        /* Mobile menu */
        .mobile-menu-btn {
            display: none;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        @media (max-width: 900px) {
            .mobile-menu-btn { display: block; }
        }
        .mobile-sidebar {
            position: fixed;
            inset: 0;
            background: var(--bg-elevated);
            z-index: 150;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        .mobile-sidebar.active { transform: translateX(0); }
        .mobile-sidebar-close {
            position: absolute;
            top: calc(16px + env(safe-area-inset-top));
            right: 16px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="brand">
                    agi.diy
                    <span class="brand-sub">multi-agent</span>
                </div>
                <div style="display:flex;align-items:center;gap:4px;margin-top:12px;flex-wrap:wrap" id="meshNavSlot"></div>
            </div>
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <div class="sidebar-title">Agents</div>
                    <div class="agent-list" id="agentList">
                        <!-- Populated by JS -->
                    </div>
                    <button class="spawn-btn" onclick="openSpawnModal()">+ New Agent</button>
                </div>
                <div class="sidebar-section">
                    <div class="sidebar-title">Scheduled Tasks</div>
                    <div id="scheduleList">
                        <div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main -->
        <main class="main">
            <header class="header">
                <div class="header-left">
                    <button class="mobile-menu-btn" onclick="toggleMobileSidebar()">‚ò∞</button>
                    <div>
                        <div class="current-agent" id="currentAgentName">No Agent Selected</div>
                        <div class="current-agent-model" id="currentAgentModel">‚Äî</div>
                    </div>
                </div>
                <div class="header-right">
                    <button class="header-btn" onclick="broadcastMessage()">üì¢ Broadcast</button>
                    <button class="header-btn" onclick="clearChat()">üóëÔ∏è Clear</button>
                    <button class="header-btn" onclick="openSettingsModal()">‚öôÔ∏è Settings</button>
                </div>
            </header>

            <div class="messages-container" id="messagesContainer">
                <div class="messages-inner" id="messagesInner">
                    <div class="message system">
                        <div class="message-content">
                            <strong>Multi-Agent AGI</strong><br><br>
                            Start chatting immediately ‚Äî a default agent is created with your saved credentials.<br><br>
                            ‚Ä¢ <strong>use_agent</strong>: Create sub-agents for parallel tasks<br>
                            ‚Ä¢ <strong>scheduler</strong>: Schedule recurring tasks with cron<br>
                            ‚Ä¢ <strong>create_tool</strong>: Build new tools at runtime<br>
                            ‚Ä¢ <strong>update_self</strong>: Modify agent system prompts<br>
                            ‚Ä¢ <strong>Ring Attention</strong>: Agents share context automatically<br><br>
                            Click "+ New Agent" to spawn additional agents, or ‚öôÔ∏è Settings to configure API keys.
                        </div>
                    </div>
                </div>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <select class="target-select" id="targetAgent">
                        <option value="all">All Agents</option>
                    </select>
                    <textarea class="input-field" id="inputField" placeholder="Send a message..." rows="1" onkeydown="handleKeyDown(event)"></textarea>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
        </main>

        <!-- Ring Context Panel -->
        <aside class="ring-panel">
            <div class="ring-header">
                <div class="ring-title">
                    <span class="ring-dot"></span>
                    Ring Context
                </div>
                <button class="ring-clear-btn" onclick="clearRingContext()" title="Clear all ring context">Clear</button>
            </div>
            <div class="ring-content" id="ringContent">
                <div style="font-size:11px;color:var(--text-tertiary);text-align:center;padding:20px;">
                    Shared context will appear here
                </div>
            </div>
        </aside>
    </div>

    <!-- Mobile Sidebar -->
    <div class="mobile-sidebar" id="mobileSidebar">
        <button class="mobile-sidebar-close" onclick="toggleMobileSidebar()">√ó</button>
        <div style="padding:60px 20px 20px;">
            <div class="sidebar-section">
                <div class="sidebar-title">Agents</div>
                <div class="agent-list" id="mobileAgentList"></div>
                <button class="spawn-btn" onclick="openSpawnModal();toggleMobileSidebar();">+ New Agent</button>
            </div>
        </div>
    </div>

    <!-- Spawn Modal -->
    <div class="modal" id="spawnModal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="modal-title">Spawn New Agent</span>
                <button class="modal-close" onclick="closeModal('spawnModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Agent ID</label>
                    <input type="text" class="form-input" id="spawnId" placeholder="e.g., researcher, coder">
                </div>
                <div class="form-group">
                    <label class="form-label">Model Provider</label>
                    <select class="form-input" id="spawnProvider" onchange="updateSpawnModelDefaults()">
                        <option value="bedrock">Amazon Bedrock</option>
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="openai_compatible">OpenAI-Compatible (Ollama, Groq, etc.)</option>
                        <option value="webllm">WebLLM (Local, Offline)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Model ID (optional)</label>
                    <input type="text" class="form-input" id="spawnModelId" placeholder="Leave empty for default" value="global.anthropic.claude-opus-4-6-v1">
                    <div class="form-hint" id="spawnModelHint">Default: global.anthropic.claude-opus-4-6-v1</div>
                </div>
                <div class="form-group">
                    <label class="form-label">System Prompt</label>
                    <textarea class="form-input" id="spawnPrompt" rows="4" placeholder="You are a helpful assistant..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" class="form-input" id="spawnMaxTokens" value="60000">
                </div>
                <div class="form-group" id="spawnAdditionalFieldsGroup">
                    <label class="form-label">Additional Request Fields (JSON)</label>
                    <textarea class="form-input" id="spawnAdditionalFields" rows="3" placeholder='{"thinking": {"type": "enabled", "budget_tokens": 10000}}'></textarea>
                    <div class="form-hint">Extended thinking, betas, etc. For Anthropic/Bedrock.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Tools</label>
                    <div id="spawnToolsList" class="tools-grid"></div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('spawnModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="spawnAgent()">Spawn Agent</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Settings</span>
                <button class="modal-close" onclick="closeModal('settingsModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="tabs">
                    <button class="tab active" onclick="showTab(event,'credentials')">API Keys</button>
                    <button class="tab" onclick="showTab(event,'network')">Network</button>
                    <button class="tab" onclick="showTab(event,'tools')">Tools</button>
                    <button class="tab" onclick="showTab(event,'sync')">Sync</button>
                    <button class="tab" onclick="showTab(event,'export')">Export</button>
                </div>

                <div class="tab-content active" id="tab-credentials">
                    <div class="form-group">
                        <label class="form-label">Anthropic API Key</label>
                        <input type="password" class="form-input" id="anthropicKey" placeholder="sk-ant-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">OpenAI API Key</label>
                        <input type="password" class="form-input" id="openaiKey" placeholder="sk-...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock API Key</label>
                        <input type="password" class="form-input" id="bedrockKey" placeholder="bedrock-api-key">
                        <div class="form-hint">Generate at AWS Bedrock Console ‚Üí API Keys</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Bedrock Region</label>
                        <select class="form-input" id="bedrockRegion">
                            <option value="us-east-1">us-east-1</option>
                            <option value="us-west-2">us-west-2</option>
                            <option value="eu-west-1">eu-west-1</option>
                        </select>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="saveCredentials()">Save Credentials</button>
                    <hr style="border-color:rgba(255,255,255,0.1);margin:16px 0">
                    <div class="form-group">
                        <label class="form-label">OpenAI-Compatible Endpoint (Ollama, LM Studio, Groq, etc.)</label>
                        <input type="text" class="form-input" id="compatBaseUrl" placeholder="http://localhost:11434/v1">
                        <input type="password" class="form-input" id="compatKey" placeholder="API key (optional)" style="margin-top:4px">
                        <input type="text" class="form-input" id="compatModel" placeholder="Model name (e.g. llama3.2)" style="margin-top:4px">
                    </div>
                    <div class="form-group">
                        <label class="form-label">üß† WebLLM (Local, Offline)</label>
                        <select class="form-input" id="webllmModel">
                            <option value="Qwen2.5-3B-Instruct-q4f16_1-MLC">Qwen 2.5 3B (recommended)</option>
                            <option value="Qwen2.5-1.5B-Instruct-q4f16_1-MLC">Qwen 2.5 1.5B (faster)</option>
                            <option value="Llama-3.2-3B-Instruct-q4f16_1-MLC">Llama 3.2 3B</option>
                            <option value="Llama-3.2-1B-Instruct-q4f16_1-MLC">Llama 3.2 1B (smallest)</option>
                            <option value="Hermes-2-Pro-Llama-3-8B-q4f16_1-MLC">Hermes Llama3 8B (best for tools)</option>
                            <option value="Phi-3.5-mini-instruct-q4f16_1-MLC">Phi 3.5 Mini</option>
                        </select>
                        <div class="form-hint">Runs 100% locally via WebGPU. No API key needed. Chrome 113+.</div>
                        <div id="webllmProgress" style="display:none;font-size:12px;color:var(--text-secondary);margin-top:8px;"></div>
                    </div>
                </div>

                <div class="tab-content" id="tab-network">
                    <div class="form-group">
                        <label class="form-label">üåê P2P Network Mode</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;">
                            Connect to remote agents via WebSocket relay. Local agents use BroadcastChannel automatically.
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Relay Server URL</label>
                        <input type="text" class="form-input" id="relayUrl" placeholder="wss://your-relay.example.com">
                        <div class="form-hint">WebSocket URL for cross-browser/device P2P</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Instance ID</label>
                        <input type="text" class="form-input" id="instanceId" placeholder="Leave blank for auto-generated">
                        <div class="form-hint">Unique identifier for this browser instance</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Connection Status</label>
                        <div id="networkStatus" style="font-family:'SF Mono',monospace;font-size:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;">
                            <div>Local: <span style="color:#0f0">‚óè BroadcastChannel active</span></div>
                            <div>Remote: <span id="wsStatus" style="color:#f66">‚óè Disconnected</span></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Remote Peers</label>
                        <div id="remotePeersList" style="font-size:12px;color:var(--text-tertiary);padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;min-height:40px;">
                            No remote peers connected
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="connectRelay()">Connect</button>
                        <button class="btn" onclick="disconnectRelay()">Disconnect</button>
                    </div>
                </div>

                <div class="tab-content" id="tab-tools">
                    <div class="form-group">
                        <label class="form-label">Built-in Tools</label>
                        <div style="font-size:12px;color:var(--text-secondary);line-height:2;">
                            <strong>Core:</strong> <code>render_ui</code> <code>javascript_eval</code> <code>storage_get</code> <code>storage_set</code> <code>fetch_url</code> <code>notify</code><br>
                            <strong>Self-Mod:</strong> <code>update_self</code> <code>create_tool</code> <code>list_tools</code> <code>delete_tool</code><br>
                            <strong>Agents:</strong> <code>use_agent</code> <code>scheduler</code><br>
                            <strong>Mesh:</strong> <code>invoke_agent</code> <code>broadcast_to_agents</code> <code>list_agents</code> <code>invoke_remote_agent</code><br>
                            <strong>PubSub:</strong> <code>subscribe_topic</code> <code>publish_topic</code>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Custom Tools</label>
                        <div id="customToolsList" style="font-size:12px;color:var(--text-tertiary);">
                            Agents can create tools with <code>create_tool</code>. Use <code>list_tools</code> to see all, <code>delete_tool</code> to remove.
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="tab-sync">
                    <div class="form-group">
                        <label class="form-label">üîó Sync via URL</label>
                        <div style="font-size:12px;color:var(--text-tertiary);margin-bottom:16px;">
                            Export your API keys as an encrypted URL for iPhone shortcuts or syncing to another device.
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">üì§ Export Settings</label>
                        <div style="display:flex;gap:8px;margin-bottom:12px;">
                            <input type="password" class="form-input" id="syncExportPassword" placeholder="Encryption password" style="flex:1;">
                            <button class="btn btn-primary" onclick="exportSyncUrl()">Export</button>
                        </div>
                        <div id="syncExportResult" style="display:none;">
                            <textarea class="form-input" id="syncExportedUrl" rows="3" readonly style="font-size:11px;"></textarea>
                            <button class="btn" onclick="navigator.clipboard.writeText(document.getElementById('syncExportedUrl').value);showToast('Copied!');" style="margin-top:8px;">üìã Copy URL</button>
                        </div>
                    </div>

                    <div class="form-group" style="margin-top:24px;padding-top:24px;border-top:1px solid var(--divider);">
                        <label class="form-label">üì• Import Settings</label>
                        <textarea class="form-input" id="syncImportUrl" rows="2" placeholder="Paste encrypted URL..." style="font-size:11px;margin-bottom:8px;"></textarea>
                        <div style="display:flex;gap:8px;">
                            <input type="password" class="form-input" id="syncImportPassword" placeholder="Decryption password" style="flex:1;">
                            <button class="btn btn-primary" onclick="importSyncUrl()">Import</button>
                        </div>
                    </div>

                    <div class="form-group" style="margin-top:24px;">
                        <label class="form-label">üì± iPhone Shortcut</label>
                        <div style="font-size:12px;color:var(--text-tertiary);line-height:1.6;">
                            Use <code>?q=your+message</code> URL param to trigger queries:<br>
                            <code style="font-size:10px;">https://agi.diy/agi.html?q=what%20time%20is%20it</code>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="tab-export">
                    <div class="form-group">
                        <label class="form-label">Export All Agents</label>
                        <button class="btn" onclick="exportAllAgents()">üì¶ Export State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Import Agents</label>
                        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importAgents(event)">
                        <button class="btn" onclick="document.getElementById('importFile').click()">üì• Import State</button>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Clear All Data</label>
                        <button class="btn" style="color:rgba(255,100,100,0.8)" onclick="clearAllData()">üóëÔ∏è Clear Everything</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Agent Modal -->
    <div class="modal" id="editAgentModal">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-header">
                <span class="modal-title">Edit Agent: <span id="editAgentTitle"></span></span>
                <button class="modal-close" onclick="closeModal('editAgentModal')">√ó</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editAgentId">
                <div class="form-group">
                    <label class="form-label">Model Provider</label>
                    <select class="form-input" id="editProvider" onchange="updateEditModelDefaults()">
                        <option value="bedrock">Amazon Bedrock</option>
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="openai_compatible">OpenAI-Compatible (Ollama, Groq, etc.)</option>
                        <option value="webllm">WebLLM (Local, Offline)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Model ID</label>
                    <input type="text" class="form-input" id="editModelId" placeholder="Leave empty for default">
                    <div class="form-hint" id="editModelHint">Default: global.anthropic.claude-opus-4-6-v1</div>
                </div>
                <div class="form-group">
                    <label class="form-label">System Prompt</label>
                    <textarea class="form-input" id="editPrompt" rows="4" placeholder="You are a helpful assistant..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Max Tokens</label>
                    <input type="number" class="form-input" id="editMaxTokens" value="60000">
                </div>
                <div class="form-group" id="editAdditionalFieldsGroup">
                    <label class="form-label">Additional Request Fields (JSON)</label>
                    <textarea class="form-input" id="editAdditionalFields" rows="3" placeholder='{"thinking": {"type": "enabled", "budget_tokens": 10000}}'></textarea>
                    <div class="form-hint">Extended thinking, betas, etc. For Anthropic/Bedrock.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Tools</label>
                    <div id="editToolsList" class="tools-grid"></div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('editAgentModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="saveAgentEdit()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Schedule Modal -->
    <div class="modal" id="scheduleModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Schedule Task</span>
                <button class="modal-close" onclick="closeModal('scheduleModal')">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" class="form-input" id="scheduleName" placeholder="daily-summary">
                </div>
                <div class="form-group">
                    <label class="form-label">Agent</label>
                    <select class="form-input" id="scheduleAgent"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Prompt</label>
                    <textarea class="form-input" id="schedulePrompt" rows="3" placeholder="What should the agent do?"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Schedule Type</label>
                    <select class="form-input" id="scheduleType" onchange="toggleScheduleFields()">
                        <option value="once">Once (delayed)</option>
                        <option value="cron">Recurring (cron)</option>
                    </select>
                </div>
                <div class="form-group" id="delayField">
                    <label class="form-label">Delay (seconds)</label>
                    <input type="number" class="form-input" id="scheduleDelay" value="60">
                </div>
                <div class="form-group" id="cronField" style="display:none;">
                    <label class="form-label">Cron Expression</label>
                    <input type="text" class="form-input" id="scheduleCron" placeholder="*/5 * * * *">
                    <div class="form-hint">e.g., */5 * * * * = every 5 minutes</div>
                </div>
                <div class="btn-group">
                    <button class="btn" onclick="closeModal('scheduleModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createSchedule()">Schedule</button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Polyfills -->
    <script>
    if (typeof Symbol.dispose === 'undefined') Symbol.dispose = Symbol('Symbol.dispose');
    if (typeof Symbol.asyncDispose === 'undefined') Symbol.asyncDispose = Symbol('Symbol.asyncDispose');
    </script>

    <script type="module">
    import { Agent, tool, Model, z, AnthropicModel, OpenAIModel, BedrockModel } from './strands.js';
    import { WebLLMBrowserModel } from './webllm.js';

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const state = {
        agents: new Map(),          // agentId -> { agent, model, config, messages, status }
        activeAgentId: null,
        ringBuffer: [],             // Shared context
        schedules: new Map(),       // scheduleId -> { name, agentId, prompt, type, cron/delay, timer }
        credentials: {
            anthropic: { apiKey: '', model: 'claude-opus-4-6' },
            openai: { apiKey: '', model: 'gpt-5.2-2025-12-11' },
            bedrock: { apiKey: '', region: 'us-east-1', model: 'global.anthropic.claude-opus-4-6-v1' },
            openai_compatible: { apiKey: '', baseUrl: '', model: '' },
            webllm: { model: 'Qwen2.5-3B-Instruct-q4f16_1-MLC' }
        },
        agentColors: ['#00ff88', '#00aaff', '#ff88ff', '#ffaa00', '#ff6666', '#88ffff'],
        colorIndex: 0
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODEL PROVIDERS ‚Äî AnthropicModel, OpenAIModel, BedrockModel imported from strands.js SDK
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let webllmModelInstance = null;

    function createModel(provider, customConfig = {}) {
        const creds = state.credentials[provider];
        if (provider === 'anthropic') {
            return new AnthropicModel({
                apiKey: creds.apiKey,
                modelId: customConfig.modelId || creds.model || 'claude-opus-4-6',
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: customConfig.additionalRequestFields || null
            });
        } else if (provider === 'openai') {
            return new OpenAIModel({
                apiKey: creds.apiKey,
                modelId: customConfig.modelId || creds.model || 'gpt-5.2-2025-12-11',
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS
            });
        } else if (provider === 'openai_compatible') {
            if (!creds.baseUrl) throw new Error('OpenAI-compatible endpoint URL not set');
            return new OpenAIModel({
                apiKey: creds.apiKey || 'not-needed',
                modelId: customConfig.modelId || creds.model || '',
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS,
                clientConfig: { baseURL: creds.baseUrl }
            });
        } else if (provider === 'bedrock') {
            return new BedrockModel({
                apiKey: creds.apiKey,
                region: creds.region || 'us-east-1',
                modelId: customConfig.modelId || creds.model || 'global.anthropic.claude-opus-4-6-v1',
                maxTokens: customConfig.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: customConfig.additionalRequestFields || DEFAULT_BEDROCK_ADDITIONAL_FIELDS
            });
        } else if (provider === 'webllm') {
            const modelId = customConfig.modelId || creds?.model || 'Qwen2.5-3B-Instruct-q4f16_1-MLC';
            if (webllmModelInstance?.getConfig().modelId === modelId && webllmModelInstance._loaded) return webllmModelInstance;
            const progressEl = document.getElementById('webllmProgress');
            const m = new WebLLMBrowserModel({ modelId, maxTokens: customConfig.maxTokens || 4096, onProgress: (pct, txt) => { if (progressEl) { progressEl.style.display = 'block'; progressEl.textContent = `${txt || 'Loading'} ${pct}%`; } } });
            webllmModelInstance = m;
            return m;
        }
        throw new Error(`Unknown provider: ${provider}`);
    }

    // Default models per provider
    const DEFAULT_MODELS = {
        bedrock: 'global.anthropic.claude-opus-4-6-v1',
        anthropic: 'claude-opus-4-6',
        openai: 'gpt-5.2-2025-12-11',
        openai_compatible: '',
        webllm: 'Qwen2.5-3B-Instruct-q4f16_1-MLC'
    };

    // Default additional request fields for bedrock (extended thinking)
    const DEFAULT_BEDROCK_ADDITIONAL_FIELDS = {
        "anthropic_beta": ["interleaved-thinking-2025-05-14", "context-1m-2025-08-07"],
        "thinking": {"type": "enabled", "budget_tokens": 2048}
    };

    const DEFAULT_MAX_TOKENS = 60000;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOOLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const renderUiTool = tool({
        name: 'render_ui',
        description: 'Render HTML/CSS/JS in the chat',
        inputSchema: z.object({ html: z.string(), css: z.string().optional(), script: z.string().optional(), title: z.string().optional() }),
        callback: async (input) => {
            const container = document.createElement('div');
            container.className = 'dynamic-ui';
            if (input.title) container.innerHTML = `<div style="font-size:11px;color:var(--text-tertiary);margin-bottom:12px;text-transform:uppercase;letter-spacing:0.05em;">${input.title}</div>`;
            if (input.css) container.innerHTML += `<style>${input.css}</style>`;
            container.innerHTML += input.html;
            document.getElementById('messagesInner').appendChild(container);
            scrollToBottom();
            if (input.script) { try { new Function(input.script).call(container); } catch (e) { return { error: e.message }; } }
            return { rendered: true };
        }
    });

    const javascriptEvalTool = tool({
        name: 'javascript_eval',
        description: 'Execute JavaScript',
        inputSchema: z.object({ code: z.string() }),
        callback: async (input) => { try { return { result: String(eval(input.code)) }; } catch (e) { return { error: e.message }; } }
    });

    const storageGetTool = tool({
        name: 'storage_get',
        description: 'Get localStorage value',
        inputSchema: z.object({ key: z.string() }),
        callback: async (input) => ({ key: input.key, value: localStorage.getItem(input.key) })
    });

    const storageSetTool = tool({
        name: 'storage_set',
        description: 'Set localStorage value',
        inputSchema: z.object({ key: z.string(), value: z.string() }),
        callback: async (input) => { localStorage.setItem(input.key, input.value); return { success: true }; }
    });

    const fetchUrlTool = tool({
        name: 'fetch_url',
        description: 'HTTP request',
        inputSchema: z.object({ url: z.string(), method: z.string().optional(), headers: z.record(z.string(), z.string()).optional(), body: z.string().optional() }),
        callback: async (input) => {
            try {
                const r = await fetch(input.url, { method: input.method || 'GET', headers: input.headers, body: input.body });
                const ct = r.headers.get('content-type');
                const data = ct?.includes('json') ? await r.json() : await r.text();
                return { status: r.status, data };
            } catch (e) { return { error: e.message }; }
        }
    });

    const notifyTool = tool({
        name: 'notify',
        description: 'Send browser notification',
        inputSchema: z.object({ title: z.string(), body: z.string() }),
        callback: async (input) => {
            if (Notification.permission === 'granted') {
                new Notification(input.title, { body: input.body });
                return { success: true };
            }
            return { error: 'Notifications not permitted' };
        }
    });

    // use_agent - spawn sub-agent
    const useAgentTool = tool({
        name: 'use_agent',
        description: 'Create a sub-agent to handle a specific task. The sub-agent runs asynchronously.',
        inputSchema: z.object({
            agentId: z.string().describe('Unique ID for the sub-agent'),
            provider: z.enum(['anthropic', 'openai', 'bedrock']).describe('Model provider'),
            systemPrompt: z.string().describe('System prompt for sub-agent'),
            prompt: z.string().describe('Initial prompt to send'),
            maxTokens: z.number().optional()
        }),
        callback: async (input) => {
            try {
                // Check if agent already exists
                if (state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} already exists` };
                }

                // Create sub-agent with default bedrock settings if using bedrock
                const modelConfig = {
                    maxTokens: input.maxTokens || DEFAULT_MAX_TOKENS
                };
                if (input.provider === 'bedrock') {
                    modelConfig.additionalRequestFields = DEFAULT_BEDROCK_ADDITIONAL_FIELDS;
                }
                const model = createModel(input.provider, modelConfig);

                const subAgent = new Agent({
                    model,
                    tools: [renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool],
                    systemPrompt: input.systemPrompt,
                    printer: false
                });

                const color = state.agentColors[state.colorIndex % state.agentColors.length];
                state.colorIndex++;

                state.agents.set(input.agentId, {
                    agent: subAgent,
                    model,
                    config: {
                        provider: input.provider,
                        systemPrompt: input.systemPrompt,
                        maxTokens: input.maxTokens || DEFAULT_MAX_TOKENS,
                        additionalRequestFields: input.provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
                    },
                    messages: [],
                    status: 'ready',
                    color
                });

                updateAgentUI();

                // Run prompt asynchronously
                setTimeout(() => runAgentMessage(input.agentId, input.prompt), 0);

                return { success: true, agentId: input.agentId, message: 'Sub-agent spawned and processing prompt' };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    // scheduler - schedule tasks
    const schedulerTool = tool({
        name: 'scheduler',
        description: 'Schedule a task to run once or on a recurring basis (cron pattern)',
        inputSchema: z.object({
            action: z.enum(['create', 'list', 'delete']),
            name: z.string().optional().describe('Task name'),
            agentId: z.string().optional().describe('Agent to run the task'),
            prompt: z.string().optional().describe('Prompt for the agent'),
            type: z.enum(['once', 'cron']).optional(),
            delay: z.number().optional().describe('Delay in seconds for once'),
            cron: z.string().optional().describe('Cron expression for recurring')
        }),
        callback: async (input) => {
            if (input.action === 'list') {
                const schedules = [];
                for (const [id, s] of state.schedules) {
                    schedules.push({ id, name: s.name, agentId: s.agentId, type: s.type, cron: s.cron, delay: s.delay });
                }
                return { schedules };
            }

            if (input.action === 'delete') {
                if (!input.name) return { error: 'Name required for delete' };
                for (const [id, s] of state.schedules) {
                    if (s.name === input.name) {
                        if (s.timer) clearTimeout(s.timer);
                        if (s.interval) clearInterval(s.interval);
                        state.schedules.delete(id);
                        updateScheduleUI();
                        return { success: true, deleted: input.name };
                    }
                }
                return { error: 'Schedule not found' };
            }

            if (input.action === 'create') {
                if (!input.name || !input.agentId || !input.prompt || !input.type) {
                    return { error: 'name, agentId, prompt, and type required' };
                }
                if (!state.agents.has(input.agentId)) {
                    return { error: `Agent ${input.agentId} not found` };
                }

                const id = `schedule-${Date.now()}`;
                const schedule = {
                    name: input.name,
                    agentId: input.agentId,
                    prompt: input.prompt,
                    type: input.type,
                    delay: input.delay,
                    cron: input.cron
                };

                if (input.type === 'once') {
                    const delayMs = (input.delay || 60) * 1000;
                    schedule.timer = setTimeout(() => {
                        runAgentMessage(input.agentId, input.prompt);
                        state.schedules.delete(id);
                        updateScheduleUI();
                    }, delayMs);
                    schedule.runAt = new Date(Date.now() + delayMs).toISOString();
                } else if (input.type === 'cron') {
                    // Simple cron parser for common patterns
                    const cronParts = (input.cron || '* * * * *').split(' ');
                    const minute = cronParts[0];

                    // Parse interval from cron (simplified)
                    let intervalMs = 60000; // default 1 minute
                    if (minute.startsWith('*/')) {
                        intervalMs = parseInt(minute.slice(2)) * 60000;
                    }

                    schedule.interval = setInterval(() => {
                        runAgentMessage(input.agentId, input.prompt);
                    }, intervalMs);
                    schedule.nextRun = new Date(Date.now() + intervalMs).toISOString();
                }

                state.schedules.set(id, schedule);
                updateScheduleUI();
                saveState();

                return { success: true, scheduleId: id, name: input.name, type: input.type };
            }

            return { error: 'Invalid action' };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MESH - Hybrid P2P: BroadcastChannel (local) + WebSocket (remote)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const agentMesh = {
        // Local mesh (same-origin tabs)
        bus: new BroadcastChannel('agi-mesh'),

        // Remote mesh (delegated to AgentMesh relay)
        get wsConnected() { return window.AgentMesh?.relayConnected || false; },
        get remotePeers() { return new Map(); }, // AgentMesh manages these now

        // Shared state
        pendingRequests: new Map(),
        messageLog: [],

        init() {
            // Local mesh
            this.bus.onmessage = (e) => this.handleMessage(e.data, 'local');

            // Subscribe to relay status for UI updates
            if (window.AgentMesh) {
                window.AgentMesh.subscribe('relay-status', (s) => this.updateWsStatus(s.connected));
                window.AgentMesh.subscribe('relay-peers', () => this.updateRemotePeersUI());
            }

            console.log(`üîó Agent mesh initialized (instance: ${window.AgentMesh?.relayInstanceId || 'unknown'})`);
        },

        connectRelay(url) { window.AgentMesh?.connectRelay(url); },
        disconnectRelay() { window.AgentMesh?.disconnectRelay(); },
        sendRemote(msg) { window.AgentMesh?.sendRelay(msg); },

        updateWsStatus(connected) {
            const el = document.getElementById('wsStatus');
            if (el) {
                el.innerHTML = connected
                    ? '<span style="color:#0f0">‚óè Connected</span>'
                    : '<span style="color:#f66">‚óè Disconnected</span>';
            }
        },

        updateRemotePeersUI() {
            const el = document.getElementById('remotePeersList');
            if (!el) return;
            const peers = window.AgentMesh?.getRelayPeers() || [];
            if (peers.length === 0) { el.innerHTML = 'No remote peers connected'; return; }
            el.innerHTML = peers.map(peer => {
                const agentCount = peer.agents?.length || 0;
                const age = Math.round((Date.now() - peer.lastSeen) / 1000);
                return `<div style="margin-bottom:4px;"><span style="color:#0f0">‚óè</span> ${peer.hostname || '?'} <span style="color:var(--text-tertiary)">(${agentCount} agents, ${age}s ago)</span></div>`;
            }).join('');
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Message Handling (both local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        handleMessage(msg, source) {
            const { type, from, to, turnId, data, timestamp } = msg;

            // Log for watching
            this.messageLog.push({ type, from, to, turnId, source, data: typeof data === 'string' ? data.slice(0, 100) : data, timestamp });
            if (this.messageLog.length > 200) this.messageLog.shift();
            updateMeshLog();

            // Handle presence/heartbeat from remote peers
            if ((type === 'presence' || type === 'heartbeat') && source === 'remote') {
                this.remotePeers.set(from, {
                    agents: data.agents || [],
                    hostname: data.hostname || 'unknown',
                    lastSeen: Date.now()
                });
                this.updateRemotePeersUI();
                return;
            }

            // Handle broadcast command
            if (type === 'broadcast' || type === 'direct') {
                // Skip if from ourselves (same instance) - only for remote messages
                if (source === 'remote' && from === this.instanceId) return;

                // Process with local agents
                for (const [agentId, agentData] of state.agents) {
                    // For direct messages, only process the target agent
                    if (type === 'direct' && agentId !== to) continue;
                    // Never let an agent process its own message
                    if (from === agentId) continue;

                    this.processIncomingCommand(agentId, from, turnId, data.command, source);
                }
                return;
            }

            // Handle response streams
            if (type === 'stream' || type === 'ack' || type === 'turn_end' || type === 'error') {
                const pending = this.pendingRequests.get(turnId);
                if (!pending) return;

                if (type === 'stream') {
                    if (!pending.streamed[from]) pending.streamed[from] = '';
                    pending.streamed[from] += data.chunk;
                    updateStreamingResponse(turnId, from, pending.streamed[from]);
                }
                else if (type === 'ack') {
                    addMeshEvent(from, 'Processing...', 'ack');
                }
                else if (type === 'turn_end') {
                    pending.responses.push({ from, result: data.result, chunks: data.chunks });
                    pending.completed++;
                    if (pending.completed >= pending.expected || pending.timeout) {
                        pending.resolve(pending);
                    }
                }
                else if (type === 'error') {
                    pending.responses.push({ from, error: data.error });
                    pending.completed++;
                }
            }
        },

        async processIncomingCommand(agentId, fromId, turnId, command, source) {
            const agentData = state.agents.get(agentId);
            if (!agentData) return;

            // Send ACK
            this.publish({ type: 'ack', from: agentId, to: fromId, turnId, timestamp: Date.now() });

            agentData.status = 'processing';
            updateAgentUI();

            try {
                let fullText = '';
                let chunkCount = 0;

                const sourceLabel = source === 'remote' ? `[Remote: ${fromId}]` : `[From agent ${fromId}]`;

                for await (const event of agentData.agent.stream(`${sourceLabel}: ${command}`)) {
                    if (event?.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                        fullText += event.delta.text;
                        chunkCount++;
                        this.publish({
                            type: 'stream',
                            from: agentId,
                            to: fromId,
                            turnId,
                            data: { chunk: event.delta.text, chunkNum: chunkCount },
                            timestamp: Date.now()
                        });
                    }
                }

                this.publish({
                    type: 'turn_end',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { result: fullText, chunks: chunkCount },
                    timestamp: Date.now()
                });

                agentData.messages.push({ role: 'user', content: `${sourceLabel}: ${command}`, timestamp: Date.now() });
                agentData.messages.push({ role: 'assistant', content: fullText, timestamp: Date.now() });

                state.ringBuffer.push({ agentId, role: 'assistant', content: fullText, timestamp: Date.now() });
                // üåê Sync to AgentMesh shared ring
                if (window.AgentMesh?.addToRingContext) {
                    window.AgentMesh.addToRingContext(agentId, 'multi', fullText.slice(0, 500));
                }
                updateRingUI();

            } catch (e) {
                this.publish({
                    type: 'error',
                    from: agentId,
                    to: fromId,
                    turnId,
                    data: { error: e.message },
                    timestamp: Date.now()
                });
            }

            agentData.status = 'ready';
            updateAgentUI();
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Publishing (bridges local and remote)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        publish(msg) {
            // Always publish to local BroadcastChannel
            this.bus.postMessage(msg);

            // Also publish to WebSocket relay if connected
            if (this.wsConnected) {
                this.sendRemote({ ...msg, instanceId: this.instanceId });
            }

            // Handle locally for same-tab agents
            setTimeout(() => this.handleMessage(msg, 'local'), 0);
        },

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // High-level API
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        async broadcast(fromAgentId, command, waitTime = 30) {
            const turnId = crypto.randomUUID().slice(0, 8);

            // Count local + remote agents
            let peerCount = state.agents.size - 1;
            for (const [, peer] of this.remotePeers) {
                peerCount += peer.agents?.length || 0;
            }

            if (peerCount === 0) {
                return { error: 'No other agents to broadcast to' };
            }

            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: peerCount,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);

                // Publish broadcast
                this.publish({
                    type: 'broadcast',
                    from: fromAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });

                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },

        async sendTo(fromAgentId, toAgentId, command, waitTime = 60) {
            const turnId = crypto.randomUUID().slice(0, 8);

            if (!state.agents.has(toAgentId)) {
                return { error: `Agent ${toAgentId} not found` };
            }

            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);

                // Publish direct message
                this.publish({
                    type: 'direct',
                    from: fromAgentId,
                    to: toAgentId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });

                // Timeout
                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        },

        listAgents(includeRemote = true) {
            const agents = [];

            // Local agents
            for (const [id, data] of state.agents) {
                agents.push({
                    id,
                    location: 'local',
                    instanceId: this.instanceId,
                    status: data.status,
                    provider: data.config.provider,
                    model: data.config.modelId || 'default',
                    messageCount: data.messages.length
                });
            }

            // Remote agents
            if (includeRemote) {
                for (const [instanceId, peer] of this.remotePeers) {
                    for (const agentId of peer.agents || []) {
                        agents.push({
                            id: agentId,
                            location: 'remote',
                            instanceId: instanceId,
                            hostname: peer.hostname,
                            lastSeen: peer.lastSeen
                        });
                    }
                }
            }

            return agents;
        },

        // Send to remote instance
        async sendToRemoteAgent(fromAgentId, targetInstanceId, targetAgentId, command, waitTime = 60) {
            if (!this.wsConnected) {
                return { error: 'Not connected to relay' };
            }

            const peer = this.remotePeers.get(targetInstanceId);
            if (!peer || !peer.agents.includes(targetAgentId)) {
                return { error: `Remote agent ${targetAgentId}@${targetInstanceId} not found` };
            }

            const turnId = crypto.randomUUID().slice(0, 8);

            return new Promise((resolve) => {
                const pending = {
                    resolve,
                    responses: [],
                    streamed: {},
                    completed: 0,
                    expected: 1,
                    timeout: false
                };
                this.pendingRequests.set(turnId, pending);

                // Send direct to remote
                this.sendRemote({
                    type: 'direct',
                    from: fromAgentId,
                    to: targetAgentId,
                    instanceId: this.instanceId,
                    targetInstanceId: targetInstanceId,
                    turnId,
                    data: { command },
                    timestamp: Date.now()
                });

                setTimeout(() => {
                    pending.timeout = true;
                    resolve(pending);
                    this.pendingRequests.delete(turnId);
                }, waitTime * 1000);
            });
        }
    };

    // Initialize mesh
    agentMesh.init();

    // Mesh UI helpers
    function updateMeshLog() {
        // Update ring panel with recent mesh activity
        const recent = agentMesh.messageLog.slice(-10).reverse();
        const meshHtml = recent.map(m => {
            const icon = m.type === 'broadcast' ? 'üì¢' : m.type === 'direct' ? 'üì®' : m.type === 'stream' ? 'üì°' : m.type === 'turn_end' ? '‚úÖ' : '‚Ä¢';
            return `<div style="font-size:10px;color:var(--text-tertiary);margin-bottom:4px;">${icon} ${m.from}${m.to ? '‚Üí' + m.to : ''}: ${m.type}</div>`;
        }).join('');

        const meshSection = document.getElementById('meshActivity');
        if (meshSection) meshSection.innerHTML = meshHtml || '<div style="font-size:10px;color:var(--text-tertiary);">No mesh activity</div>';
    }

    function updateStreamingResponse(turnId, from, text) {
        // Show streaming in a special area or update existing message
        const el = document.getElementById(`mesh-stream-${turnId}-${from}`);
        if (el) {
            el.querySelector('.markdown-content').innerHTML = marked.parse(text);
        }
    }

    function addMeshEvent(agentId, message, type) {
        const color = state.agents.get(agentId)?.color || '#888';
        showToast(`üîó ${agentId}: ${message}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESH TOOLS - Agent-to-Agent Communication
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // invoke_agent - Call another agent and get response
    const invokeAgentTool = tool({
        name: 'invoke_agent',
        description: 'Send a message to another agent and wait for their response. Use this to delegate tasks or collaborate with other agents.',
        inputSchema: z.object({
            targetAgentId: z.string().describe('ID of the agent to invoke'),
            message: z.string().describe('Message/command to send'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find which agent is calling this
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }

            if (!state.agents.has(input.targetAgentId)) {
                return { error: `Agent '${input.targetAgentId}' not found`, available: [...state.agents.keys()] };
            }

            if (input.targetAgentId === callerAgentId) {
                return { error: 'Cannot invoke yourself' };
            }

            const result = await agentMesh.sendTo(callerAgentId, input.targetAgentId, input.message, input.waitTime || 60);

            if (result.error) return { error: result.error };

            const response = result.responses[0];
            if (response?.error) return { error: response.error };

            return {
                success: true,
                from: input.targetAgentId,
                response: result.streamed[input.targetAgentId] || response?.result || 'No response',
                chunks: response?.chunks || 0
            };
        }
    });

    // broadcast_to_agents - Send to all agents
    const broadcastToAgentsTool = tool({
        name: 'broadcast_to_agents',
        description: 'Broadcast a message to ALL other agents. Each will process and respond.',
        inputSchema: z.object({
            message: z.string().describe('Message to broadcast'),
            waitTime: z.number().optional().describe('Max seconds to wait (default: 30)')
        }),
        callback: async (input, { agent }) => {
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }

            const result = await agentMesh.broadcast(callerAgentId, input.message, input.waitTime || 30);

            if (result.error) return { error: result.error };

            const responses = [];
            for (const [agentId, text] of Object.entries(result.streamed)) {
                responses.push({ agentId, response: text });
            }
            for (const r of result.responses) {
                if (r.result && !result.streamed[r.from]) {
                    responses.push({ agentId: r.from, response: r.result });
                }
            }

            return {
                success: true,
                broadcastedTo: state.agents.size - 1,
                responses
            };
        }
    });

    // list_agents - See available agents (local + remote)
    const listAgentsTool = tool({
        name: 'list_agents',
        description: 'List all available agents (local and remote). Shows agent ID, location (local/remote), instance, and status.',
        inputSchema: z.object({
            includeRemote: z.boolean().optional().describe('Include remote agents from relay (default: true)')
        }),
        callback: async (input) => {
            const includeRemote = input?.includeRemote !== false;
            const agents = agentMesh.listAgents(includeRemote);
            const localCount = agents.filter(a => a.location === 'local').length;
            const remoteCount = agents.filter(a => a.location === 'remote').length;
            return {
                agents,
                summary: {
                    local: localCount,
                    remote: remoteCount,
                    total: agents.length,
                    relayConnected: agentMesh.wsConnected
                }
            };
        }
    });

    // invoke_remote_agent - Call an agent on a remote instance
    const invokeRemoteAgentTool = tool({
        name: 'invoke_remote_agent',
        description: 'Send a message to an agent running on a different browser/device via the relay server. Use list_agents to see remote agents first.',
        inputSchema: z.object({
            instanceId: z.string().describe('Remote instance ID (from list_agents)'),
            agentId: z.string().describe('Agent ID on the remote instance'),
            message: z.string().describe('Message to send'),
            waitTime: z.number().optional().describe('Seconds to wait for response (default: 60)')
        }),
        callback: async (input, { agent }) => {
            // Find caller agent
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }

            const result = await agentMesh.sendToRemoteAgent(
                callerAgentId,
                input.instanceId,
                input.agentId,
                input.message,
                input.waitTime || 60
            );

            if (result.error) return { error: result.error };

            const response = result.responses[0];
            if (response?.error) return { error: response.error };

            return {
                success: true,
                from: `${input.agentId}@${input.instanceId}`,
                response: result.streamed[input.agentId] || response?.result || 'No response'
            };
        }
    });

    // subscribe_topic - Watch for messages on a topic
    const subscribeTopicTool = tool({
        name: 'subscribe_topic',
        description: 'Subscribe to a topic to receive messages. Creates a listener that triggers on new messages.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name to subscribe to'),
            handler: z.string().describe('JavaScript code to run when message received (receives msg parameter)')
        }),
        callback: async (input) => {
            // Store subscription
            if (!state.subscriptions) state.subscriptions = new Map();

            const subId = `sub-${Date.now()}`;
            state.subscriptions.set(subId, {
                topic: input.topic,
                handler: new Function('msg', input.handler)
            });

            return { success: true, subscriptionId: subId, topic: input.topic };
        }
    });

    // publish_topic - Publish to a topic
    const publishTopicTool = tool({
        name: 'publish_topic',
        description: 'Publish a message to a topic. All subscribers will receive it.',
        inputSchema: z.object({
            topic: z.string().describe('Topic name'),
            message: z.any().describe('Message to publish (string or object)')
        }),
        callback: async (input) => {
            agentMesh.publish({
                type: 'topic',
                topic: input.topic,
                data: input.message,
                timestamp: Date.now()
            });

            // Notify local subscribers
            if (state.subscriptions) {
                for (const [id, sub] of state.subscriptions) {
                    if (sub.topic === input.topic) {
                        try {
                            sub.handler(input.message);
                        } catch (e) {
                            console.error(`Subscription ${id} error:`, e);
                        }
                    }
                }
            }

            return { success: true, topic: input.topic };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SELF-MODIFICATION TOOLS - Agent can create its own tools!
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Storage key for custom tools
    const CUSTOM_TOOLS_KEY = 'agi_multi_custom_tools';

    // Load custom tools from localStorage
    function loadCustomTools() {
        try {
            const stored = localStorage.getItem(CUSTOM_TOOLS_KEY);
            if (!stored) return {};
            return JSON.parse(stored);
        } catch (e) {
            console.warn('Failed to load custom tools:', e);
            return {};
        }
    }

    // Save custom tools to localStorage
    function saveCustomTools(tools) {
        localStorage.setItem(CUSTOM_TOOLS_KEY, JSON.stringify(tools));
    }

    // Create a tool from stored definition
    function createToolFromDefinition(name, def) {
        try {
            // Build the Zod schema from the stored schema definition
            const schemaObj = {};
            for (const [key, prop] of Object.entries(def.inputSchema.properties || {})) {
                let zodType;
                switch (prop.type) {
                    case 'number': zodType = z.number(); break;
                    case 'boolean': zodType = z.boolean(); break;
                    case 'array': zodType = z.array(z.any()); break;
                    case 'object': zodType = z.object({}).passthrough(); break;
                    default: zodType = z.string();
                }
                if (prop.description) zodType = zodType.describe(prop.description);
                if (!(def.inputSchema.required || []).includes(key)) zodType = zodType.optional();
                schemaObj[key] = zodType;
            }

            // Create the callback function from stored code
            const callbackFn = new Function('input', `
                return (async () => {
                    ${def.code}
                })();
            `);

            return tool({
                name: name,
                description: def.description,
                inputSchema: z.object(schemaObj),
                callback: callbackFn
            });
        } catch (e) {
            console.error(`Failed to create tool ${name}:`, e);
            return null;
        }
    }

    // Build all custom tools as actual tool objects
    function buildCustomTools() {
        const customToolDefs = loadCustomTools();
        const tools = [];
        for (const [name, def] of Object.entries(customToolDefs)) {
            const t = createToolFromDefinition(name, def);
            if (t) tools.push(t);
        }
        return tools;
    }

    // update_self - Update agent configuration
    const updateSelfTool = tool({
        name: 'update_self',
        description: 'Update agent configuration (system prompt, etc.)',
        inputSchema: z.object({
            section: z.enum(['system_prompt', 'config']).describe('Section'),
            content: z.string().describe('Content'),
            action: z.enum(['replace', 'append', 'prepend']).optional().describe('Action')
        }),
        callback: async (input, { agent }) => {
            const action = input.action || 'replace';

            // Find which agent is calling this
            let callerAgentId = state.activeAgentId;
            for (const [id, data] of state.agents) {
                if (data.agent === agent) {
                    callerAgentId = id;
                    break;
                }
            }

            const agentData = state.agents.get(callerAgentId);
            if (!agentData) {
                return { error: 'Agent not found' };
            }

            if (input.section === 'system_prompt') {
                const current = agentData.config.systemPrompt || '';
                let newPrompt;
                if (action === 'append') {
                    newPrompt = current + '\n' + input.content;
                } else if (action === 'prepend') {
                    newPrompt = input.content + '\n' + current;
                } else {
                    newPrompt = input.content;
                }
                agentData.config.systemPrompt = newPrompt;
                saveState();
                return { success: true, message: `System prompt updated for agent ${callerAgentId}.` };
            }

            return { error: `Unknown section: ${input.section}` };
        }
    });

    // create_tool - Create new tools at runtime
    const createToolTool = tool({
        name: 'create_tool',
        description: `Create a new tool that will be available to all agents. The tool persists across sessions.

IMPORTANT: The 'code' parameter should be the BODY of an async function that receives 'input' as parameter.
Return a result object. You have access to: fetch, localStorage, document, console, etc.

Example - create a tool that gets weather:
{
    "name": "get_weather",
    "description": "Get weather for a city",
    "inputSchema": {
        "type": "object",
        "properties": {
            "city": { "type": "string", "description": "City name" }
        },
        "required": ["city"]
    },
    "code": "const response = await fetch('https://wttr.in/' + input.city + '?format=j1');\\nconst data = await response.json();\\nreturn { temperature: data.current_condition[0].temp_C, description: data.current_condition[0].weatherDesc[0].value };"
}`,
        inputSchema: z.object({
            name: z.string().describe('Tool name (snake_case)'),
            description: z.string().describe('What the tool does'),
            inputSchema: z.object({
                type: z.literal('object'),
                properties: z.record(z.string(), z.object({
                    type: z.string(),
                    description: z.string().optional()
                })),
                required: z.array(z.string()).optional()
            }).describe('JSON Schema for tool inputs'),
            code: z.string().describe('JavaScript code - body of async function with input parameter. Must return a result.')
        }),
        callback: async (input) => {
            try {
                // Validate the tool name
                if (!/^[a-z][a-z0-9_]*$/.test(input.name)) {
                    return { error: 'Tool name must be snake_case (lowercase, underscores, start with letter)' };
                }

                // Check for reserved names
                const reserved = ['create_tool', 'list_tools', 'delete_tool', 'update_self', 'render_ui', 'javascript_eval',
                                  'storage_get', 'storage_set', 'fetch_url', 'notify', 'use_agent', 'scheduler',
                                  'invoke_agent', 'broadcast_to_agents', 'list_agents', 'invoke_remote_agent',
                                  'subscribe_topic', 'publish_topic'];
                if (reserved.includes(input.name)) {
                    return { error: `Cannot override built-in tool: ${input.name}` };
                }

                // Test that the code compiles
                try {
                    new Function('input', input.code);
                } catch (e) {
                    return { error: `Invalid JavaScript code: ${e.message}` };
                }

                // Store the tool definition
                const customTools = loadCustomTools();
                const toolDef = {
                    description: input.description,
                    inputSchema: input.inputSchema,
                    code: input.code,
                    createdAt: new Date().toISOString()
                };
                customTools[input.name] = toolDef;
                saveCustomTools(customTools);

                // Immediately add tool to all existing agents (hot-reload!)
                const newTool = createToolFromDefinition(input.name, toolDef);
                if (newTool) {
                    for (const [id, agentData] of state.agents) {
                        if (agentData.agent && agentData.agent.tools) {
                            agentData.agent.tools.push(newTool);
                        }
                    }
                }

                return {
                    success: true,
                    message: `Tool '${input.name}' created and ready to use immediately!`,
                    tool: input.name
                };
            } catch (e) {
                return { error: e.message };
            }
        }
    });

    // list_tools - List all available tools
    const listToolsTool = tool({
        name: 'list_tools',
        description: 'List all available tools, including custom tools created by agents',
        inputSchema: z.object({
            includeBuiltIn: z.boolean().optional().describe('Include built-in tools (default: true)')
        }),
        callback: async (input = {}) => {
            const includeBuiltIn = input?.includeBuiltIn !== false;
            const result = { custom: [], builtIn: [] };

            // Custom tools
            const customTools = loadCustomTools();
            for (const [name, def] of Object.entries(customTools)) {
                result.custom.push({
                    name,
                    description: def.description,
                    createdAt: def.createdAt
                });
            }

            // Built-in tools
            if (includeBuiltIn) {
                result.builtIn = [
                    'render_ui', 'javascript_eval', 'storage_get', 'storage_set',
                    'fetch_url', 'notify', 'update_self', 'create_tool', 'list_tools', 'delete_tool',
                    'use_agent', 'scheduler', 'invoke_agent', 'broadcast_to_agents',
                    'list_agents', 'invoke_remote_agent', 'subscribe_topic', 'publish_topic'
                ];
            }

            return result;
        }
    });

    // delete_tool - Delete custom tools
    const deleteToolTool = tool({
        name: 'delete_tool',
        description: 'Delete a custom tool created by an agent',
        inputSchema: z.object({
            name: z.string().describe('Name of the tool to delete')
        }),
        callback: async (input) => {
            const customTools = loadCustomTools();

            if (!customTools[input.name]) {
                return { error: `Tool '${input.name}' not found in custom tools` };
            }

            delete customTools[input.name];
            saveCustomTools(customTools);

            return {
                success: true,
                message: `Tool '${input.name}' deleted. Restart agents to remove from tool list.`
            };
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåê AGENTMESH TOOLS - Cross-tab communication with other agi.diy pages
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const invokeMeshAgentTool = tool({
        name: 'invoke_mesh_agent',
        description: 'Send a prompt to an agent running in ANOTHER browser tab (index.html single agent, mesh.html, etc). Use list_mesh_peers to see available targets.',
        inputSchema: z.object({
            target: z.string().describe('Target page ID: "single", "multi", "mesh", or "all"'),
            prompt: z.string().describe('The prompt/message to send')
        }),
        callback: async (input) => {
            if (!window.AgentMesh) return { error: 'AgentMesh not loaded' };
            try {
                const result = await window.AgentMesh.invoke(input.target, input.prompt);
                return { success: true, target: input.target, result: result.result || result };
            } catch (err) {
                return { error: err.message };
            }
        }
    });

    const listMeshPeersTool = tool({
        name: 'list_mesh_peers',
        description: 'List all connected agi.diy browser tabs',
        inputSchema: z.object({}),
        callback: async () => {
            if (!window.AgentMesh) return { error: 'AgentMesh not loaded' };
            const peers = window.AgentMesh.getPeers();
            return {
                myPage: window.AgentMesh.currentPage.id,
                peerCount: peers.length,
                peers: peers.map(p => ({ id: p.id, label: p.label, tabId: p.tabId })),
                availableTargets: [...new Set(peers.map(p => p.id))]
            };
        }
    });

    const broadcastMeshTool = tool({
        name: 'broadcast_mesh',
        description: 'Send message to ALL connected agi.diy tabs',
        inputSchema: z.object({
            message: z.string().describe('Message to broadcast')
        }),
        callback: async (input) => {
            if (!window.AgentMesh) return { error: 'AgentMesh not loaded' };
            try {
                const result = await window.AgentMesh.invoke('all', input.message);
                return { success: true, broadcast: true, responses: result };
            } catch (err) {
                return { error: err.message };
            }
        }
    });

    const addToMeshRingTool = tool({
        name: 'add_to_mesh_ring',
        description: 'Share context visible to ALL agents in ALL tabs',
        inputSchema: z.object({
            text: z.string().describe('Context to share'),
            agentType: z.string().optional().describe('Type (default: "multi")')
        }),
        callback: async (input) => {
            if (!window.AgentMesh?.addToRingContext) return { error: 'AgentMesh not available' };
            window.AgentMesh.addToRingContext('multi-agent', input.agentType || 'multi', input.text);
            return { success: true, added: input.text.slice(0, 100) };
        }
    });

    const getMeshRingTool = tool({
        name: 'get_mesh_ring',
        description: 'See what agents in other tabs are working on',
        inputSchema: z.object({ maxEntries: z.number().optional() }),
        callback: async (input) => {
            if (!window.AgentMesh?.getRingContext) return { error: 'AgentMesh not available' };
            const entries = window.AgentMesh.getRingContext();
            return {
                totalEntries: entries.length,
                recent: entries.slice(-(input.maxEntries || 10)).map(e => ({
                    agentId: e.agentId, type: e.agentType, text: e.text.slice(0, 200)
                }))
            };
        }
    });

    const MESH_TOOLS = [invokeMeshAgentTool, listMeshPeersTool, broadcastMeshTool, addToMeshRingTool, getMeshRingTool];

    const TOOLS = [
        // Core
        renderUiTool, javascriptEvalTool, storageGetTool, storageSetTool, fetchUrlTool, notifyTool,
        // Self-modification
        updateSelfTool, createToolTool, listToolsTool, deleteToolTool,
        // Agent management
        useAgentTool, schedulerTool,
        // Mesh communication (local + remote)
        invokeAgentTool, broadcastToAgentsTool, listAgentsTool, invokeRemoteAgentTool, subscribeTopicTool, publishTopicTool,
        // Cross-tab mesh
        ...MESH_TOOLS
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AGENT MANAGEMENT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    window.spawnAgent = async function() {
        const id = document.getElementById('spawnId').value.trim();
        const provider = document.getElementById('spawnProvider').value;
        const modelId = document.getElementById('spawnModelId').value.trim();
        const systemPrompt = document.getElementById('spawnPrompt').value.trim() || 'You are a helpful AI assistant.';
        const maxTokens = parseInt(document.getElementById('spawnMaxTokens').value) || DEFAULT_MAX_TOKENS;
        const additionalFieldsStr = document.getElementById('spawnAdditionalFields').value.trim();

        if (!id) { showToast('Enter agent ID'); return; }
        if (state.agents.has(id)) { showToast('Agent ID exists'); return; }

        // Parse additional request fields
        let additionalRequestFields = null;
        if (additionalFieldsStr) {
            try {
                additionalRequestFields = JSON.parse(additionalFieldsStr);
            } catch (e) {
                showToast('Invalid JSON in additional fields');
                return;
            }
        }

        // Get enabled tools
        const toolCheckboxes = document.querySelectorAll('#spawnToolsList input[name="spawn-tool"]:checked');
        const enabledTools = Array.from(toolCheckboxes).map(cb => cb.value);
        const allToolsEnabled = enabledTools.length === TOOLS.length;

        try {
            const model = createModel(provider, {
                modelId: modelId || undefined,
                maxTokens,
                additionalRequestFields
            });

            // Get the tools based on selection + custom tools
            const selectedTools = allToolsEnabled ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();
            const allTools = [...selectedTools, ...customTools];

            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(id, systemPrompt),
                printer: false
            });

            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;

            state.agents.set(id, {
                agent,
                model,
                config: {
                    provider,
                    modelId: modelId || undefined,
                    systemPrompt,
                    maxTokens,
                    additionalRequestFields,
                    enabledTools: allToolsEnabled ? null : enabledTools
                },
                messages: [],
                status: 'ready',
                color
            });

            closeModal('spawnModal');

            updateAgentUI();
            selectAgent(id);
            showToast(`Agent ${id} spawned`);
            saveState();
        } catch (e) {
            showToast('Error: ' + e.message);
        }
    };

    function buildSystemPrompt(agentId, basePrompt) {
        // üåê Inject AgentMesh peer context
        let meshContext = '';
        if (window.AgentMesh?.getPeerContext) {
            meshContext = window.AgentMesh.getPeerContext();
        }
        if (window.AgentMesh?.getRingContextForAgent) {
            const ringCtx = window.AgentMesh.getRingContextForAgent(agentId, 5);
            if (ringCtx) meshContext += ringCtx;
        }

        return `${basePrompt}

## Multi-Agent Context
You are agent "${agentId}" in a multi-agent system. You have access to:
- use_agent: Create sub-agents for parallel tasks
- scheduler: Schedule tasks (once or recurring cron)
- invoke_agent: Call another agent and wait for response
- broadcast_to_agents: Send message to all agents
- invoke_mesh_agent: Send prompts to agents in OTHER TABS (cross-tab mesh)
- list_mesh_peers: See all connected agi.diy tabs
- broadcast_mesh: Send message to ALL connected tabs

## Self-Modification
- update_self: Modify your own system prompt
- create_tool: Create new tools at runtime (persists across sessions)
- list_tools: See all available tools including custom ones
- delete_tool: Remove custom tools

Ring Attention: Other agents' recent messages are shared with you for context.

${meshContext}
${getRingContext()}`;
    }

    function getRingContext() {
        // Combine local ring buffer with AgentMesh shared ring
        let allEntries = [...state.ringBuffer];

        // Add AgentMesh ring entries (from other tabs)
        if (window.AgentMesh?.getRingContext) {
            const meshEntries = window.AgentMesh.getRingContext();
            for (const entry of meshEntries) {
                // Skip entries that are already in local buffer (avoid duplicates)
                const isDuplicate = allEntries.some(e =>
                    e.agentId === entry.agentId &&
                    Math.abs(e.timestamp - entry.timestamp) < 5000 &&
                    e.content?.slice(0, 50) === entry.text?.slice(0, 50)
                );
                if (!isDuplicate) {
                    allEntries.push({
                        agentId: entry.agentId,
                        role: 'assistant',
                        content: entry.text,
                        timestamp: entry.timestamp,
                        isMesh: true,
                        agentType: entry.agentType
                    });
                }
            }
        }

        // Sort by timestamp and take recent
        allEntries.sort((a, b) => a.timestamp - b.timestamp);
        const recent = allEntries.slice(-15);

        if (recent.length === 0) return '';

        return '## Recent Messages from Agents:\n' + recent.map(e => {
            const source = e.isMesh ? ` (${e.agentType || 'mesh'})` : '';
            return `[${e.agentId}${source}]: ${(e.content || '').slice(0, 200)}...`;
        }).join('\n');
    }

    window.selectAgent = function(agentId) {
        state.activeAgentId = agentId;
        updateAgentUI();
        renderMessages();

        const agentData = state.agents.get(agentId);
        if (agentData) {
            document.getElementById('currentAgentName').textContent = agentId;
            document.getElementById('currentAgentModel').textContent = `${agentData.config.provider} ‚Ä¢ ${agentData.config.modelId || 'default'}`;
        }
    };

    window.killAgent = function(agentId, event) {
        event.stopPropagation();
        if (!confirm(`Kill agent ${agentId}?`)) return;

        state.agents.delete(agentId);
        if (state.activeAgentId === agentId) {
            state.activeAgentId = state.agents.keys().next().value || null;
        }
        updateAgentUI();
        renderMessages();
        showToast(`Agent ${agentId} killed`);
        saveState();
    };

    function updateAgentUI() {
        const agentListHtml = [];
        const targetOptions = ['<option value="all">All Agents</option>'];

        for (const [id, data] of state.agents) {
            const isActive = id === state.activeAgentId;
            agentListHtml.push(`
                <div class="agent-card ${isActive ? 'active' : ''}" onclick="selectAgent('${id}')">
                    <div class="agent-card-header">
                        <span class="agent-dot" style="background:${data.color}"></span>
                        <span class="agent-name">${id}</span>
                        <span class="agent-status ${data.status}">${data.status}</span>
                    </div>
                    <div class="agent-meta">
                        <span>${data.config.provider}</span>
                        <span>
                            <span class="agent-edit" onclick="openEditAgentModal('${id}', event)" title="Edit agent">‚úé</span>
                            <span class="agent-kill" onclick="killAgent('${id}', event)" title="Kill agent">‚úï</span>
                        </span>
                    </div>
                </div>
            `);
            targetOptions.push(`<option value="${id}">${id}</option>`);
        }

        document.getElementById('agentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('mobileAgentList').innerHTML = agentListHtml.join('') || '<div style="font-size:11px;color:var(--text-tertiary);">No agents yet</div>';
        document.getElementById('targetAgent').innerHTML = targetOptions.join('');

        // Update schedule agent dropdown
        const scheduleAgentSelect = document.getElementById('scheduleAgent');
        if (scheduleAgentSelect) {
            scheduleAgentSelect.innerHTML = [...state.agents.keys()].map(id => `<option value="${id}">${id}</option>`).join('');
        }
    }

    function updateScheduleUI() {
        const container = document.getElementById('scheduleList');
        if (state.schedules.size === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);">No tasks scheduled</div>';
            return;
        }

        let html = '';
        for (const [id, s] of state.schedules) {
            html += `
                <div class="schedule-item">
                    <div class="schedule-item-header">
                        <strong>${s.name}</strong>
                        <span class="schedule-delete" onclick="deleteSchedule('${id}')">‚úï</span>
                    </div>
                    <div>Agent: ${s.agentId}</div>
                    <div class="schedule-cron">${s.type === 'cron' ? s.cron : `once in ${s.delay}s`}</div>
                </div>
            `;
        }
        container.innerHTML = html;
    }

    window.deleteSchedule = function(id) {
        const s = state.schedules.get(id);
        if (s) {
            if (s.timer) clearTimeout(s.timer);
            if (s.interval) clearInterval(s.interval);
            state.schedules.delete(id);
            updateScheduleUI();
            saveState();
            showToast('Schedule deleted');
        }
    };

    // Auto-create default agent if none exist and credentials are available
    async function autoCreateDefaultAgent() {
        if (state.agents.size > 0) return; // Already have agents

        // Check for any configured credentials
        const hasAnthropic = state.credentials.anthropic.apiKey;
        const hasOpenAI = state.credentials.openai.apiKey;
        const hasBedrock = state.credentials.bedrock.apiKey;
        const hasCompat = state.credentials.openai_compatible?.baseUrl;

        // Determine which provider to use (priority: bedrock > anthropic > openai > compat > webllm)
        let provider;
        if (hasBedrock) provider = 'bedrock';
        else if (hasAnthropic) provider = 'anthropic';
        else if (hasOpenAI) provider = 'openai';
        else if (hasCompat) provider = 'openai_compatible';
        else provider = 'webllm';

        try {
            // Use bedrock defaults with extended thinking
            const modelConfig = {
                maxTokens: DEFAULT_MAX_TOKENS,
                additionalRequestFields: provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
            };
            const model = createModel(provider, modelConfig);

            // Include custom tools
            const customTools = buildCustomTools();
            const allTools = [...TOOLS, ...customTools];

            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt('assistant', 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, create custom tools, and coordinate with other agents.'),
                printer: false
            });

            const color = state.agentColors[state.colorIndex % state.agentColors.length];
            state.colorIndex++;

            state.agents.set('assistant', {
                agent,
                model,
                config: {
                    provider,
                    systemPrompt: 'You are AGI, a helpful AI assistant. You can spawn sub-agents, schedule tasks, create custom tools, and coordinate with other agents.',
                    maxTokens: DEFAULT_MAX_TOKENS,
                    additionalRequestFields: provider === 'bedrock' ? DEFAULT_BEDROCK_ADDITIONAL_FIELDS : null
                },
                messages: [],
                status: 'ready',
                color
            });

            state.activeAgentId = 'assistant';
            updateAgentUI();
            renderMessages();
            saveState();

            console.log('‚úÖ Default agent "assistant" created automatically');
            showToast('Default agent ready');
        } catch (e) {
            console.warn('Could not auto-create default agent:', e);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESSAGING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let streamingEls = new Map(); // agentId -> streaming element
    let broadcastMode = false; // true when sending to all agents

    async function runAgentMessage(agentId, message) {
        const agentData = state.agents.get(agentId);
        if (!agentData) return;

        // Add to ring buffer FIRST so it's included in system prompt
        state.ringBuffer.push({ agentId, role: 'user', content: message, timestamp: Date.now() });
        if (state.ringBuffer.length > 100) state.ringBuffer.shift();
        // üåê Sync to AgentMesh shared ring
        if (window.AgentMesh?.addToRingContext) {
            window.AgentMesh.addToRingContext(agentId, 'multi', `[User‚Üí${agentId}] ${message.slice(0, 300)}`);
        }
        updateRingUI();

        // Create a FRESH agent instance for each message (allows parallelism)
        // The stored agentData.agent is just a reference/template
        let activeAgent;
        try {
            const model = createModel(agentData.config.provider, {
                modelId: agentData.config.modelId,
                maxTokens: agentData.config.maxTokens || DEFAULT_MAX_TOKENS,
                additionalRequestFields: agentData.config.additionalRequestFields || null
            });

            // Get the tools based on agent's enabled tools config + custom tools
            const enabledTools = agentData.config.enabledTools;
            const selectedTools = (!enabledTools || enabledTools === null) ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();  // Include dynamically created tools!
            const allTools = [...selectedTools, ...customTools];

            activeAgent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(agentId, agentData.config.systemPrompt),
                printer: false
            });

            // Inject conversation history from this agent's messages
            if (agentData.messages.length > 0) {
                // Load recent conversation history (last 20 messages)
                const recentHistory = agentData.messages.slice(-20);
                for (const msg of recentHistory) {
                    activeAgent.messages.push({
                        role: msg.role,
                        content: [{ type: 'textBlock', text: msg.content }]
                    });
                }
                console.log(`Injected ${recentHistory.length} messages of history for ${agentId}`);
            }
        } catch (e) {
            console.error(`Failed to create agent instance for ${agentId}:`, e);
            addMessageToUI('error', `Failed to create agent: ${e.message}`, agentId, agentData.color);
            return;
        }

        agentData.status = 'processing';
        updateAgentUI();

        // Add user message to stored history
        agentData.messages.push({ role: 'user', content: message, timestamp: Date.now() });
        const shouldShow = broadcastMode || agentId === state.activeAgentId;

        if (shouldShow) {
            addMessageToUI('user', message, agentId, agentData.color);
            addThinking();
        }

        try {
            let currentText = '';

            for await (const event of activeAgent.stream(message)) {
                if (!event?.type) continue;

                if (event.type === 'modelContentBlockDeltaEvent' && event.delta?.type === 'textDelta') {
                    currentText += event.delta.text;
                    if (shouldShow) updateStreaming(currentText, agentId, agentData.color);
                }
                else if (event.type === 'beforeToolCallEvent' && shouldShow) {
                    addToolCall(event.toolUse?.name, event.toolUse?.input, 'running');
                }
                else if (event.type === 'afterToolCallEvent' && shouldShow) {
                    updateToolStatus(event.toolUse?.name, event.result?.status || 'success');
                }
            }


            if (shouldShow) {
                removeThinking();
                if (currentText) finalizeStreaming(currentText, agentId, agentData.color);
            }

            agentData.messages.push({ role: 'assistant', content: currentText, timestamp: Date.now() });

            // Add to ring buffer
            state.ringBuffer.push({ agentId, role: 'assistant', content: currentText, timestamp: Date.now() });
            if (state.ringBuffer.length > 100) state.ringBuffer.shift();
            // üåê Sync to AgentMesh shared ring
            if (window.AgentMesh?.addToRingContext) {
                window.AgentMesh.addToRingContext(agentId, 'multi', currentText.slice(0, 500));
            }
            updateRingUI();

            agentData.status = 'ready';
        } catch (e) {
            console.error(`Agent ${agentId} error:`, e);
            agentData.status = 'error';

            if (shouldShow) {
                removeThinking();
                addMessageToUI('error', e.message, agentId, agentData.color);
            }
        }

        updateAgentUI();
        saveState();
    }

    window.sendMessage = async function() {
        const input = document.getElementById('inputField');
        const text = input.value.trim();
        if (!text) return;

        const target = document.getElementById('targetAgent').value;

        // If no agents exist, try to create default agent first
        if (state.agents.size === 0) {
            const hasAnyKey = state.credentials.anthropic.apiKey ||
                              state.credentials.openai.apiKey ||
                              state.credentials.bedrock.apiKey;

            if (!hasAnyKey) {
                showToast('Add API key in Settings first');
                openSettingsModal();
                return;
            }

            // Create default agent on the fly
            showToast('Creating agent...');
            await autoCreateDefaultAgent();

            if (state.agents.size === 0) {
                showToast('Failed to create agent');
                return;
            }
        }

        input.value = '';

        broadcastMode = (target === 'all');
        if (target === 'all') {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text);
            }
        } else {
            runAgentMessage(target, text);
        }
    };

    window.broadcastMessage = function() {
        broadcastMode = true;
        const text = prompt('Broadcast message to all agents:');
        if (text?.trim()) {
            for (const agentId of state.agents.keys()) {
                runAgentMessage(agentId, text.trim());
            }
        }
    };

    window.clearChat = function() {
        if (!state.activeAgentId) {
            showToast('No active agent to clear');
            return;
        }

        const agentData = state.agents.get(state.activeAgentId);
        if (agentData) {
            agentData.messages = [];
            renderMessages();
            showToast('Chat cleared');
            saveState();
        }
    };

    window.handleKeyDown = function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderMessages() {
        const inner = document.getElementById('messagesInner');
        inner.innerHTML = '';

        if (!state.activeAgentId) {
            inner.innerHTML = `<div class="message system"><div class="message-content">
                <strong>Getting Started</strong><br><br>
                ${Object.values(state.credentials).some(c => c.apiKey)
                    ? 'Creating default agent... If this takes too long, try clicking "+ New Agent".'
                    : 'Add your API key in ‚öôÔ∏è Settings to start chatting, or click "+ New Agent" to configure a new agent.'}
            </div></div>`;
            document.getElementById('currentAgentName').textContent = 'No Agent Selected';
            document.getElementById('currentAgentModel').textContent = '‚Äî';
            return;
        }

        const agentData = state.agents.get(state.activeAgentId);
        if (!agentData) return;

        for (const msg of agentData.messages) {
            addMessageToUI(msg.role, msg.content, state.activeAgentId, agentData.color, false);
        }
        scrollToBottom();
    }

    function addMessageToUI(role, content, agentId, color, scroll = true) {
        const inner = document.getElementById('messagesInner');
        const msg = document.createElement('div');
        msg.className = `message ${role}`;

        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        msg.innerHTML = `
            <div class="message-header">
                <span class="message-role">${role === 'user' ? 'you' : role === 'assistant' ? 'agi' : role}</span>
                <span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>
                <span class="message-time">${time}</span>
            </div>
            <div class="message-content">${role === 'user' ? escapeHtml(content) : `<div class="markdown-content">${marked.parse(content)}</div>`}</div>
        `;

        inner.appendChild(msg);
        if (scroll) scrollToBottom();
    }

    function updateStreaming(text, agentId, color) {
        const inner = document.getElementById('messagesInner');
        removeThinking();

        let streamingEl = streamingEls.get(agentId);
        if (!streamingEl) {
            streamingEl = document.createElement('div');
            streamingEl.className = 'message assistant';
            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            streamingEl.innerHTML = `
                <div class="message-header">
                    <span class="message-role">agi</span>
                    <span class="message-agent" style="background:${color}20;color:${color}">${agentId}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content"><div class="markdown-content"></div></div>
            `;
            inner.appendChild(streamingEl);
            streamingEls.set(agentId, streamingEl);
        }

        streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
        scrollToBottom();
    }

    function finalizeStreaming(text, agentId, color) {
        const streamingEl = streamingEls.get(agentId);
        if (streamingEl) {
            streamingEl.querySelector('.markdown-content').innerHTML = marked.parse(text);
            streamingEls.delete(agentId);
        }
    }

    function addToolCall(name, input, status) {
        const inner = document.getElementById('messagesInner');
        const tool = document.createElement('div');
        tool.className = 'tool-block';
        tool.id = `tool-${name}-${Date.now()}`;
        tool.innerHTML = `
            <div class="tool-header">
                <div class="tool-status ${status}"></div>
                <span class="tool-name">${name}</span>
            </div>
            <details><summary style="cursor:pointer;color:var(--text-tertiary);font-size:10px;margin-top:8px;">input</summary>
            <div class="tool-input">${JSON.stringify(input, null, 2)}</div></details>
        `;
        inner.appendChild(tool);
        scrollToBottom();
    }

    function updateToolStatus(name, status) {
        const blocks = document.querySelectorAll('.tool-block');
        for (let i = blocks.length - 1; i >= 0; i--) {
            if (blocks[i].querySelector('.tool-name')?.textContent === name) {
                blocks[i].querySelector('.tool-status').className = `tool-status ${status === 'error' ? 'error' : ''}`;
                break;
            }
        }
    }

    function addThinking() {
        const inner = document.getElementById('messagesInner');
        if (inner.querySelector('.thinking-indicator')) return;
        const el = document.createElement('div');
        el.className = 'message assistant thinking-indicator';
        el.innerHTML = '<div class="message-content"><div class="thinking"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div></div>';
        inner.appendChild(el);
        scrollToBottom();
    }

    function removeThinking() {
        document.querySelector('.thinking-indicator')?.remove();
    }

    function updateRingUI() {
        const container = document.getElementById('ringContent');

        // Combine local ring with AgentMesh shared ring
        let allEntries = state.ringBuffer.map((e, idx) => ({ ...e, localIndex: idx }));

        // Add AgentMesh ring entries (from other tabs)
        if (window.AgentMesh?.getRingContext) {
            const meshEntries = window.AgentMesh.getRingContext();
            for (const entry of meshEntries) {
                // Skip entries that look like duplicates
                const isDuplicate = allEntries.some(e =>
                    e.agentId === entry.agentId &&
                    Math.abs(e.timestamp - entry.timestamp) < 5000 &&
                    e.content?.slice(0, 50) === entry.text?.slice(0, 50)
                );
                if (!isDuplicate) {
                    allEntries.push({
                        agentId: entry.agentId,
                        role: 'assistant',
                        content: entry.text,
                        timestamp: entry.timestamp,
                        isMesh: true,
                        agentType: entry.agentType
                    });
                }
            }
        }

        // Sort by timestamp descending (most recent first)
        allEntries.sort((a, b) => b.timestamp - a.timestamp);
        const recent = allEntries.slice(0, 20);

        if (recent.length === 0) {
            container.innerHTML = '<div style="font-size:11px;color:var(--text-tertiary);text-align:center;padding:20px;">Shared context will appear here</div>';
            return;
        }

        container.innerHTML = recent.map((e) => {
            const agentData = state.agents.get(e.agentId);
            const color = agentData?.color || (e.isMesh ? '#007aff' : '#888');
            const time = new Date(e.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const meshBadge = e.isMesh ? `<span style="font-size:9px;color:#007aff;margin-left:4px;">üåê ${e.agentType || 'mesh'}</span>` : '';
            const deleteBtn = e.isMesh ? '' : `<span class="ring-entry-delete" onclick="deleteRingEntry(${e.localIndex})" title="Delete this entry">‚úï</span>`;
            const borderStyle = e.isMesh ? 'border-left:2px solid #007aff;' : '';

            return `
                <div class="ring-entry" style="${borderStyle}">
                    <div class="ring-entry-header">
                        <span class="ring-entry-agent" style="color:${color}">${e.agentId}${meshBadge}</span>
                        <div class="ring-entry-meta">
                            <span class="ring-entry-time">${time}</span>
                            ${deleteBtn}
                        </div>
                    </div>
                    <div class="ring-entry-content">${escapeHtml((e.content || '').slice(0, 150))}${(e.content || '').length > 150 ? '...' : ''}</div>
                </div>
            `;
        }).join('');
    }

    window.clearRingContext = function() {
        if (state.ringBuffer.length === 0) {
            showToast('Ring context is already empty');
            return;
        }
        if (!confirm('Clear all ring context? This cannot be undone.')) return;
        state.ringBuffer = [];
        updateRingUI();
        saveState();
        showToast('Ring context cleared');
    };

    window.deleteRingEntry = function(index) {
        if (index >= 0 && index < state.ringBuffer.length) {
            state.ringBuffer.splice(index, 1);
            updateRingUI();
            saveState();
            showToast('Entry deleted');
        }
    };

    function scrollToBottom() {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODALS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    window.openSpawnModal = () => {
        // Reset form with bedrock defaults
        document.getElementById('spawnId').value = '';
        document.getElementById('spawnProvider').value = 'bedrock';
        document.getElementById('spawnModelId').value = '';
        document.getElementById('spawnPrompt').value = '';
        document.getElementById('spawnMaxTokens').value = String(DEFAULT_MAX_TOKENS);
        document.getElementById('spawnAdditionalFields').value = JSON.stringify(DEFAULT_BEDROCK_ADDITIONAL_FIELDS, null, 2);

        // Update model hint
        updateSpawnModelDefaults();

        // Render tools list (all enabled by default)
        renderSpawnToolsList();

        document.getElementById('spawnModal').classList.add('active');
    };

    window.updateSpawnModelDefaults = function() {
        const provider = document.getElementById('spawnProvider').value;
        const hintEl = document.getElementById('spawnModelHint');
        hintEl.textContent = `Default: ${DEFAULT_MODELS[provider] || 'unknown'}`;

        // Show/hide additional fields based on provider
        const additionalFieldsGroup = document.getElementById('spawnAdditionalFieldsGroup');
        const additionalFieldsInput = document.getElementById('spawnAdditionalFields');

        if (provider === 'bedrock') {
            additionalFieldsGroup.style.display = 'block';
            // Pre-populate with default bedrock fields if empty
            if (!additionalFieldsInput.value.trim()) {
                additionalFieldsInput.value = JSON.stringify(DEFAULT_BEDROCK_ADDITIONAL_FIELDS, null, 2);
            }
        } else if (provider === 'anthropic') {
            additionalFieldsGroup.style.display = 'block';
        } else {
            additionalFieldsGroup.style.display = 'none';
        }
    };

    function renderSpawnToolsList() {
        const container = document.getElementById('spawnToolsList');
        const allTools = [
            { name: 'render_ui', desc: 'Render HTML/CSS/JS' },
            { name: 'javascript_eval', desc: 'Execute JavaScript' },
            { name: 'storage_get', desc: 'Get localStorage' },
            { name: 'storage_set', desc: 'Set localStorage' },
            { name: 'fetch_url', desc: 'HTTP requests' },
            { name: 'notify', desc: 'Browser notifications' },
            { name: 'update_self', desc: 'Modify system prompt' },
            { name: 'create_tool', desc: 'Create new tools' },
            { name: 'list_tools', desc: 'List all tools' },
            { name: 'delete_tool', desc: 'Delete custom tools' },
            { name: 'use_agent', desc: 'Create sub-agents' },
            { name: 'scheduler', desc: 'Schedule tasks' },
            { name: 'invoke_agent', desc: 'Call another agent' },
            { name: 'broadcast_to_agents', desc: 'Broadcast to all' },
            { name: 'list_agents', desc: 'List all agents' },
            { name: 'invoke_remote_agent', desc: 'Call remote agent' },
            { name: 'subscribe_topic', desc: 'Subscribe to topic' },
            { name: 'publish_topic', desc: 'Publish to topic' }
        ];

        container.innerHTML = allTools.map(t => `
            <label class="tool-item enabled" onclick="toggleToolItem(this)">
                <input type="checkbox" name="spawn-tool" value="${t.name}" checked>
                <div>
                    <div class="tool-item-name">${t.name}</div>
                    <div class="tool-item-desc">${t.desc}</div>
                </div>
            </label>
        `).join('');
    }

    window.openEditAgentModal = function(agentId, event) {
        event.stopPropagation();
        const agentData = state.agents.get(agentId);
        if (!agentData) return;

        document.getElementById('editAgentId').value = agentId;
        document.getElementById('editAgentTitle').textContent = agentId;
        document.getElementById('editProvider').value = agentData.config.provider;
        document.getElementById('editModelId').value = agentData.config.modelId || '';
        document.getElementById('editPrompt').value = agentData.config.systemPrompt || '';
        document.getElementById('editMaxTokens').value = agentData.config.maxTokens || 16000;
        document.getElementById('editAdditionalFields').value = agentData.config.additionalRequestFields
            ? JSON.stringify(agentData.config.additionalRequestFields, null, 2)
            : '';

        // Update model hint
        updateEditModelDefaults();

        // Show/hide additional fields based on provider
        const provider = agentData.config.provider;
        document.getElementById('editAdditionalFieldsGroup').style.display =
            (provider === 'anthropic' || provider === 'bedrock') ? 'block' : 'none';

        // Render tools list
        renderEditToolsList(agentData.config.enabledTools || null);

        document.getElementById('editAgentModal').classList.add('active');
    };

    window.updateEditModelDefaults = function() {
        const provider = document.getElementById('editProvider').value;
        const hintEl = document.getElementById('editModelHint');
        hintEl.textContent = `Default: ${DEFAULT_MODELS[provider] || 'unknown'}`;

        // Show/hide additional fields based on provider
        document.getElementById('editAdditionalFieldsGroup').style.display =
            (provider === 'anthropic' || provider === 'bedrock') ? 'block' : 'none';
    };

    function renderEditToolsList(enabledTools) {
        const container = document.getElementById('editToolsList');
        // All available tools with descriptions
        const allTools = [
            { name: 'render_ui', desc: 'Render HTML/CSS/JS' },
            { name: 'javascript_eval', desc: 'Execute JavaScript' },
            { name: 'storage_get', desc: 'Get localStorage' },
            { name: 'storage_set', desc: 'Set localStorage' },
            { name: 'fetch_url', desc: 'HTTP requests' },
            { name: 'notify', desc: 'Browser notifications' },
            { name: 'update_self', desc: 'Modify system prompt' },
            { name: 'create_tool', desc: 'Create new tools' },
            { name: 'list_tools', desc: 'List all tools' },
            { name: 'delete_tool', desc: 'Delete custom tools' },
            { name: 'use_agent', desc: 'Create sub-agents' },
            { name: 'scheduler', desc: 'Schedule tasks' },
            { name: 'invoke_agent', desc: 'Call another agent' },
            { name: 'broadcast_to_agents', desc: 'Broadcast to all' },
            { name: 'list_agents', desc: 'List all agents' },
            { name: 'invoke_remote_agent', desc: 'Call remote agent' },
            { name: 'subscribe_topic', desc: 'Subscribe to topic' },
            { name: 'publish_topic', desc: 'Publish to topic' }
        ];

        // If enabledTools is null, all tools are enabled
        const isAllEnabled = enabledTools === null;

        container.innerHTML = allTools.map(t => {
            const enabled = isAllEnabled || (enabledTools && enabledTools.includes(t.name));
            return `
                <label class="tool-item ${enabled ? 'enabled' : ''}" onclick="toggleToolItem(this)">
                    <input type="checkbox" name="tool" value="${t.name}" ${enabled ? 'checked' : ''}>
                    <div>
                        <div class="tool-item-name">${t.name}</div>
                        <div class="tool-item-desc">${t.desc}</div>
                    </div>
                </label>
            `;
        }).join('');
    }

    window.toggleToolItem = function(el) {
        el.classList.toggle('enabled');
    };

    window.saveAgentEdit = async function() {
        const agentId = document.getElementById('editAgentId').value;
        const agentData = state.agents.get(agentId);
        if (!agentData) return;

        const provider = document.getElementById('editProvider').value;
        const modelId = document.getElementById('editModelId').value.trim();
        const systemPrompt = document.getElementById('editPrompt').value.trim() || 'You are a helpful AI assistant.';
        const maxTokens = parseInt(document.getElementById('editMaxTokens').value) || DEFAULT_MAX_TOKENS;
        const additionalFieldsStr = document.getElementById('editAdditionalFields').value.trim();

        // Parse additional request fields
        let additionalRequestFields = null;
        if (additionalFieldsStr) {
            try {
                additionalRequestFields = JSON.parse(additionalFieldsStr);
            } catch (e) {
                showToast('Invalid JSON in additional fields');
                return;
            }
        }

        // Get enabled tools
        const toolCheckboxes = document.querySelectorAll('#editToolsList input[name="tool"]:checked');
        const enabledTools = Array.from(toolCheckboxes).map(cb => cb.value);

        // Check if all tools are enabled
        const allToolsEnabled = enabledTools.length === TOOLS.length;

        try {
            // Create new model with updated config
            const model = createModel(provider, {
                modelId: modelId || undefined,
                maxTokens,
                additionalRequestFields
            });

            // Get the tools based on selection + custom tools
            const selectedTools = allToolsEnabled ? TOOLS : TOOLS.filter(t => enabledTools.includes(t.name));
            const customTools = buildCustomTools();
            const allTools = [...selectedTools, ...customTools];

            // Create new agent instance
            const agent = new Agent({
                model,
                tools: allTools,
                systemPrompt: buildSystemPrompt(agentId, systemPrompt),
                printer: false
            });

            // Update agent data
            agentData.agent = agent;
            agentData.model = model;
            agentData.config = {
                provider,
                modelId: modelId || undefined,
                systemPrompt,
                maxTokens,
                additionalRequestFields,
                enabledTools: allToolsEnabled ? null : enabledTools
            };

            closeModal('editAgentModal');
            updateAgentUI();
            saveState();
            showToast(`Agent ${agentId} updated`);

            // Update header if this is the active agent

            if (agentId === state.activeAgentId) {
                document.getElementById('currentAgentName').textContent = agentId;
                document.getElementById('currentAgentModel').textContent = `${provider} ‚Ä¢ ${modelId || DEFAULT_MODELS[provider]}`;
            }
        } catch (e) {
            showToast('Error: ' + e.message);
        }
    };

    window.openSettingsModal = () => {
        document.getElementById('anthropicKey').value = state.credentials.anthropic.apiKey;
        document.getElementById('openaiKey').value = state.credentials.openai.apiKey;
        document.getElementById('bedrockKey').value = state.credentials.bedrock.apiKey;
        document.getElementById('bedrockRegion').value = state.credentials.bedrock.region;
        document.getElementById('compatBaseUrl').value = state.credentials.openai_compatible?.baseUrl || '';
        document.getElementById('compatKey').value = state.credentials.openai_compatible?.apiKey || '';
        document.getElementById('compatModel').value = state.credentials.openai_compatible?.model || '';
        document.getElementById('webllmModel').value = state.credentials.webllm?.model || 'Qwen2.5-3B-Instruct-q4f16_1-MLC';
        // Load network settings
        document.getElementById('relayUrl').value = localStorage.getItem('mesh_relay_url') || '';
        document.getElementById('instanceId').value = agentMesh.instanceId || '';
        agentMesh.updateWsStatus(agentMesh.wsConnected);
        agentMesh.updateRemotePeersUI();
        document.getElementById('settingsModal').classList.add('active');
    };
    window.closeModal = (id) => document.getElementById(id).classList.remove('active');

    window.showTab = function(e, tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        document.getElementById(`tab-${tabName}`).classList.add('active');
    };

    window.toggleScheduleFields = function() {
        const type = document.getElementById('scheduleType').value;
        document.getElementById('delayField').style.display = type === 'once' ? 'block' : 'none';
        document.getElementById('cronField').style.display = type === 'cron' ? 'block' : 'none';
    };

    window.toggleMobileSidebar = () => document.getElementById('mobileSidebar').classList.toggle('active');

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENCRYPTED SYNC - Export/Import API keys via encrypted URL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async function deriveKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
        return crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
    }

    async function encryptData(data, password) {
        const plaintext = JSON.stringify(data);
        const enc = new TextEncoder();
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const key = await deriveKey(password, salt);
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(plaintext));
        const combined = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
        combined.set(salt, 0);
        combined.set(iv, salt.length);
        combined.set(new Uint8Array(ciphertext), salt.length + iv.length);
        return btoa(String.fromCharCode(...combined));
    }

    async function decryptData(encryptedBase64, password) {
        const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const ciphertext = combined.slice(28);
        const key = await deriveKey(password, salt);
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
        return JSON.parse(new TextDecoder().decode(plaintext));
    }

    window.exportSyncUrl = async function() {
        const password = document.getElementById('syncExportPassword')?.value;
        if (!password || password.length < 4) {
            showToast('Password must be 4+ chars');
            return;
        }

        try {
            const data = {
                anthropic: state.credentials.anthropic,
                openai: state.credentials.openai,
                bedrock: state.credentials.bedrock
            };
            const encrypted = await encryptData(data, password);
            const url = `${window.location.origin}${window.location.pathname}?import=${encrypted}`;

            document.getElementById('syncExportedUrl').value = url;
            document.getElementById('syncExportResult').style.display = 'block';
            showToast('Settings encrypted!');
        } catch (e) {
            showToast('Export failed: ' + e.message);
        }
    };

    window.importSyncUrl = async function() {
        const urlOrData = document.getElementById('syncImportUrl')?.value?.trim();
        const password = document.getElementById('syncImportPassword')?.value;

        if (!urlOrData || !password) {
            showToast('Enter URL and password');
            return;
        }

        try {
            let encryptedData = urlOrData;
            if (urlOrData.includes('?import=')) {
                encryptedData = new URL(urlOrData).searchParams.get('import');
            }

            const data = await decryptData(encryptedData, password);

            // Apply credentials
            if (data.anthropic) state.credentials.anthropic = { ...state.credentials.anthropic, ...data.anthropic };
            if (data.openai) state.credentials.openai = { ...state.credentials.openai, ...data.openai };
            if (data.bedrock) state.credentials.bedrock = { ...state.credentials.bedrock, ...data.bedrock };

            // Update UI
            document.getElementById('anthropicKey').value = state.credentials.anthropic.apiKey || '';
            document.getElementById('openaiKey').value = state.credentials.openai.apiKey || '';
            document.getElementById('bedrockKey').value = state.credentials.bedrock.apiKey || '';
            document.getElementById('bedrockRegion').value = state.credentials.bedrock.region || 'us-east-1';

            saveState();
            showToast('Settings imported!');

            // Clear fields
            document.getElementById('syncImportUrl').value = '';
            document.getElementById('syncImportPassword').value = '';
        } catch (e) {
            showToast('Import failed - wrong password?');
        }
    };

    // Check for ?import= URL param on load
    function checkForImportParam() {
        const url = new URL(window.location.href);
        const importData = url.searchParams.get('import');
        if (importData) {
            window.history.replaceState({}, '', window.location.pathname);
            openSettingsModal();
            setTimeout(() => {
                document.querySelector('.tab[onclick*="sync"]')?.click();
                document.getElementById('syncImportUrl').value = window.location.origin + window.location.pathname + '?import=' + importData;
                showToast('Import URL detected - enter password');
            }, 100);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CREDENTIALS & PERSISTENCE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    window.saveCredentials = function() {
        state.credentials.anthropic.apiKey = document.getElementById('anthropicKey').value.trim();
        state.credentials.openai.apiKey = document.getElementById('openaiKey').value.trim();
        state.credentials.bedrock.apiKey = document.getElementById('bedrockKey').value.trim();
        state.credentials.bedrock.region = document.getElementById('bedrockRegion').value;
        state.credentials.openai_compatible = state.credentials.openai_compatible || {};
        state.credentials.openai_compatible.baseUrl = document.getElementById('compatBaseUrl').value.trim();
        state.credentials.openai_compatible.apiKey = document.getElementById('compatKey').value.trim();
        state.credentials.openai_compatible.model = document.getElementById('compatModel').value.trim();
        state.credentials.webllm = state.credentials.webllm || {};
        state.credentials.webllm.model = document.getElementById('webllmModel').value;

        // üîë Sync to AgentMesh unified credentials (cross-tab)
        if (window.AgentMesh?.setCredentials) {
            window.AgentMesh.setCredentials({
                anthropic: { apiKey: state.credentials.anthropic.apiKey, model: state.credentials.anthropic.model },
                openai: { apiKey: state.credentials.openai.apiKey, model: state.credentials.openai.model },
                bedrock: { apiKey: state.credentials.bedrock.apiKey, region: state.credentials.bedrock.region, model: state.credentials.bedrock.model }
            });
        }

        saveState();
        showToast('Credentials saved');
        closeModal('settingsModal');
    };

    // Network relay functions
    window.connectRelay = function() {
        const url = document.getElementById('relayUrl').value.trim();
        const instanceId = document.getElementById('instanceId').value.trim();

        if (!url) {
            showToast('Enter relay URL');
            return;
        }

        if (instanceId) {
            agentMesh.instanceId = instanceId;
            localStorage.setItem('mesh_instance_id', instanceId);
        }

        agentMesh.connectRelay(url);
    };

    window.disconnectRelay = function() {
        agentMesh.disconnectRelay();
        localStorage.removeItem('mesh_relay_url');
    };

    function saveState() {
        const data = {
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer.slice(-50)
        };

        for (const [id, agentData] of state.agents) {
            data.agents.push({
                id,
                config: agentData.config,
                messages: agentData.messages.slice(-50),
                color: agentData.color
            });
        }

        localStorage.setItem('agi_multi_state', JSON.stringify(data));
    }

    function loadState() {
        try {
            const stored = localStorage.getItem('agi_multi_state');
            if (!stored) return;

            const data = JSON.parse(stored);
            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];

            // üîë AgentMesh is the credential authority ‚Äî always prefer its values
            if (window.AgentMesh?.getCredentials) {
                const mc = window.AgentMesh.getCredentials();
                if (mc.anthropic?.apiKey) state.credentials.anthropic.apiKey = mc.anthropic.apiKey;
                if (mc.openai?.apiKey) state.credentials.openai.apiKey = mc.openai.apiKey;
                if (mc.bedrock?.apiKey) state.credentials.bedrock.apiKey = mc.bedrock.apiKey;
                if (mc.bedrock?.region) state.credentials.bedrock.region = mc.bedrock.region;
            }

            for (const agentData of data.agents || []) {
                try {
                    const model = createModel(agentData.config.provider, agentData.config);
                    const agent = new Agent({
                        model,
                        tools: TOOLS,
                        systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                        printer: false
                    });

                    state.agents.set(agentData.id, {
                        agent,
                        model,
                        config: agentData.config,
                        messages: agentData.messages || [],
                        status: 'ready',
                        color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                    });
                } catch (e) {
                    console.warn(`Failed to restore agent ${agentData.id}:`, e);
                }
            }

            if (state.agents.size > 0) {
                state.activeAgentId = state.agents.keys().next().value;
            }
        } catch (e) {
            console.warn('Failed to load state:', e);
        }
    }

    window.exportAllAgents = function() {
        const data = {
            version: 1,
            exported: new Date().toISOString(),
            credentials: state.credentials,
            agents: [],
            ringBuffer: state.ringBuffer
        };

        for (const [id, agentData] of state.agents) {
            data.agents.push({ id, config: agentData.config, messages: agentData.messages, color: agentData.color });
        }

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `agi-multi-export-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('State exported');
    };

    window.importAgents = async function(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const text = await file.text();
            const data = JSON.parse(text);

            state.credentials = data.credentials || state.credentials;
            state.ringBuffer = data.ringBuffer || [];

            for (const agentData of data.agents || []) {
                if (state.agents.has(agentData.id)) continue;

                const model = createModel(agentData.config.provider, agentData.config);
                const agent = new Agent({
                    model,
                    tools: TOOLS,
                    systemPrompt: buildSystemPrompt(agentData.id, agentData.config.systemPrompt),
                    printer: false
                });

                state.agents.set(agentData.id, {
                    agent,
                    model,
                    config: agentData.config,
                    messages: agentData.messages || [],
                    status: 'ready',
                    color: agentData.color || state.agentColors[state.colorIndex++ % state.agentColors.length]
                });
            }

            updateAgentUI();
            updateRingUI();
            saveState();
            showToast('State imported');
        } catch (e) {
            showToast('Import failed: ' + e.message);
        }

        event.target.value = '';
    };

    window.clearAllData = function() {
        if (!confirm('Clear all agents and data?')) return;
        localStorage.removeItem('agi_multi_state');
        location.reload();
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CUSTOM TOOLS UI
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateCustomToolsUI() {
        const container = document.getElementById('customToolsList');
        if (!container) return;

        const customTools = loadCustomTools();
        const toolNames = Object.keys(customTools);

        if (toolNames.length === 0) {
            container.innerHTML = `
                <div style="color:var(--text-tertiary);">
                    No custom tools yet. Agents can create tools with <code>create_tool</code>.
                </div>
            `;
        } else {
            container.innerHTML = `
                <div style="margin-bottom:8px;color:var(--text-secondary);">
                    ${toolNames.length} custom tool(s) saved:
                </div>
                ${toolNames.map(name => {
                    const tool = customTools[name];
                    return `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:6px;margin-bottom:4px;">
                            <div>
                                <code style="color:var(--text)">${name}</code>
                                <span style="color:var(--text-tertiary);font-size:11px;margin-left:8px;">${tool.description?.slice(0,40) || ''}...</span>
                            </div>
                            <button onclick="deleteCustomTool('${name}')" style="background:transparent;border:none;color:rgba(255,100,100,0.6);cursor:pointer;font-size:12px;" title="Delete tool">‚úï</button>
                        </div>
                    `;
                }).join('')}
                <div style="margin-top:12px;font-size:11px;color:var(--text-tertiary);">
                    ‚ö†Ô∏è Custom tools are available to newly spawned agents. Refresh page to apply to all.
                </div>
            `;
        }
    }

    window.deleteCustomTool = function(name) {
        if (!confirm(`Delete custom tool "${name}"?`)) return;
        const customTools = loadCustomTools();
        delete customTools[name];
        saveCustomTools(customTools);
        updateCustomToolsUI();
        showToast(`Tool "${name}" deleted`);
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    loadState();

    // üîë Listen for credential changes from other tabs
    window.addEventListener('agimesh:credentials', (e) => {
        const creds = e.detail;
        if (creds.anthropic?.apiKey) state.credentials.anthropic.apiKey = creds.anthropic.apiKey;
        if (creds.openai?.apiKey) state.credentials.openai.apiKey = creds.openai.apiKey;
        if (creds.bedrock?.apiKey) state.credentials.bedrock.apiKey = creds.bedrock.apiKey;
        // Update UI if settings modal is open
        const anthropicInput = document.getElementById('anthropicKey');
        if (anthropicInput) anthropicInput.value = state.credentials.anthropic.apiKey;
        const openaiInput = document.getElementById('openaiKey');
        if (openaiInput) openaiInput.value = state.credentials.openai.apiKey;
        const bedrockInput = document.getElementById('bedrockKey');
        if (bedrockInput) bedrockInput.value = state.credentials.bedrock.apiKey;
        console.log('[agi.html] Credentials synced from another tab');
        showToast('Credentials synced from another tab');
    });

    // üîó Listen for ring context changes from other tabs (via localStorage)
    window.addEventListener('storage', (e) => {
        if (e.key === 'agi-mesh-ring-context') {
            console.log('[agi.html] Ring context updated from another tab');
            updateRingUI();
        }
    });

    // üîó Listen for ring context updates via AgentMesh BroadcastChannel
    // Delayed to ensure agent-mesh.js has loaded
    setTimeout(() => {
        if (window.AgentMesh?.subscribe) {
            window.AgentMesh.subscribe('ring-update', () => {
                console.log('[agi.html] Ring context broadcast received');
                updateRingUI();
            });
            window.AgentMesh.subscribe('ring-clear', () => {
                console.log('[agi.html] Ring context cleared via broadcast');
                updateRingUI();
            });
            console.log('[agi.html] Subscribed to AgentMesh ring events');
        }
    }, 600);
    updateAgentUI();
    updateRingUI();
    updateScheduleUI();
    renderMessages();

    // Check for ?q= query parameter (iPhone shortcut support)
    function checkForQueryParam() {
        const url = new URL(window.location.href);
        const query = url.searchParams.get('q');

        if (query) {
            // Clear URL params without reload
            window.history.replaceState({}, '', window.location.pathname);

            // Wait for agents to initialize, then send query
            setTimeout(async () => {
                if (state.agents.size === 0) {
                    // Try to create default agent first
                    await autoCreateDefaultAgent();
                }

                if (state.agents.size > 0) {
                    console.log('üì± Running query from URL param:', query);
                    const targetAgent = state.activeAgentId || state.agents.keys().next().value;
                    if (targetAgent) {
                        runAgentMessage(targetAgent, query);
                    }
                } else {
                    showToast('Add API key in Settings first');
                }
            }, 1500);
        }
    }
    checkForQueryParam();

    // Check for ?import= param (encrypted settings sync)
    checkForImportParam();

    // Update custom tools UI when tools tab is shown
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            if (e.target.textContent.trim() === 'Tools') {
                updateCustomToolsUI();
            }
        });
    });

    // Run auto-create after a short delay to ensure UI is ready
    setTimeout(autoCreateDefaultAgent, 100);

    // üîë Delayed credential sync after AgentMesh initializes
    setTimeout(() => {
        if (window.AgentMesh?.getCredentials) {
            const meshCreds = window.AgentMesh.getCredentials();
            let updated = false;
            if (meshCreds.anthropic?.apiKey && !state.credentials.anthropic.apiKey) {
                state.credentials.anthropic.apiKey = meshCreds.anthropic.apiKey;
                updated = true;
            }
            if (meshCreds.openai?.apiKey && !state.credentials.openai.apiKey) {
                state.credentials.openai.apiKey = meshCreds.openai.apiKey;
                updated = true;
            }
            if (meshCreds.bedrock?.apiKey && !state.credentials.bedrock.apiKey) {
                state.credentials.bedrock.apiKey = meshCreds.bedrock.apiKey;
                updated = true;
            }
            if (updated) {
                console.log('üîë Loaded credentials from AgentMesh unified storage');
                saveState();
                // Try to create default agent if none exists
                if (state.agents.size === 0) {
                    autoCreateDefaultAgent();
                }
            }
        }
    }, 600);

    // Request notification permission
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EXPOSE FOR AGENT MESH (cross-page communication)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window.state = state;
    window.runAgentMessage = runAgentMessage;

    console.log('%cü¶Ü agi.diy Multi-Agent v1.0', 'font-size:16px;font-weight:bold;');
    console.log('%cSpawn agents, schedule tasks, let them coordinate via ring attention.', 'color:#888');
    </script>
<script src="mesh-nav.js"></script>
<script src="agent-mesh.js"></script>
<script>
// Populate mesh navigation after AgentMesh loads
setTimeout(() => window.MeshNav?.populate('meshNavSlot'), 500);
</script>
</body>
</html>
